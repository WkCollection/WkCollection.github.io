{"meta":{"title":"编程の路","subtitle":"Codeing成神之路!","description":"这辈子只管努力,剩下的交给命运!","author":"BlueHole","url":"https://WkCollection.github.io","root":"/"},"pages":[{"title":"标签","date":"2022-06-19T09:09:48.000Z","updated":"2022-06-19T09:37:45.387Z","comments":true,"path":"tags/index.html","permalink":"https://wkcollection.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-06-19T07:55:46.000Z","updated":"2022-06-19T09:37:35.268Z","comments":true,"path":"categories/index.html","permalink":"https://wkcollection.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-06-19T06:17:26.000Z","updated":"2022-06-19T10:28:31.579Z","comments":true,"path":"about/index.html","permalink":"https://wkcollection.github.io/about/index.html","excerpt":"","text":"我如果爱你绝不像攀援的凌霄花借你的高枝炫耀自己我如果爱你绝不学痴情的鸟儿为绿荫重复单调的歌曲也不止像泉源常年送来清凉的慰藉也不止像险峰增加你的高度，衬托你的威仪甚至日光甚至春雨不，这些都还不够我必须是你近旁的一株木棉作为树的形象和你站在一起根，紧握在地下叶，相触在云里每一阵风过我们都互相致意但没有人听懂我们的言语你有你的铜枝铁干像刀，像剑，也像戟我有我红硕的花朵像沉重的叹息又像英勇的火炬我们分担寒潮、风雷、霹雳我们共享雾霭、流岚、虹霓仿佛永远分离却又终身相依这才是伟大的爱情坚贞就在这里爱不仅爱你伟岸的身躯也爱你坚持的位置足下的土地"}],"posts":[{"title":"Git学习","slug":"Git学习","date":"2022-06-19T11:43:08.000Z","updated":"2022-06-19T11:58:45.106Z","comments":true,"path":"2022/06/19/Git学习/","link":"","permalink":"https://wkcollection.github.io/2022/06/19/Git%E5%AD%A6%E4%B9%A0/","excerpt":"Git学习","text":"Git学习 学习git这一种主流的版本控制系统 什么是”版本控制”？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 git的三种状态已提交：commited已提交表示数据已经安全的保存在本地数据库中。 已修改：modified已修改表示修改了文件，但还没保存到数据库中。 已暂存：staged已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 git的三个工作区 git仓库Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，其它计算机克隆 仓库时，拷贝的就是这里的数据。 工作目录工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘 上供你使用或修改。 暂存区域暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作’’索 引’’，不过一般说法还是叫暂存区域。 基本的 Git 工作流程 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 git的安装Linux上安装以Fedora 上为例： 1sudo yum install git 如果你在基于 Debian 的发行版上： 1sudo apt-get install git Mac上安装最简单的方法是安装 Xcode或者git官网 下载二进制文件安装 Windows上安装在 Windows 上安装 Git 也有几种安装方法。官方版本可以在 Git 官方网站下载。 从源代码安装如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版： 12sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-develsudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev 为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包： 12sudo yum install asciidoc xmlto docbook2xsudo apt-get install asciidoc xmlto docbook2x 从 GitHub 网站上的镜像来获得最新发布版本的 tar 包 123456tar -zxf git-2.0.0.tar.gzcd git-2.0.0 make configure ./configure --prefix=/usr make all doc info sudo make install install-doc install-html install-info git的配置初次启动（配置环境变量）对于Linux系统，Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。这些变量存储在三个不同的位 置： &#x2F;etc&#x2F;gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的git config 时，它会从此文件读写配置变量。 ~&#x2F;.gitconfig 或 ~&#x2F;.config&#x2F;git&#x2F;config 文件：只针对当前用户。 可以传递 –global 选项让 Git读写此文件。 当前使用仓库的 Git 目录中的 config 文件（就是 .git&#x2F;config）：针对该仓库。 每一个级别覆盖上一级别的配置，所以 .git&#x2F;config 的配置变量会覆盖 &#x2F;etc&#x2F;gitconfig 中的配置变量。 对于windows系统，Git 会查找 $HOME$ 目录下（一般情况下是 C:\\Users\\$USER$）的 .gitconfig 文 件。 设置用户信息每一次 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 12git config --global user.name &quot;Mr.W&quot; #配置用户名git config --global user.email xxxxxxxx@qq.com #配置邮箱 使用–global代表全局设置，该命令只需要运行一次，之后无论你在该系统上做任何事情， Git 都会使用这些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行不带 –global 选项的命令来配置。 指定文本编辑器Git 会使用操作系统默认的文本编辑器，通常是 Vim。如果你想使用不同的文本编辑器，例如 Emacs，可以这样做： 1git config --global core.editor emacs 检查配置信息如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。 1git config --list 可以通过输入 git config ： 来检查 Git 的某一项配置： 1git config user.name 获取帮助手册123git help &lt;verb&gt; #方式一git &lt;verb&gt; --help #方式二man git-&lt;verb&gt; #在linux上可以方式三 git基础获取git仓库 在现有项目或目录下导入所有文件到 Git 中 从一个服务器克隆一个现有的 Git 仓库 初始化仓库进入该项目目录并输入： 1git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是Git 仓库的核心。 如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。你可通过 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交： 123git add *.cgit add LICENSEgit commit -m &#x27;initial project version&#x27; 克隆仓库如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令。当执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 1git clone [url] 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令： 1git clone [url] 本地仓库的名字 经常报错: OpenSSL SSL_read: Connection was reset, errno 10054解决方法如下： 1git config --global http.sslVerify &quot;false&quot; Git 支持多种数据传输协议。上面的例子使用的是 https:&#x2F;&#x2F; 协议，不过你也可以使用 git:&#x2F;&#x2F; 协议或者使用SSH 传输协议，比如 user@server:path&#x2F;to&#x2F;repo.git 记录每次更新到仓库工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放 入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。使用 Git 时文件的生命周期如下： 检查当前文件状态要查看哪些文件处于什么状态，可以用 git status 命令 1git status 如果在克隆仓库后立即使用此命令，会看到类似这样的输出： 12On branch masternothing to commit, working directory clean 这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息 还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是 “master”,这是默认的分支名。 跟踪新文件使用命令 git add 开始跟踪一个文件。所以，要跟踪 README 文件，运行： 1git add README 此时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态： 123456git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README 只要在 Changes to be committed 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。 暂存已修改文件现在我们来修改一个已被跟踪的文件。如果你修改了一个名为 Git.md 的已被跟踪的文件，然后运行 git status 命令，会看到下面内容： 12345678910On branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: Git.md new file: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Git.md 文件 Git.md 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 git add 命令。这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 123456789git add Git.mdgit statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: Git.md new file: README 现在两个文件都已暂存，下次提交时就会一并记录到仓库。假设此时，你想要在 CONTRIBUTING.md 里再加条注释，重新编辑存盘后，准备好提交。不过且慢，再运行 git status 看看： 12345678910On branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: Git.md new file: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Git.md 现在 Git.md 文件同时出现在暂存区和非暂存区。实际上 Git 只不过暂存了你运行 git add 命令时的版本，如果你现在提交，Git.md 的版本是你最后一次运行git add 命令时的那个版本，而不是你运行 git commit 时，在工作目录中的当前版本。所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来： 123456789git add Git.mdgit status On branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: Git.md new file: README 状态简览git status 命令的输出十分详细，但其用语有些繁琐。如果你使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出。 1234567git status -s M READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,lib/simplegit.rb 文件被修改了并将修改后的文件放入了暂存区。而Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。 忽略文件(.gitignore)一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文 件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为 .gitignore的文件，列出要忽略的文件模式。来看一个实际的例子： 1234cat .gitignore*.[oa]*~ 文件 .gitignore 的格式规范如下： 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以/开头防止递归。 匹配模式可以以/结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号*匹配零个或多个任意字符；[abc] 匹配任 何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号?只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。使用两个星号** 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z,a/b/z 或 a/b/c/z等。 查看已暂存和未暂存的修改如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。git diff 将通过文件补丁的格式显示具体哪些行发生了改变。 12345678910111213git diffwarning: LF will be replaced by CRLF in Git.md.The file will have its original line endings in your working directorydiff --git a/Git.md b/Git.mdindex b49f414..661e036 100644--- a/Git.md+++ b/Git.md@@ -1,3 +1,4 @@ Git Test Modified Second Modified+Third Modified 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。 若要查看已暂存的将要添加到下次提交里的内容，可以使用 git diff –staged 提交更新现在的暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit： 1git commit 默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。如果想要更详细的对修改了哪些内容的提示，可以用 -v 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。 另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行： 1git commit -m &quot;git second commit&quot; 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤： 1git commit -a -m &quot;git third commit&quot; 移除文件要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单了。 如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是未暂存清单）看到： 1234567git rm READMEgit statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) deleted: README 下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f。这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 git 恢复。 另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 12345678910git rm --cached test.txtgit statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) deleted: test.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) test.txt 移动文件1234567891011git mv Git.md git.mdgit statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) renamed: Git.md -&gt; git.md deleted: test.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) test.txt 其实，运行 git mv 就相当于运行了下面三条命令： 123mv README.md READMEgit rm README.mdgit add README 查看提交历史在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史.完成这个任务最简单而又有效的工具是 git log 命令。 1git log 默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 git log 有许多选项可以帮助你搜寻你所要找的提交，接下来我们介绍些最常用的。一个常用的选项是 -p，用来显示每次提交的内容差异。你也可以加上 -2 来仅显示最近两次提交： 1git log -p -2 你也可以为 git log 附带一系列的总结性选项。比如说，如果你想看到每次提交的简略的统计信息，你可以使用 –stat 选项： 1git log --stat 另外一个常用的选项是 –pretty。这个选项可以指定使用不同于默认格式的方式展示提交历史。这个选项有一些内建的子选项供你使用。比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。另外还有short，full 和 fuller 可以用，展示的信息或多或少有些不同。 1git log --pretty=oneline 有用的是 format，可以定制要显示的记录格式。 1git log --pretty=format:&quot;%h - %an, %ar : %s&quot; git log –pretty&#x3D;format 常用的选项 列出了常用的格式占位符写法及其代表的意义。 当 oneline 或 format 与另一个 log 选项 –graph 结合使用时尤其有用。这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史： 1git log --pretty=format:&quot;%h %s&quot; --graph git log 的常用选项: 限制输出长度除了定制输出格式的选项之外，git log 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。之前你已经看到过 -2 了，它只显示最近的两条提交，实际上，这是 - 选项的写法，其中的 n 可以是任何整数，表示仅显示最近的若干条提交。不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调 用分页程序，所以你一次只会看到一页的内容。 另外还有按照时间作限制的选项，比如 –since 和 –until 也很有用。例如，下面的命令列出所有最近两周内的提交： 1git log --since=2.weeks 另一个非常有用的筛选选项是 -S，可以列出那些添加或移除了某些字符串的提交。比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用： 1git log -SModified 限制 git log 输出的选项: 撤消操作在任何一个阶段，你都有可能想要撤消某些操作。这里，我们将会学习几个撤消你所做修改的基本工具。 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 –amend 选项的提交命令尝试重新提交，这个命令会将暂存区中的文件提交。： 1git commit --amend 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。 取消暂存的文件例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了git add * 暂存了它们两个。如何只取消暂存两个中的一个呢？ 1git reset HEAD CONTRIBUTING.md 撤消对文件的修改如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 1git checkout -- CONTRIBUTING.md git远程仓库 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 查看远程仓库如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。它会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字： 1git remote 你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。 1git remote -v 添加远程仓库首先在github上创建一个仓库，然后clone到本地，再然后运行git remote add 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写： 1git remote add gs https://github.com/mygit-WK/gStudy.git 现在你可以在命令行中使用字符串 gs来代替整个 URL。例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch gs： 1git fetch gs 从远程仓库中抓取与拉取从远程仓库中获得数据，可以执行： 1git fetch [remote-name] 这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。所以git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。必须注意 git fetch 命令会将数据拉取到你的本地仓库它并不会自动合并或修改你当前的工作。 如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送到远程仓库当你想分享你的项目时，必须将其推送到上游。这个命令很简单：git push [remote-name] [branch-name]。当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器： 1git push origin master 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 查看远程仓库如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息： 1git remote show origin 远程仓库的移除与重命名如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 1git remote rename gs gitstudy 可以使用 git remote rm 来移除远程仓库： 1git remote rm gitstudy git标签列出标签1git tag 创建标签Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated） 在 Git 中创建一个附注标签是很简单的。最简单的方式是当你在运行 tag 命令时指定 -a 选项，-m 选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息： 1git tag -a v1.0 -m &#x27;my version 1.0&#x27; 通过使用 git show 命令可以看到标签信息与对应的提交信息： 1git show v1.0 另一种给提交打标签的方式是使用轻量标签。轻量标签本质上是将提交校验和存储到一个文件中,没有保存任何其他信息。创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字： 1git tag v1.0-lw 后期打标签你也可以对过去的提交打标签。现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。你可以在之后补上标签。要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）: 1git tag -a v1.2 9fceb02 共享标签默认情况下，git push 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样 - 你可以运行 git push origin [tagname]。 1git push origin v1.5 如果想要一次性推送很多标签，也可以使用带有 –tags 选项的 git push 命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。 1git push origin --tags 检出标签在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支： 1git checkout -b version2 v2.0.0 Git 别名Git 并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的 Git 命令，可以通过 gitconfig 文件来轻松地为每一个命令设置一个别名。这里有一些例子你可以试试： 1234git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st status 这意味着，当要输入 git commit时，只需要输入 git ci。 可以向 Git 中 添加你自己的取消暂存别名： 1git config --global alias.unstage &#x27;reset HEAD --&#x27; 等价于： 12git unstage fileAgit reset HEAD -- fileA 通常也会添加一个 last 命令，可以轻松地看到最后一次提交： 1git config --global alias.last &#x27;log -1 HEAD&#x27;","categories":[{"name":"Git","slug":"Git","permalink":"https://wkcollection.github.io/categories/Git/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://wkcollection.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"git","slug":"git","permalink":"https://wkcollection.github.io/tags/git/"}]},{"title":"Cpp学习","slug":"Cpp","date":"2022-06-19T08:05:43.000Z","updated":"2022-06-19T09:45:21.041Z","comments":true,"path":"2022/06/19/Cpp/","link":"","permalink":"https://wkcollection.github.io/2022/06/19/Cpp/","excerpt":"C++学习","text":"C++学习 数组 方便存放同类型的元素 一维数组一维数组数组名代表数组的首地址 一维数组名可以计算出数组在内存空间所占内存大小 二维数组二维数组名代表二维数组的首地址，也可以查看某行的首地址 二维数组可以计算出数组在内存空间所占内存大小，也可以计算出某行所占内存大小 指针 作用：保存地址 指针的定义：数据类型 *指针变量名 32位操作系统指针所占内存空间：4个字节 64位操作系统指针所占内存空间：8个字节 指针的两大类型空指针： 指针变量指向内存编号为0的空间 空指针指向内存无法访问，0~255内存编号给系统占用的，无法访问 可用于给指针变量初始化 野指针：指针变量指向非法空间，要尽量避免 const与指针结合const修饰指针称为常量指针:指针指向的值不能变，指针的指向可以变 123456789101112#include &lt;iostream&gt;using namespace std;int main(int argc, char** argv) &#123;// 常量指针：指针指向的值不能变，指针的指向可以变 int a=20; const int *p=&amp;a; int b=30; p=&amp;b;//指针的指向可以改，由指向a修改为指向b // *p=b; 指向的值不能改 cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; const修饰常量称为指针常量：指针指向的值可以改，指针的指向不可以修改 123456789101112#include &lt;iostream&gt;using namespace std;int main(int argc, char** argv) &#123;// 指针常量：指针指向的值可以改，指针的指向不可以修改 int a=20; int * const p=&amp;a; int b=30; *p=b; //指向的值可以改// p=&amp;b;//指针的指向不能改 cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; const既修饰常量又修饰指针：指针的指向不能改，指针指向的值也不能改 123456789101112#include &lt;iostream&gt;using namespace std;int main(int argc, char** argv) &#123;// const既修饰常量又修饰指针：指针的指向不能改，指针指向的值也不能改 int a=20; const int * const p=&amp;a; int b=30;// *p=b; //指向的值不可以改// p=&amp;b;//指针的指向不能改 cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 指针与数组123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main(int argc, char** argv) &#123;// 访问数组的第一种方式 int array[10]= &#123;1,2,3,4,5,6,7,8,9,10&#125;; int *p; for(int i=0; i&lt;10; i++) &#123; cout&lt;&lt;array[i]&lt;&lt;endl; &#125; cout&lt;&lt;&quot;利用指针访问数组元素:&quot;&lt;&lt;endl; p=array;// 利用指针访问数组元素 for(int i=0; i&lt;10; i++) &#123; cout&lt;&lt;*p&lt;&lt;endl; p++; &#125; return 0;&#125; 指针与函数值传递：不会改变实参的值 地址传递（引用传递）：会改变实参的值 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;void swap(int a,int b);void swap2(int *a,int *b);int main(int argc, char** argv) &#123;// 指针函数// 值传递:不改变实参的值 int a=10,b=20; cout&lt;&lt;&quot;交换前:a:&quot;&lt;&lt;a&lt;&lt;&quot; b:&quot;&lt;&lt;b&lt;&lt;endl; swap(a,b); cout&lt;&lt;&quot;交换后:a:&quot;&lt;&lt;a&lt;&lt;&quot; b:&quot;&lt;&lt;b&lt;&lt;endl;// 引用传递：改变实参的值 cout&lt;&lt;&quot;交换前:a:&quot;&lt;&lt;a&lt;&lt;&quot; b:&quot;&lt;&lt;b&lt;&lt;endl; swap2(&amp;a,&amp;b); cout&lt;&lt;&quot;交换后:a:&quot;&lt;&lt;a&lt;&lt;&quot; b:&quot;&lt;&lt;b&lt;&lt;endl; return 0;&#125;void swap(int a,int b) &#123; int temp; temp=a; a=b; b=temp;&#125;void swap2(int *a,int *b) &#123; int temp; temp=*a; *a=*b; *b=temp;&#125; 结构体 属于用户自定义的数据类型 结构体定义语法：struct 结构体名 {结构体成员列表}； 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct people &#123; string name; int age; int sex;&#125; p3;void display(people p);int main(int argc, char** argv) &#123;// 1. struct 结构体名 变量名； struct people p1; p1.name=&quot;张三&quot;; p1.age=20; p1.sex=0; display(p1);// 2. struct 结构体名 变量名=&#123;值1，值2&#125;； struct people p2= &#123;&quot;李四&quot;,22,1&#125;; display(p2);// 3. 定义结构体时顺便创建变量； p3.name=&quot;王五&quot;; p3.age=26; p3.sex=3; display(p3); return 0;&#125;void display(people p) &#123; cout&lt;&lt;&quot;name:&quot;&lt;&lt;p.name&lt;&lt;&quot; age:&quot;&lt;&lt;p.age&lt;&lt;&quot; sex:&quot;&lt;&lt;p.sex&lt;&lt;endl;&#125; 结构体数组12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct people &#123; string name; int age;&#125;;int main(int argc, char** argv) &#123;// 结构体数组定义 people ps[2]= &#123; &#123;&quot;刘邦&quot;,200&#125;, &#123;&quot;周瑜&quot;,2000&#125; &#125;;// 结构体遍历 for(int i=0; i&lt;2; i++) &#123; cout&lt;&lt;&quot;name:&quot;&lt;&lt;ps[i].name&lt;&lt;&quot; age:&quot;&lt;&lt;ps[i].age&lt;&lt;endl; &#125; return 0;&#125; 结构体指针作用：通过指针访问结构体中的成员 结构体变量通过.操作符访问，结构体指针通过-&gt;访问结构体成员 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct people &#123; string name; int age;&#125;;int main(int argc, char** argv) &#123; people p1= &#123;&quot;张三&quot;,100&#125;; people *p=&amp;p1;// 利用结构体指针进行访问 cout&lt;&lt;&quot;name:&quot;&lt;&lt;p-&gt;name&lt;&lt;&quot; age:&quot;&lt;&lt;p-&gt;age&lt;&lt;endl; return 0;&#125; 内存四区代码区用途：存放函数体的二进制代码，由操作系统进行管理 代码区是共享的，共享是针对需要频繁执行的程序，只需要在内存中有一份代码即可 代码区是只读的，只读为了防止程序意外修改了指令 栈区用途：有编译器自动分配释放，存放函数的参数值、局部变量等 堆区用途：由程序员分配和释放，若程序员不分配释放，程序结束时由操作系统回收 使用new关键字进行内存申请，使用delete关键字进行内存释放，数组需要使用delete[]进行释放 全局区用途：存放全局变量、静态变量以及常量 包含常量区、字符串常量和其他常量 包括全局变量、全局常量、静态变量和字符串常量 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;// 全局变量int g=10;int h=10;// 全局常量const int i=10;const int j=10;int main(int argc, char** argv) &#123;// 局部变量 int a=10; int b=10; cout&lt;&lt;&quot;&amp;a=&quot;&lt;&lt;(int *)&amp;a&lt;&lt;&quot; &amp;b=&quot;&lt;&lt;(int *)&amp;b&lt;&lt;endl;// 局部常量 const int c=20; const int d=20; cout&lt;&lt;&quot;&amp;c=&quot;&lt;&lt;(int *)&amp;c&lt;&lt;&quot; &amp;d=&quot;&lt;&lt;(int *)&amp;d&lt;&lt;endl;// 静态变量 static int e=10; static int f=10; cout&lt;&lt;&quot;&amp;e=&quot;&lt;&lt;(int *)&amp;e&lt;&lt;&quot; &amp;f=&quot;&lt;&lt;(int *)&amp;f&lt;&lt;endl; cout&lt;&lt;&quot;&amp;g=&quot;&lt;&lt;(int *)&amp;g&lt;&lt;&quot; &amp;h=&quot;&lt;&lt;(int *)&amp;h&lt;&lt;endl; cout&lt;&lt;&quot;&amp;i=&quot;&lt;&lt;(int *)&amp;i&lt;&lt;&quot; &amp;j=&quot;&lt;&lt;(int *)&amp;j&lt;&lt;endl;// 字符串常量 cout&lt;&lt;&quot;&amp;str=&quot;&lt;&lt;(int *)&amp;&quot;hello world&quot;&lt;&lt;endl; return 0;&#125; C++特点引用 给内存地址取别名，本质是指针常量 基本语法：数据类型 &amp;别名&#x3D;原名 注意事项：引用必须初始化，一旦初始化不可更改 引用做函数参数：可以简化指针修改实参 引用做函数返回值：可以作为函数左值，但是不要返回局部变量的引用 常引用：可以防止形参改变实参，即变为只读状态 函数进阶函数默认参数：返回值类型 函数名（参数&#x3D;默认值）{}，如果某个参数有默认值那么从这个默认值开始从左向右都得有默认值；函数声明有默认值，那么实现就不能有默认值。 函数的占位参数：调用时必须传递实参。 函数重载：同一个作用域，函数名称相同，函数的参数类型不同或者个数不同或者顺序不同；返回值不作为函数重载的条件。 面向对象封装ex:设计圆类，通过半径求周长 1234567891011121314151617#include &lt;iostream&gt;#define PI 3.14using namespace std;class Circle &#123; public : //半径 float radius; float calc() &#123; return 2*PI*radius; &#125;&#125;;int main(int argc, char** argv) &#123; Circle c; c.radius=10; cout&lt;&lt;&quot;圆的周长为：&quot;&lt;&lt;c.calc()&lt;&lt;endl; return 0;&#125; 访问权限： 权限类型 类内 类外 public 允许 允许 protected 允许 不允许 private 允许 不允许 对于protected儿子可以访问父亲的保护内容 对于private儿子不可以访问父亲的保护内容 对象特性 空对象占用1bit的内存空间，编译器会给每个空对象也分配一个字节，是为了区分空对象的位置 构造函数和析构函数不提供构造函数和析构函数，编译器会默认提供空实现的构造函数和析构函数。 构造函数（进行初始化操作）：类名（）{} 构造函数的分类： 有参构造和无参构造 普通构造和拷贝构造 调用方法： 括号法：调用无参构造函数时别带小括号，否则编译器会认为是函数的声明 显示法：不能用拷贝构造函数初始化匿名对象，编译器会默认忽视小括号，从而造成重定义 隐式法 调用规则： 如果用户自定义有参构造函数，C++就不再提供默认无参构造函数，但是会提供默认拷贝构造函数 如果用户自定义拷贝构造函数，C++不在提供其他构造函数 析构函数（进行销毁操作）：~类名（）{} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Man &#123; public: Man() &#123; cout&lt;&lt;&quot;无参构造函数调用&quot;&lt;&lt;endl; &#125; Man(string name) &#123; this-&gt;name=name; cout&lt;&lt;&quot;有参构造函数调用&quot;&lt;&lt;endl; &#125; Man(const Man &amp;m) &#123; this-&gt;name=m.name; this-&gt;age=m.age; cout&lt;&lt;&quot;拷贝构造函数调用&quot;&lt;&lt;endl; &#125; ~Man() &#123; cout&lt;&lt;&quot;析构函数调用&quot;&lt;&lt;endl; &#125; private: string name; int age;&#125;;int main(int argc, char** argv) &#123; /** 调用方式: 括号法 显示法 隐式法 */// 方式一:括号法 Man m; Man m1(&quot;张三&quot;); Man m2(m1); /*注意：调用无参构造函数时别带小括号，这一点可Java有所不同， 同时使用this-&gt;而不是this.*/// 方式二：显示法 Man m3=Man(); Man m4=Man(&quot;李四&quot;); Man m5=Man(m4);// 匿名对象 Man(&quot;赵四&quot;); /*不能用拷贝构造函数初始化匿名对象 Man(m5)==Man m5,编译器会忽略小括号 */// 方式三：隐式法 Man m6=m5; return 0;&#125; 拷贝构造函数的作用： 使用一个已经创建完毕的对象来初始化新对象 值传递的方式传参 值方式返回局部对象 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class People &#123; public: People() &#123; cout&lt;&lt;&quot;默认构造函数调用&quot;&lt;&lt;endl; &#125; People(string name,int age) &#123; this-&gt;name=name; this-&gt;age=age; cout&lt;&lt;&quot;有参构造函数调用&quot;&lt;&lt;endl; &#125; People(const People &amp;p) &#123; this-&gt;name=p.name; this-&gt;age=p.age; cout&lt;&lt;&quot;拷贝构造函数调用&quot;&lt;&lt;endl; &#125; string name; int age;&#125;;void test(People p) &#123;&#125;People test1() &#123; People p(&quot;王五&quot;,10); return p;&#125;int main(int argc, char** argv) &#123;// 方式一：用一个已经创建好的对象来初始化新对象// People p(&quot;张三&quot;,18);// People p1(p);// 方式二：用于函数传参// test(p);// 方式三：用于返回局部对象 People p1=test1(); cout&lt;&lt;&quot;name:&quot;&lt;&lt;p1.name&lt;&lt;&quot; age:&quot;&lt;&lt;p1.age&lt;&lt;endl; return 0;&#125; 深拷贝与浅拷贝浅拷贝：简单的赋值操作，会导致内存重复释放 深拷贝：在堆区重新申请空间，进行拷贝操作 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class People &#123; public: People() &#123; cout&lt;&lt;&quot;无参构造函数&quot;&lt;&lt;endl; &#125; People(string name,int age,int height) &#123; this-&gt;name=name; this-&gt;age=age; this-&gt;height=new int(height); cout&lt;&lt;&quot;有参构造函数&quot;&lt;&lt;endl; &#125; People(const People &amp;p) &#123; this-&gt;name=p.name; this-&gt;age=p.age;// this-&gt;height=p.height;//为了解决浅拷贝所带来的内存重复释放的问题，在拷贝时主动向堆区申请一块内存空间 this-&gt;height=new int(*p.height);//此语句解决浅拷贝所带的问题 cout&lt;&lt;&quot;拷贝构造函数&quot;&lt;&lt;endl; &#125; ~People() &#123; if(height!=NULL) &#123; delete height; height=NULL; &#125; cout&lt;&lt;&quot;析构函数调用&quot;&lt;&lt;endl; &#125; string name;//姓名 int age;//年龄 int *height;//身高&#125;;int main(int argc, char** argv) &#123; People p(&quot;张胜男&quot;,18,170); cout&lt;&lt;&quot;name:&quot;&lt;&lt;p.name&lt;&lt;&quot; age:&quot;&lt;&lt;p.age&lt;&lt;&quot; height:&quot;&lt;&lt;*p.height&lt;&lt;endl; People p1(p); cout&lt;&lt;&quot;name:&quot;&lt;&lt;p1.name&lt;&lt;&quot; age:&quot;&lt;&lt;p1.age&lt;&lt;&quot; height:&quot;&lt;&lt;*p1.height&lt;&lt;endl; return 0;&#125; 初始化列表12345678910111213#include &lt;iostream&gt;using namespace std; class People&#123; public: People(int age,int sex):age(age),sex(sex)&#123; &#125; int age; int sex;&#125;;int main(int argc, char** argv) &#123; People p(18,0); return 0;&#125; 静态成员 静态成员变量 所有对象共享一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数：可以通过对象或类名访问 所有对象共享同一个函数 静态成员函数只能访问静态成员变量，不能访问非静态成员变量 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class People &#123; public: People() &#123; &#125; People(int age) &#123; this-&gt;age=age; &#125; int age; static int sex; static void func() &#123; cout&lt;&lt;&quot;性别是:&quot;&lt;&lt;sex&lt;&lt;endl; &#125;&#125;;// 类外初始化int People::sex=1;int main(int argc, char** argv) &#123;// 方式一：对象名 People p(10); p.func();// 方式二：类名 People::func(); return 0;&#125; this指针与空指针this的用途：解决命名冲突和制造链式调用 空指针也能访问成员函数，需要加以判断保证代码的健壮性 常函数和常对象 常函数内不可以修改成员属性 成员属性加mutable后就可以修改属性 常对象只能调用常函数 123456789101112131415161718#include &lt;iostream&gt;using namespace std;class People &#123; public: People(int age,int sex) &#123; this-&gt;age=age; this-sex=sex; &#125;// 常函数 ，加const后实际上修饰的是this，则this指向的内容也不可以改 void print() const &#123; cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;&quot; sex:&quot;&lt;&lt;sex&lt;&lt;endl; &#125; int age; int sex;&#125;;int main(int argc, char** argv) &#123; return 0;&#125; 友元全局函数做友元12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class People &#123;// 告诉编译器goodBrother是People的友元函数，可以访问People的private变量 friend void goodBrother(People &amp;p); public: People() &#123; this-&gt;sitroom=&quot;客厅&quot;; this-&gt;bedroom=&quot;卧室&quot;; &#125; public: string sitroom; private: string bedroom;&#125;;void goodBrother(People &amp;p) &#123; cout&lt;&lt;&quot;好兄弟正在进入你的&quot;&lt;&lt;p.sitroom&lt;&lt;endl; cout&lt;&lt;&quot;好兄弟正在进入你的&quot;&lt;&lt;p.bedroom&lt;&lt;endl;&#125;int main(int argc, char** argv) &#123; People p; goodBrother(p); return 0;&#125; 友元类12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Brother &#123;// 声明People是Brother的友元类 friend class People; public: Brother() &#123; wc=&quot;厕所&quot;; bathroom=&quot;浴室&quot;; &#125; string wc; private: string bathroom;&#125;;class People &#123; public: People() &#123; sittingroom=&quot;客厅&quot;; bedroom=&quot;卧室&quot;; &#125; string sittingroom; void visit(Brother &amp;b) &#123; cout&lt;&lt;&quot;正在访问好兄弟的&quot;&lt;&lt;b.bathroom&lt;&lt;endl; &#125; private: string bedroom;&#125;;int main(int argc, char** argv) &#123; Brother b; People p; p.visit(b); return 0;&#125; 成员函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;//成员函数做友元class Building;class GoodGay&#123;public: GoodGay(); ~GoodGay(); void visit();// 让 visit 访问Building中的私有函数 void visit2();// 让 visit2 不可以访问Building中的私有函数 Building *building;//指向对象的指针，在构造函数中要初始化指针&#125;;class Building&#123; //GoodGay类下的visit成员函数作为本类的好朋友，可以访问私有成员变量 friend void GoodGay::visit();public: string m_SittingRoom; Building();private: string m_BedRoom;&#125;;Building::Building()&#123; m_SittingRoom = &quot;客厅&quot;; m_BedRoom = &quot;卧室&quot;;&#125;GoodGay::GoodGay()&#123; //创建一个建筑物的对象 //用new再堆区中申请一片空间返回的是一个指针，用building来接受这个指针，完成building初始化 building = new Building; &#125;GoodGay::~GoodGay()&#123; delete building;&#125;void GoodGay::visit()&#123; cout &lt;&lt; &quot;visit函数: Public &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;visit函数: Private &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void GoodGay::visit2()&#123; cout &lt;&lt; &quot;visit2函数: Public &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //visit2函数不是Building的友元函数，不能访问其私有变量m_BedRoom&#125;void test01()&#123; GoodGay gg; gg.visit(); gg.visit2();&#125;int main()&#123; test01(); return 0;&#125; 运算符重载加号运算符重载成员函数重载+运算符和全局函数重载+运算符 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 加号运算符重载class Number &#123; public: Number() &#123; &#125; Number(int n) &#123; this-&gt;num=n; &#125;// 成员函数重载+// Number operator+(Number &amp;n) &#123;// Number temp;// temp.num=this-&gt;num+n.num;// return temp;// &#125; int num;&#125;;// 全局函数重载+Number operator+(Number &amp;n1,Number &amp;n2) &#123; Number n3; n3.num= n1.num+n2.num; return n3;&#125;int main(int argc, char** argv) &#123; Number n(10); Number n1(15); Number n2=n+n1; cout&lt;&lt;n2.num&lt;&lt;endl; return 0;&#125; 左移运算符重载只能利用全局函数重载左移运算符 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//左移运算符重载&lt;&lt;class Number &#123;// 如果数据私有可以使用友元 public: Number(int n) &#123; this-&gt;num=n; &#125; int num;&#125;;// 全局函数重载&lt;&lt;运算符ostream&amp; operator&lt;&lt;(ostream &amp;cout,Number &amp;n) &#123; cout&lt;&lt;n.num; return cout;&#125;int main(int argc, char** argv) &#123; Number n1(10); cout&lt;&lt;n1&lt;&lt;endl; return 0;&#125; 递增运算符重载前置++运算符重载 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Number &#123; public : Number() &#123; &#125; Number(int num) &#123; this-&gt;num=num; &#125; int num;// 前置++重载 Number&amp; operator++() &#123; ++num; return *this; &#125;&#125;;ostream&amp; operator&lt;&lt;(ostream &amp;cout,Number n) &#123; cout&lt;&lt;n.num; return cout;&#125;int main(int argc, char** argv) &#123; Number n(10); cout&lt;&lt;++(++n)&lt;&lt;endl; cout&lt;&lt;n&lt;&lt;endl; return 0;&#125; 后置++运算符重载 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Number &#123; friend ostream&amp; operator&lt;&lt;(ostream &amp;cout,Number n); public : Number() &#123; &#125; Number(int num) &#123; this-&gt;num=num; &#125;// 前置++重载 Number&amp; operator++() &#123; ++num; return *this; &#125;// 后置 ++重载 Number operator++(int) &#123; Number temp=*this; num++; return temp; &#125; int num;&#125;;ostream&amp; operator&lt;&lt;(ostream &amp;cout,Number n) &#123; cout&lt;&lt;n.num; return cout;&#125;int main(int argc, char** argv) &#123; Number n(10); cout&lt;&lt;n++; return 0;&#125; 赋值运算符重载123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class People &#123; public: People(int age) &#123; p_age=new int(age); &#125; ~People() &#123; if(p_age!=NULL) &#123; delete p_age; p_age=NULL; &#125; &#125;// =运算符重载 People&amp; operator=(People &amp;p) &#123;// 如果自身有内存先释放干净 if(p_age!=NULL) &#123; delete p_age; p_age=NULL; &#125; this-&gt;p_age= new int(*p.p_age); return *this; &#125; int *p_age;&#125;;int main(int argc, char** argv) &#123; People p1(10); People p2(18); p2=p1; cout&lt;&lt;&quot;age:&quot;&lt;&lt;*p2.p_age&lt;&lt;endl; return 0;&#125; 关系运算符重载123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123; public: Person() &#123; &#125; Person(int age) &#123; this-&gt;age=age; &#125;// 关系运算符重载 bool operator==(Person &amp;p) &#123; if(p.age==this-&gt;age) &#123; return true; &#125; else &#123; return false; &#125; &#125; int age;&#125;;ostream&amp; operator&lt;&lt;(ostream &amp;cout,Person &amp;p) &#123; cout&lt;&lt;p.age; return cout;&#125;int main(int argc, char** argv) &#123; Person p(10); Person p1(10); if(p==p1) &#123; cout&lt;&lt;&quot;相等&quot;&lt;&lt;endl; &#125; return 0;&#125; 函数调用运算符重载又称为仿函数，写法很灵活 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Print &#123; public: Print() &#123; &#125; void operator()(string valueString) &#123; cout&lt;&lt;valueString&lt;&lt;endl; &#125;&#125;;int main(int argc, char** argv) &#123; Print print; print(&quot;hello world!&quot;); return 0;&#125; 继承用处：去重，减少冗余 语法:class 派生类：继承方式 父类 三种继承方式：（父类中的私有属性，子类无论哪种继承都访问不到） 公共继承：父类的public和protected属性保持不变，私有属性访问不到 保护继承：父类的public和protected属性变为子类的protected属性，私有属性访问不到 私有继承：父类的public和protected属性变为子类的private属性，私有属性访问不到 父类中所有的非静态成员属性都会被子类继承下去，只是私有属性被编译器隐藏了，所以访问不到 查看对象模型： 1cl /dl reportSingleClassLayout类名 文件名 继承中的构造和析构的顺序析构顺序与构造顺序相反 父类构造-&gt;子类构造-&gt;子类析构-&gt;父类析构 子类继承访问同名成员的处理 访问子类同名成员，直接访问即可 访问父类同名成员，加作用域即可 子类出现和父类同名的成员，子类会隐藏父类所有的同名成员函数 子类继承访问静态成员的处理两种访问方式：对象名和类名 访问子类同名成员，直接访问即可 访问父类同名成员，加作用域即可 子类出现和父类同名的静态成员，子类会隐藏父类所有的同名静态成员函数 多继承（不建议使用） 语法：class 子类：继承方式 父类1，继承方式 父类2 菱形继承概念：两个类继承一个基类，又有一个类继承这两个派生类 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//动物类//通过使用virtual关键字解决菱形继承问题class Animal &#123; public: int age;&#125;;//羊类class Sheep:virtual public Animal &#123;&#125;;//驼类class Tuo:virtual public Animal &#123;&#125;;//羊驼类class SheepTuo:public Sheep,public Tuo &#123;&#125;;int main(int argc, char** argv) &#123; SheepTuo st; st.Tuo::age=28; st.Sheep::age=18; cout&lt;&lt;&quot;st.Sheep::age:&quot;&lt;&lt;st.Sheep::age&lt;&lt;endl; cout&lt;&lt;&quot;st.Tuo::age:&quot;&lt;&lt;st.Tuo::age&lt;&lt;endl; cout&lt;&lt;&quot;st.age:&quot;&lt;&lt;st.age&lt;&lt;endl; return 0;&#125; 多态 静态多态：函数重载和运算符重载，编译阶段确定函数地址，地址早绑定 动态多态：派生类和虚函数，运行阶段确定函数地址，地址晚绑定 虚函数12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Animal &#123; public:// 此刻地址早绑定// void speak() &#123;// cout&lt;&lt;&quot;动物在说话&quot;&lt;&lt;endl;// &#125;// 加virtual变成虚函数地址晚绑定 virtual void speak() &#123; cout&lt;&lt;&quot;动物在说话&quot;&lt;&lt;endl; &#125;&#125;;class Cat:public Animal &#123; public : void speak() &#123; cout&lt;&lt;&quot;喵喵~~&quot;&lt;&lt;endl; &#125;&#125;;class Dog:public Animal &#123; public : void speak() &#123; cout&lt;&lt;&quot;汪汪~~&quot;&lt;&lt;endl; &#125;&#125;;int main(int argc, char** argv) &#123; Cat cat; Dog dog;// Animal &amp;animal=cat; Animal &amp;animal=dog; animal.speak(); return 0;&#125; 纯虚函数和抽象类有纯虚函数的类称为抽象类 语法：virtual 返回值类型 函数名（参数列表）&#x3D;0； 抽象类特点： 无法实例化 子类必须重写抽象类的纯虚函数，否则子类也属于抽象类 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Animal &#123; public:// 变成纯虚函数 virtual void speak()=0;&#125;;class Cat:public Animal &#123; public : void speak() &#123; cout&lt;&lt;&quot;喵喵~~&quot;&lt;&lt;endl; &#125;&#125;;class Dog:public Animal &#123; public : void speak() &#123; cout&lt;&lt;&quot;汪汪~~&quot;&lt;&lt;endl; &#125;&#125;;int main(int argc, char** argv) &#123; Cat cat; Dog dog;// Animal &amp;animal=cat; Animal &amp;animal=dog; animal.speak(); return 0;&#125; 虚析构和纯虚析构有纯虚析构的类也称为抽象类 用处：如果子类属性开辟到堆区，那么父类指针在释放时无法调用子类的析构代码 虚析构语法：virtual ~类名（）{} 纯虚析构：virtual ~类名（）&#x3D;0；必须要有具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Animal &#123; public: Animal() &#123; cout&lt;&lt;&quot;Animal构造函数调用&quot;&lt;&lt;endl; &#125;// 利用虚析构// virtual ~Animal() &#123;// cout&lt;&lt;&quot;Animal析构函数调用&quot;&lt;&lt;endl;// &#125;// 利用纯虚析构 virtual ~Animal()=0;&#125;;class Cat:public Animal &#123; public : Cat() &#123; cout&lt;&lt;&quot;Cat构造函数调用&quot;&lt;&lt;endl; &#125; Cat(string name) &#123; this-&gt;name=new string(name); cout&lt;&lt;&quot;Cat有参构造函数调用&quot;&lt;&lt;endl; &#125; ~Cat() &#123; if(name!=NULL) &#123; delete name; name=NULL; &#125; cout&lt;&lt;&quot;Cat析构函数调用&quot;&lt;&lt;endl; &#125; string *name;&#125;;Animal::~Animal() &#123; cout&lt;&lt;&quot;Animal析构函数调用&quot;&lt;&lt;endl;&#125;int main(int argc, char** argv) &#123; Animal *animal=new Cat(&quot;小白&quot;); delete animal; return 0;&#125; C++泛型编程模板 用途：提高复用性 函数模板语法：template，typename可以用class代替 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//利用模板template &lt;typename T&gt;void Swap(T &amp;a,T &amp;b) &#123; T temp; temp=a; a=b; b=temp;&#125;int main(int argc, char** argv) &#123; int a=10,b=20; float c=10.9,d=10.6; Swap(a,b); cout&lt;&lt;a&lt;&lt;&quot; ,&quot;&lt;&lt;b&lt;&lt;endl; Swap(c,d); cout&lt;&lt;c&lt;&lt;&quot; ,&quot;&lt;&lt;d&lt;&lt;endl; return 0;&#125; 普通函数与模板函数的区别 普通函数可以自动类型转换 函数模板如果使用自动类型，不会发生自动类型转换 函数模板如果使用指定类型，会发生自动类型转换 普通函数与模板函数的调用规则 函数模板和普通函数都可以，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以重载 如果函数模板能更好匹配，优先调用函数模板 模板的局限性对于数组和对象来说，可以使用template&lt;&gt;重写一个模板具体实现 类模板123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;template &lt;class NameType,class AgeType&gt;class People &#123; public: People(NameType name,AgeType age) &#123; this-&gt;name=name; this-&gt;age=age; &#125; NameType name; AgeType age;&#125;;int main(int argc, char** argv) &#123; People&lt;string,int&gt; p(&quot;张三&quot;,18); cout&lt;&lt;p.name&lt;&lt;p.age&lt;&lt;endl; return 0;&#125; 类模板的成员函数的创建时机类模板中成员函数只在调用时才去创建 类模板对象做函数参数传入方式 指定传入方式 参数模板化 整个类模板化 类模板继承 当子类继承父类是一个类模板时，子类在声明时，要指出父类中的数据类型 不指定，编译器无法给子类分配内存 如果要灵活支出父类中的数据类型，子类也要变成类模板 STL 查阅API即可，深入理解阅读《STL源码剖析》 容器String string本质上是一个类，内部封装了char *,是一个char *的容器 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(int argc, char** argv) &#123; string str=&quot;hello&quot;; const char *ch=&quot;china&quot;; string str1(ch); string str2(10,&#x27;a&#x27;); str+=&quot;world&quot;; cout&lt;&lt;str&lt;&lt;&quot; &quot;&lt;&lt;str1&lt;&lt;&quot; &quot;&lt;&lt;str2&lt;&lt;endl; return 0;&#125; Vector 功能：类似数组，又称为单端数组，可以动态扩展（找更大的内存空间，将数据拷贝，释放原空间） vector存放内置数据类型12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void print(int value) &#123; cout&lt;&lt;value&lt;&lt;endl;&#125;int main(int argc, char** argv) &#123;// vector容器，类似于数组 vector&lt;int&gt; v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); vector&lt;int&gt;::iterator itBegin=v.begin();//起始迭代器，指向容器中第一个元素 vector&lt;int&gt;::iterator itEnd=v.end();//结束迭代器，指向容器中最后一个元素的下一个位置 cout&lt;&lt;&quot;while循环遍历&quot;&lt;&lt;endl; while(itBegin!=itEnd) &#123; cout&lt;&lt;*itBegin&lt;&lt;endl; itBegin++; &#125; cout&lt;&lt;&quot;for循环遍历&quot;&lt;&lt;endl; for(vector&lt;int&gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; cout&lt;&lt;&quot;stl遍历算法&quot;&lt;&lt;endl; for_each(v.begin(),v.end(),print); return 0;&#125; vector存放自定义数据类型1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class People &#123; public: People(string name,int age) &#123; this-&gt;age=age; this-&gt;name=name; &#125; string name; int age;&#125;;int main(int argc, char** argv) &#123; People p1(&quot;李白&quot;,2000); People p2(&quot;达摩&quot;,1000); People p3(&quot;王昭君&quot;,900); People p4(&quot;公孙离&quot;,20); People p5(&quot;赵云&quot;,200); vector&lt;People&gt; v; v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); vector&lt;People*&gt; v1; v1.push_back(&amp;p1); v1.push_back(&amp;p2); v1.push_back(&amp;p3); v1.push_back(&amp;p4); v1.push_back(&amp;p5); for(vector&lt;People&gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; cout&lt;&lt;&quot;姓名:&quot;&lt;&lt;it-&gt;name&lt;&lt;&quot; 年龄：&quot;&lt;&lt;it-&gt;age&lt;&lt;endl; &#125; cout&lt;&lt;&quot;遍历自定义数据类型指针&quot;&lt;&lt;endl; for(vector&lt;People*&gt;::iterator it=v1.begin(); it!=v1.end(); it++) &#123; cout&lt;&lt;&quot;姓名:&quot;&lt;&lt;(*it)-&gt;name&lt;&lt;&quot; 年龄：&quot;&lt;&lt;(*it)-&gt;age&lt;&lt;endl; &#125; return 0;&#125; vector容器嵌套123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;//vector容器嵌套int main(int argc, char** argv) &#123; vector&lt;vector&lt;int&gt; &gt; v; vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector&lt;int&gt; v3; vector&lt;int&gt; v4; for(int i=0; i&lt;4; i++) &#123; v1.push_back(i); v2.push_back(i+1); v3.push_back(i+2); v4.push_back(i+3); &#125; v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); for(vector&lt;vector&lt;int&gt; &gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; for(vector&lt;int&gt;::iterator vit=(*it).begin(); vit!=(*it).end(); vit++) &#123; cout&lt;&lt;*vit&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; vector容器插入和删除12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void print(vector&lt;int&gt; &amp;v) &#123; for(vector&lt;int&gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125;&#125;int main(int argc, char** argv) &#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); print(v); v.pop_back(); print(v); v.insert(v.begin(),60); print(v); v.erase(v.begin(),v.end()); print(v); v.clear(); print(v); return 0;&#125; Deque双端数组，可以对头端进行插入和删除 Stack（栈）：没啥可说的Queue（队列）：没啥可说的List注意：list不支持随机存取，所以没有[]和at的访问方式 Set和Multiserset结构会自动排序，底层是二叉树 set中不允许有重复的值 multiset允许有重复的值 Mapmap中所以元素都是pair,底层为二叉树，可以根据key快速找到value map中不允许有重复key值元素 multimap中允许有重复key值元素","categories":[{"name":"C++","slug":"C","permalink":"https://wkcollection.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wkcollection.github.io/tags/C/"},{"name":"编程语言","slug":"编程语言","permalink":"https://wkcollection.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]}],"categories":[{"name":"Git","slug":"Git","permalink":"https://wkcollection.github.io/categories/Git/"},{"name":"C++","slug":"C","permalink":"https://wkcollection.github.io/categories/C/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://wkcollection.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"git","slug":"git","permalink":"https://wkcollection.github.io/tags/git/"},{"name":"C++","slug":"C","permalink":"https://wkcollection.github.io/tags/C/"},{"name":"编程语言","slug":"编程语言","permalink":"https://wkcollection.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]}