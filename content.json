{"meta":{"title":"编程の路","subtitle":"Coding成神之路!","description":"这辈子只管努力,剩下的交给命运!","author":"BlueHole","url":"https://WkCollection.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-06-19T07:55:46.000Z","updated":"2022-06-19T09:37:35.268Z","comments":true,"path":"categories/index.html","permalink":"https://wkcollection.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-06-19T06:17:26.000Z","updated":"2022-07-10T13:37:30.821Z","comments":true,"path":"about/index.html","permalink":"https://wkcollection.github.io/about/index.html","excerpt":"","text":"我如果爱你绝不像攀援的凌霄花借你的高枝炫耀自己我如果爱你绝不学痴情的鸟儿为绿荫重复单调的歌曲也不止像泉源常年送来清凉的慰藉也不止像险峰增加你的高度，衬托你的威仪甚至日光甚至春雨不，这些都还不够我必须是你近旁的一株木棉作为树的形象和你站在一起根，紧握在地下叶，相触在云里每一阵风过我们都互相致意但没有人听懂我们的言语你有你的铜枝铁干像刀，像剑，也像戟我有我红硕的花朵像沉重的叹息又像英勇的火炬我们分担寒潮、风雷、霹雳我们共享雾霭、流岚、虹霓仿佛永远分离却又终身相依这才是伟大的爱情坚贞就在这里爱不仅爱你伟岸的身躯也爱你坚持的位置足下的土地"},{"title":"标签","date":"2022-06-19T09:09:48.000Z","updated":"2022-06-19T09:37:45.387Z","comments":true,"path":"tags/index.html","permalink":"https://wkcollection.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C语言突破","slug":"C","date":"2022-07-11T13:49:56.000Z","updated":"2022-08-10T06:12:21.459Z","comments":true,"path":"2022/07/11/C/","link":"","permalink":"https://wkcollection.github.io/2022/07/11/C/","excerpt":"C语言突破 C和C++语言相关知识点深入理解 C和Cpp C语言相关知识点深入理解 第一关：C和指针宽字符常量如果一个多字节字符常量前面带有一个L，那么他就是宽字符常量。例如：L‘X’ 枚举类型枚举类型的实质是以整型形式进行存储的，符号名其实都是整型值。如果某个符号未显式复制那个他的值就比前面的一个符号名的值大1。第一个未命名的初始化为0。 浮点类型浮点数在缺省情况下都是double类型的，加L或l表示为long double类型的，或者加F或f表示是float类型的值。 字符串常量字符串常量在程序中使用会生成一个”指向字符的常量指针”。 12345char *message = &quot;Hello&quot;;/*等价于char *message;message = “Hello”;*/ 指针与常量123int const *p;//可以修改指针的值，无法修改指针指向的值int * const p1;//指针为常量无法修改，指针指向的值可以修改int const * const p2;//指针的指向和指针指向的值都不可以改变 作用域代码块作用域位于一对花括号之间的所有语句都称为一个代码块，任何在代码块的开始位置声明的标识符都具有代码块作用域。 文件作用域任何在所有代码块之外声明的标识符都具有文件作用域。 原型作用域原型作用域只适用于在函数原型中声明的参数名。 函数作用域函数作用域只适用于语句标签，指在函数内声明的所有变量在函数体内始终是可见的,可以在整个函数的范围内使用及复用。","text":"C语言突破 C和C++语言相关知识点深入理解 C和Cpp C语言相关知识点深入理解 第一关：C和指针宽字符常量如果一个多字节字符常量前面带有一个L，那么他就是宽字符常量。例如：L‘X’ 枚举类型枚举类型的实质是以整型形式进行存储的，符号名其实都是整型值。如果某个符号未显式复制那个他的值就比前面的一个符号名的值大1。第一个未命名的初始化为0。 浮点类型浮点数在缺省情况下都是double类型的，加L或l表示为long double类型的，或者加F或f表示是float类型的值。 字符串常量字符串常量在程序中使用会生成一个”指向字符的常量指针”。 12345char *message = &quot;Hello&quot;;/*等价于char *message;message = “Hello”;*/ 指针与常量123int const *p;//可以修改指针的值，无法修改指针指向的值int * const p1;//指针为常量无法修改，指针指向的值可以修改int const * const p2;//指针的指向和指针指向的值都不可以改变 作用域代码块作用域位于一对花括号之间的所有语句都称为一个代码块，任何在代码块的开始位置声明的标识符都具有代码块作用域。 文件作用域任何在所有代码块之外声明的标识符都具有文件作用域。 原型作用域原型作用域只适用于在函数原型中声明的参数名。 函数作用域函数作用域只适用于语句标签，指在函数内声明的所有变量在函数体内始终是可见的,可以在整个函数的范围内使用及复用。 链接属性 external：无论被声明多少次，位于不同源文件的都表示同一个实体 internal：在同一个源文件内的所有声明中都指向同一个实体，不同源文件属于不同实体 none：总是被当做单独的个体 关键字extern和static可用来修改链接属性，使用static可以使得链接属性变为internal,但是只对缺省的external有效 当extern关键字用于标识符第一次声明，指定有external属性，用于变量第二次或以后的声明则不会更改第一次声明的链接属性 编译和链接 编译一个源文件main.c 1gcc main.c 会产生一个a.exe的可执行程序 编译并链接几个C源文件 1gcc main.c hello.c 编译一个源文件并把其和现存文件链接在一起 1gcc main.o hello.c 编译单个C源文件，并产生目标文件 1gcc -c main.c 编译几个C源文件，并为每个文件产生一个目标文件 1gcc -c main.c hello.c 存储类型凡是存在于任何代码块之外声明的变量总是存储于静态内存中，即存储在全局区中，存在于全局区的变量于程序运行前创建，在程序执行的整个期间始终存在，始终保持原来的值，除非赋新的值。 在代码块内部声明的变量的缺省类型是自动的，存储于堆栈中，在程序执行到声明的变量时，该变量才被创建，当程序的执行离开代码块时，该变量被销毁。在代码块内部给声明的变量加上static可以让变量放到全局区内去，但是该变量的作用域依旧不变。 register关键字可以用于自动变量的声明，表示这个变量应该存储于寄存器中而不是内存中，也被称为寄存器变量。通常寄存器变量比内存的变量访问效率更高，但是寄存器不一定会理睬寄存器变量，只会选取前几个实际存储于寄存器中。 字符串常用函数字符串长度123char *msg = &quot;Hello World!&quot;;size_t len = strlen(msg);printf(&quot;msg的长度是:%d\\n&quot;, len); 复制字符串strcpy返回目标函数的一个拷贝 1234char *msg = &quot;Hello World!&quot;;char copy[20];strcpy(copy, msg);printf(&quot;copy数组内为:%s\\n&quot;, copy); 连接字符串1234char str3[] = &quot;I Love &quot;;char str4[] = &quot;China&quot;;strcat(str3, str4);printf(&quot;str3为:%s\\n&quot;, str3); 字符串比较12345678910char str[] = &quot;bceg&quot;;char str1[] = &quot;abceg&quot;;int result = strcmp(str, str1);if(result &gt; 0) &#123; printf(&quot;str大于str1\\n&quot;);&#125; else if(result &lt; 0) &#123; printf(&quot;str小于str1\\n&quot;);&#125; else &#123; printf(&quot;str等于str1\\n&quot;);&#125; 内存操作memcpy：void* memcpy( void *dest, const void *src, size_t count );从 src 所指向的对象复制 count 个字节到 dest 所指向的对象。 1234char msg[13] = &quot;Hello World~&quot;;char msgDst[13];memcpy(msgDst, msg, 13);printf(&quot;msgDst is %s\\n&quot;, msgDst); memmove：void* memmove( void* dest, const void* src, size_t count ); 从 src 所指向的对象复制 count 个字节到 dest 所指向的对象。与memcpy不同的是，memmove的源和目标数可以重叠。也就是说src和dest可以相同。 1234char msgSrc[5] = &quot;Hello&quot;;char msgDstTwo[6];memmove(msgDstTwo, msgSrc, 5);printf(&quot;msgDstTwo is %s\\n&quot;, msgDstTwo); memcmp：int memcmp( const void* lhs, const void* rhs, size_t count );比较 lhs 和 rhs 所指向对象的首 count 个字节。如果lhs小于rhs则小于0；如果lhs大于rhs则大于0;如果lhs等于rhs则等于0。 12345678910char info[] = &quot;Hi,I am Tom&quot;;char infoTwo[] = &quot;hi,I am Tom&quot;;int result = memcmp(info, infoTwo, 12);if(result &gt; 0) &#123; printf(&quot;info大于infoTwo\\n&quot;);&#125; else if(result &lt; 0) &#123; printf(&quot;info小于infoTwo\\n&quot;);&#125; else &#123; printf(&quot;info等于infoTwo\\n&quot;);&#125; memchr：void* memchr( const void* ptr, int ch, size_t count );从ptr的起始位置开始查找ch的首次出现的位置，返回一个指向该位置的指针。 123char info[] = &quot;Hi,I am Tom&quot;;char *p = memchr(info, 97, 12);printf(&quot;*p is %s\\n&quot;, p); memset：void *memset( void *dest, int ch, size_t count );从 dest开始的count个字节都设置为ch 。 12345int zero[20];memset(zero, 0, sizeof(zero));for(int i = 0; i &lt; sizeof(zero) / sizeof(zero[0]); i++) &#123; printf(&quot;zero[%d] = %d\\n&quot;, i, zero[i]);&#125; 动态内存分配动态内存分配两个主要的函数malloc和free。 malloc和calloc都用于分配内存，区别在于后者在返回指向内存的指针前会将其初始化为0。 第二关：C陷阱与缺陷第三关：C专家编程第四关：Linux C编程第五关：数据结构与算法分析第六关：Makefile第一章 什么是makefile？makefile关系到整个工程的编译规则，makefile定义了一些规则来指定哪些文件需要先进行编译，哪些文件需要后进行编译，哪些文件需要重新进行编译，甚至于进行更加复杂的操作。值得一提的是makefile也可以执行操作系统的命令。makefile带来的好处就是——自动化编译，一旦makefile文件写好，只需要一个make命令就可以完成整个工程的完全自动化编译，可以极大的提高软件开发的效率。make是一个解释makefile文件中指令的命令工具。 第二章 程序的编译和链接一般来说对于编译型语言，首先要做的就是将源文件编译成中间代码文件，对于C，C++,在Windwos下来说也就是.obj文件，这个过程就是编译。然后再把大量编译好的目标文件链接在一起合成一个可执行文件，这个过程就是链接。编译时，编译器只检查程序的语法，变量和函数是否被声明，如果未被声明那么编译器会给出警告，此时可以成功生成目标文件，但是在链接过程中，链接器会在所有的目标文件中查找函数的定义，找不到则会报链接错误。 第三章 Makefile简介makefile规则12target : prerequisites command target：可以是一个目标文件，也可以是一个可执行程序，还可以是一个标签。 prerequisites：指要生成那个target所需要的文件或是目标。 command：是指make需要执行的命令，可以是任意是shell命令。 总结：如果prerequisites中有一个以上的文件比target的文件要新的话，command所定义的命令就会被执行。 makefile例子1234567891011121314151617181920edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o gcc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.omain.o : main.c defs.h gcc -c main.ckbd.o : kbd.c defs.h command.h gcc -c kbd.ccommand.o : command.c defs.h command.h gcc -c command.cdisplay.o : display.c defs.h buffer.h gcc -c display.cinsert.o : insert.c defs.h buffer.h gcc -c insert.csearch.o : search.c defs.h buffer.h gcc -c search.cfiles.o : files.c defs.h buffer.h command.h gcc -c files.cutils.o : utils.c defs.h gcc -c utils.cclean : rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o 这里要说明一点的是，clean 不是一个文件，它只不过是一个动作名字，有点像 C 语言中的 lable 一样，其冒号后什么也没有，那么，make 就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在 make 命令后明显得指出这个lable 的名字。 make的工作方式在默认的方式下，也就是我们只输入 make 命令。那么 make 会在当前目录下找名字叫“Makefile”或“makefile”的文件。 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。 如果 edit 文件不存在， 或是 edit 所依赖的后面的 .o 文件的文件修改时间要比 edit这个文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。 如果 edit 所依赖的.o 文件也存在，那么 make 会在当前文件中找目标为.o 文件的依赖性，如果找到则再根据那一个规则生成.o 文件。 当然，你的 C 文件和 H 文件是存在的啦， 于是 make 会生成 .o 文件， 然后再用 .o 文件生命 make 的终极任务，也就是执行文件 edit 了。 makefile中使用变量从上面的例子中可以看到main.o kbd.o command.o display.o insert.o search.o files.o utils.o被使用了3次。如果工程很大的话，需要依赖的目标文件很多的话，那么就很容易忘掉需要添加的目标文件，为了makefile便于维护，我们可以使用变量，makefile的变量就类似于C语言中的宏。 所以对于需要使用多次的目标文件，可以对其定义一个变量来表示。即obj = main.o kbd.o command.o display.o insert.o search.o files.o utils.o。然后通过$(obj)来进行使用。经过修改后那么makefile文件如下： 12345678910111213141516171819202122obj = main.o kbd.o command.o display.o insert.o search.o files.o utils.oedit : $(obj) gcc -o edit $(obj)main.o : main.c defs.h gcc -c main.ckbd.o : kbd.c defs.h command.h gcc -c kbd.ccommand.o : command.c defs.h command.h gcc -c command.cdisplay.o : display.c defs.h buffer.h gcc -c display.cinsert.o : insert.c defs.h buffer.h gcc -c insert.csearch.o : search.c defs.h buffer.h gcc -c search.cfiles.o : files.c defs.h buffer.h command.h gcc -c files.cutils.o : utils.c defs.h gcc -c utils.cclean : rm edit $(obj) make的自动推导功能GNU的make很强大，可以自动推导文件及其文件依赖后面的命令。只要make看到一个.o文件，他就会自动的将.c文件加在依赖关系中，并且gcc -c也会被自动推导出来。于是改良版plus的makefile如下： 1234567891011121314151617obj = main.o kbd.o command.o display.o insert.o search.o files.o utils.oedit : $(obj) gcc -o edit $(obj)main.o : defs.hkbd.o : defs.h command.hcommand.o : defs.h command.hdisplay.o : defs.h buffer.hinsert.o : defs.h buffer.hsearch.o : defs.h buffer.hfiles.o : defs.h buffer.h command.hutils.o : defs.h.PHONY : cleanclean : rm edit $(obj) .PHONY 表示clean是一个伪目标文件。 makefile的另一种风格这种风格就是将相同的.h和.o文件进行收拢。没有上一种情况可以那么清楚的显示依赖关系。 123456789101112obj = main.o kbd.o command.o display.o insert.o search.o files.o utils.oedit : $(obj) gcc -o edit $(obj)$(obj) : defs.hkbd.o command.o files.o : command.hdisplay.o insert.o search.o files.o : buffer.h.PHONY : cleanclean : rm edit $(obj) 清空目标文件的makefile最佳规则一般的风格都是： 12clean: rm edit $(objects) 更为稳健的做法是： 123.PHONY : cleanclean : -rm edit $(objects) 在 rm 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean 的规则不要放在文件的开头，不然，这就会变成 make 的默认目标。 第四章 Makefile全貌makefile的内容 显式规则 显式规则说明了，如何生成一个或多的的目标文件。这是由 Makefile 的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。 隐式规则 由于我们的 make 有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写 Makefile，这是由 make 所支持的。 变量 在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点类似C 语言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。 文件引用 一个是在一个makefile文件中包含另一个makefile,类似C的include一样，另一种情况则是根据某些情况指定makefile的有效部分，类似于C语言的#if一样，还有就是定义一个多行的命令。 注释 makefile中只有行注释，注释是使用#号，需要使用到#号的地方可以进行转义。 makefile中的命令必须以Tab键开头进行缩进。 makefile的文件名默认情况下，make会寻找文件名为”GNUmakefile”,”makefile”,”Makefile”这三个文件。GNUmakefile只支持GNU，大多数都支持：”makefile”,”Makefile”。 如果想要使用别的文件名来书写makefile,可以使用make -f 文件名或者make --file 文件名来指定特定的文件。 引用其他的makefile文件在 Makefile 使用 include 关键字可以把别的 Makefile 包含进来，这很像 C 语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include 的语法是： 1include &lt;filename&gt; filename 可以是当前操作系统 Shell 的文件模式（可以保含路径和通配符） 在 include前面可以有一些空字符，但是绝不能是[Tab]键开始。include 和可以用一个或多个空格隔开。 如果文件都没有指定绝对路径或是相对路径的话，make 会在当前目录下首先寻找，如果当前目录下没有找到，那么，make 还会在下面的几个目录下找： 如果 make 执行时，有-I或--include-dir参数，那么 make 就会在这个参数所指定的目录下去寻找 。 如果目录&#x2F;include（一般是：&#x2F;usr&#x2F;local&#x2F;bin 或&#x2F;usr&#x2F;include）存在的话，make 也会去找。如果有文件没有找到的话，make 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找到，或是不能读取的文件，如果还是不行，make 才会出现一条致命信息。如果你想让 make不理那些无法读取的文件，而继续执行，你可以在 include 前加一个减号“-”。 环境变量 MAKEFILES如果你的当前环境中定义了环境变量 MAKEFILES，那么，make 会把这个变量中的值做一个类似include 的动作。这个变量中的值是其它的 Makefile，用空格分隔。只是， 它和 include不同的是，从这个环境变中引入的 Makefile 的“目标”不会起作用，如果环境变量中定义的文件发现错误，make 也会不理。 make 的工作方式GNU 的 make 工作时的执行步骤入下： 读入所有的 Makefile。 读入被 include 的其它 Makefile。 初始化文件中的变量。 推导隐晦规则，并分析所有规则。 为所有的目标文件创建依赖关系链。 根据依赖关系，决定哪些目标要重新生成。 执行生成命令。 第五章 书写规则在 Makefile 中，规则的顺序是很重要的，因为，Makefile 中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让 make 知道你的最终目标是什么。一般来说，定义在 Makefile 中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。 规则语法第一种写法： 12targets : prerequisites command 第二种写法： 1targets : prerequisites ; command 如果命令太长，你可以使用反斜框（‘\\’）作为换行符。 在规则中使用通配符make 支持三种通配符： *，?和[]。 波浪号（“”）字符在文件名中也有比较特殊的用途。如果是“&#x2F;test”，这就表示当前用户的$HOME 目录下的 test 目录。而“~hchen&#x2F;test”则表示用户 hchen 的宿主目录下的 test 目录。 在 Windows 下则指的是环境变量“HOME” 。 1objects = *.o 此时objects的值就是*.o，如果需要objects的值是所有.o文件的集合，那么需要用到wildcard关键字，即 objects := $(wildcard *.o)。 文件搜寻在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当 make 需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉 make，让 make 在自动去找。 Makefile 文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make 只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。 1VPATH = src:../headers 另一个设置文件搜索路径的方法是使用 make 的“vpath”关键字 ，它的用法有三种： vpath &lt;pattern&gt; &lt;directories&gt; 为符合模式的文件指定搜索目录。 vpath &lt;pattern&gt; 清除符合模式的文件的搜索目录。 vpath 清除所有已被设置好了的文件搜索目录。 vapth 使用方法中的需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。指定了要搜索的文件集，而则指定了的文件集的搜索的目录。 1vpath %.h ../headers 该语句表示，要求 make 在“..&#x2F;headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话） 伪目标伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的 Makefile 需要一口气生成若干个可执行文件，但你只想简单地敲一个 make 完事，并且，所有的目标文件都写在一个 Makefile 中，那么你可以使用“伪目标”这个特性： 12345678all : prog1 prog2 prog3.PHONY : allprog1 : prog1.o utils.o cc -o prog1 prog1.o utils.oprog2 : prog2.o cc -o prog2 prog2.oprog3 : prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o 伪目标同样也可成为依赖。看下面的例子： 1234567.PHONY: cleanall cleanobj cleandiffcleanall : cleanobj cleandiff rm programcleanobj : rm *.ocleandiff : rm *.diff 我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。 多目标Makefile 的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@” ，这个变量表示着目前规则中所有的目标的集合。 12bigoutput littleoutput : text.ggenerate text.g -$(subst output,$@) &gt; $@ 等价于： 1234bigoutput : text.ggenerate text.g -big &gt; bigoutputlittleoutput : text.ggenerate text.g -little &gt; littleoutput 其中，-$(subst output,$@)中的“$”表示执行一个 Makefile 的函数，函数名为 subst，后面的为参数。 这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。 静态模式静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活 。 语法： 12&lt;targets ...&gt; : &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt; &lt;commands&gt; targets 定义了一系列的目标文件，可以有通配符。是目标的一个集合。 target-parrtern 是指明了 targets 的模式，也就是的目标集模式。 prereq-parrterns 是目标的依赖模式，它对 target-parrtern 形成的模式再进行一次依赖目标的定义。 看一个例子： 1234objects = foo.o bar.oall: $(objects)$(objects): %.o: %.c$(CC) -c $(CFLAGS) $&lt; -o $@ 上面的例子中，指明了我们的目标从$object 中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object 集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，$&lt;表示所有的依赖目标集（也就是“foo.c bar.c”）， $@表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则： 1234foo.o : foo.c$(CC) -c $(CFLAGS) foo.c -o foo.obar.o : bar.c$(CC) -c $(CFLAGS) bar.c -o bar.o 如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子： 12345files = foo.elc bar.o lose.o$(filter %.o,$(files)): %.o: %.c$(CC) -c $(CFLAGS) $&lt; -o $@$(filter %.elc,$(files)): %.elc: %.elemacs -f batch-byte-compile $&lt; 自动生成依赖如果是一个比较大型的工程，你必需清楚哪些 C 文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改 Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用 C&#x2F;C++编译的一个功能。大多数的C&#x2F;C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。 如果你使用 GNU 的 C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。 GNU 组织建议把编译器为每一个源 文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的 Makefile 文件，[.d]文件中就存放对应[.c]文件的依赖关系。于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让 make 自动更新或自成[.d]文件，并把其包含在我们的Makefile 中，这样，我们就可以自动化地生成每个文件的依赖关系了。这里，我们给出了一个模式规则来产生[.d]文件： 12345%.d: %.c@set -e; rm -f $@; \\$(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \\sed &#x27;s,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g&#x27; &lt; $@.$$$$ &gt; $@; \\rm -f $@.$$$$ 这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm -f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$&lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式“ %.d” 文件，如果有一个 C 文件是 name.c，那么“%”就是“name”，“$$$$”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用 sed 命令做了一个替换。第四行就是删除临时文件。 总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系： main.o : main.c defs.h转成：main.o main.d : main.c defs.h 。 于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主 Makefile 中。 我们可以使用Makefile 的“include”命令，来引入别的 Makefile 文件，例如： 12sources = foo.c bar.cinclude $(sources:.c=.d) 上述语句中的“$(sources:.c&#x3D;.d)”中的“.c&#x3D;.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]。当然，你得注意次序，因为 include 是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。 第六章 常用命令显示提示的命令通常，make 会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被 make 显示出来，最具代表性的例子是，我们用这个功能来向屏幕显示一些信息。如： 1@echo 正在编译 XXX 模块...... 当 make 执行时，会输出“正在编译 XXX 模块……”字串，但不会输出命令，如果没有“@”，那么，make 将输出： 123echo 正在编译 XXX 模块......正在编译 XXX 模块...... 如果 make 执行时，带入 make 参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的 Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。 而 make 参数“-s”或“–slient”则是全面禁止命令的显示。 执行命令当依赖目标新于目标时，也就是当规则的目标需要被更新时，make 会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是 cd 命令，你希望第二条命令得在 cd 之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。 如： 1234567# 示例一：exec:cd /home/hchenpwd# 示例二：exec:cd /home/hchen; pwd 当我们执行“make exec”时，第一个例子中的 cd 没有作用，pwd 会打印出当前的Makefile 目录，而第二个例子中，cd 就起作用了，pwd 会打印出“&#x2F;home&#x2F;hchen”。 命令出错每当命令运行完后，make 会检测每个命令的返回码，如果命令返回成功，那么 make 会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么 make 就会终止执行当前规则，这将有可能终止所有规则的执行。 有些时候，命令的出错并不表示就是错误的。 为了忽略命令的出错，我们可以在 Makefile 的命令行前加一个减号“-”（在 Tab 键之后），标记为不管命令出不出错都认为是成功的。还有一个全局的办是，给 make 加上“-i”或是“ –ignore-errors”参数，那么，Makefile 中所有命令都会忽略错误。 而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。还有一个要提一下的 make 的参数的是“-k”或是“–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。 嵌套执行make在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的 Makefile，这有利于让我们的 Makefile 变得更加地简洁，而不至于把所有的东西全部写在一个 Makefile 中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。 例如，我们有一个子目录叫 subdir，这个目录下有个 Makefile 文件，来指明了这个目录下文件的编译规则。那么我们总控的 Makefile 可以这样书写： 12subsystem: cd subdir &amp;&amp; $(MAKE) 等价于： 12subsystem: $(MAKE) -C subdir 如果你要传递变量到下级 Makefile 中，那么你可以使用这样的声明：export &lt;variable ...&gt; 如果你不想让某些变量传递到下级 Makefile 中，那么可以这样声明：unexport &lt;variable ...&gt; 需要注意的是，有两个变量，一个是 SHELL，一个是 MAKEFLAGS，这两个变量不管你是否 export，其总是要传递到下层 Makefile 中，特别是 MAKEFILES 变量，其中包含了 make的参数信息，如果我们执行“总控 Makefile”时有 make 参数或是在上层 Makefile 中定义了这个变量，那么 MAKEFILES 变量将会是这些参数，并会传递到下层 Makefile 中，这是一个系统级的环境变量 。但是 make 命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W” ,如果你不想往下层传递参数，那么，你可以这样来： 12subsystem: cd subdir &amp;&amp; $(MAKE) MAKEFLAGS= 命令包如果 Makefile 中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如： 1234define run-yaccyacc $(firstword $^)mv y.tab.c $@endef 这里，“ run-yacc”是这个命令包的名字，其不要和 Makefile 中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行 Yacc程序，因为 Yacc 程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。 第七章 变量 变量是大小写敏感的 变量的嵌套使用第一种方式，也就是简单的使用“&#x3D;”号，在“&#x3D;”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。 12345foo = $(bar)bar = $(ugh)ugh = Huh?all: echo $(foo) 第二种方式，使用:&#x3D;操作符，如： 123456x := fooy := $(x) barx := later其等价于：y := foo barx := later 还有一个比较有用的操作符是“?&#x3D;” ,如： 1FOO ?= bar 其含义是，如果 FOO 没有被定义过，那么变量 FOO 的值就是“bar”，如果 FOO 先前被定义过，那么这条语将什么也不做。 变量的高级用法第一种是变量值的替换。 如： 12foo := a.o b.o c.obar := $(foo:.o=.c) 这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。 另外一种变量替换的技术是以“静态模式” ，如： 12foo := a.o b.o c.obar := $(foo:%.o=%.c) 第二种高级用法是——“把变量的值再当成变量”。 如： 123x = yy = za := $($(x)) 追加变量值我们可以使用“+&#x3D;”操作符给变量追加值， 如： 12objects = main.o foo.o bar.o utils.oobjects += another.o override 指示符如果有变量是通常 make 的命令行参数设置的，那么 Makefile 中对这个变量的赋值会被忽略。如果你想在 Makefile 中设置这类参数的值，那么，你可以使用“override”指示符。其语法是： 12override &lt;variable&gt; = &lt;value&gt;override &lt;variable&gt; := &lt;value&gt; 多行变量还有一种设置变量值的方法是使用 define 关键字。 使用 define 关键字设置变量的值可以有换行，这有利于定义一系列的命令 。 define 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以 endef 关键字结束。其工作方式和“&#x3D;”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。 因为命令需要以[Tab]键开头， 所以如果你用 define 定义的命令变量中没有以[Tab]键开头，那么 make 就不会把其认为是命令。 目标变量目标变量的作用范围只在这条规则以及连带规则中。语法是：&lt;target ...&gt; : &lt;variable-assignment&gt; &lt;target ...&gt; : overide &lt;variable-assignment&gt; 如： 123456789prog : CFLAGS = -gprog : prog.o foo.o bar.o $(CC) $(CFLAGS) prog.o foo.o bar.oprog.o : prog.c $(CC) $(CFLAGS) prog.cfoo.o : foo.c $(CC) $(CFLAGS) foo.cbar.o : bar.c $(CC) $(CFLAGS) bar.c 模式变量通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。 如：给所有以[.o]结尾的目标定义目标变量 。 1%.o : CFLAGS = -O 第八章 条件判断12345678libs_for_gcc = -lgnunormal_libs =foo: $(objects)ifeq ($(CC),gcc) $(CC) -o foo $(objects) $(libs_for_gcc)else $(CC) -o foo $(objects) $(normal_libs)endif 特别注意的是，make 是在读取 Makefile 时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。 第九章 函数语法：$(&lt;function&gt; &lt;arguments&gt;) 或者是$&#123;&lt;function&gt; &lt;arguments&gt;&#125; 。 foreach函数语法：$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;) 。如： 12names := a b c dfiles := $(foreach n,$(names),$(n).o) 第七关：CMake","categories":[{"name":"C","slug":"C","permalink":"https://wkcollection.github.io/categories/C/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://wkcollection.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C","slug":"C","permalink":"https://wkcollection.github.io/tags/C/"}]},{"title":"深度学习之路：Python配置Pytorch","slug":"Python","date":"2022-07-08T07:32:02.000Z","updated":"2022-07-09T06:36:39.888Z","comments":true,"path":"2022/07/08/Python/","link":"","permalink":"https://wkcollection.github.io/2022/07/08/Python/","excerpt":"深度学习之路：Python配置Pytorch 本文为Python配置Pytorch库，利用Anaconda包管理工具 查看电脑显卡配置打开电脑的设备管理器查看显示适配器配置，如果有NVIDIA则可以采用GPU方式，我的电脑没有NVIDIA所以不支持GPU，所以后面只能采用CPU方式（采用CPU方式进行训练会很慢）：","text":"深度学习之路：Python配置Pytorch 本文为Python配置Pytorch库，利用Anaconda包管理工具 查看电脑显卡配置打开电脑的设备管理器查看显示适配器配置，如果有NVIDIA则可以采用GPU方式，我的电脑没有NVIDIA所以不支持GPU，所以后面只能采用CPU方式（采用CPU方式进行训练会很慢）： 下载Anaconda由于使用Pip进行Pytorch库的安装，过程中坑实在太多，根据网上的建议选用Anaconda这个也很优秀的Python第三库的包管理工具。为节省时间可以采用清华源镜像进行下载Anaconda选择Anaconda3-5.3.1-Windows-x86_64.exe进行下载： 下载完成后进行安装 安装Anaconda Anaconda配置环境变量将D:\\Anaconda;D:\\Anaconda\\Scripts;D:\\Anaconda\\Library\\bin;加入到环境变量Path中 打开命令行CMD输入conda --version 1conda --version Conda虚拟环境配置在后面的项目我们可能遇见不同的项目需要用到不同环境，此时可以使用虚拟环境： 使用conda创建一个pytorch的环境，指定Python版本为3.7 1conda create -n pytorch python=3.7 使用下面的命令查看当前环境，带*的为当前所处环境 1conda info --envs 先使用activate激活base环境 1activate 再使用conda activate pytorch激活pytorch这个环境 1conda activate pytorch 安装CUDA和CUDNN（如无独显则跳过此步） 查看CUDA的官方文档 查看cuDNN的官方文档 第一步：首先根据显卡的驱动程序版本找到对应的Cuda Toolkit 第二步：找到对应的CUDA，在此处下载 第三步：找到对应的cuDNN,在此处下载 第四步：解压cuDNN文件，将bin,include,lib复制到CUDA目录下 第五步：配置CUDA的环境变量，将CUDA下的include,lib,libnvvp配置到Path路径下 第六步：验证是否安装成功，打开CMD，输入nvcc -V查看CUDA版本 安装Pytorch第一步：进入Pytorch官网，点击首页Install 第二步：找到自己所需配置 即打开CMD运行下面的命令进行Pytorch(使用CUDA-10.2)的安装： 1CUDA-10.2 PyTorch builds are no longer available for Windows, please use CUDA-11.6 由于我电脑无独立显卡只有核显所以我只能选择CPU方式进行安装： 即打开CMD运行下面的命令进行Pytorch的安装： 1conda install pytorch torchvision torchaudio cpuonly -c pytorch 至此Pytorch配置完毕！！！","categories":[{"name":"Python","slug":"Python","permalink":"https://wkcollection.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wkcollection.github.io/tags/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"https://wkcollection.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"FLTK踩坑之路","slug":"CodeBlocks","date":"2022-07-04T05:32:03.000Z","updated":"2022-07-11T13:22:32.783Z","comments":true,"path":"2022/07/04/CodeBlocks/","link":"","permalink":"https://wkcollection.github.io/2022/07/04/CodeBlocks/","excerpt":"FLTK踩坑之路：CodeBlocks配置FLTK库FLTK库 系统环境：Win7旗舰版 CodeBlocks版本：20.3 FLTK版本：1.3.8 Mingw版本：4.2.1（CodeBlocks自带的编译器，无需额外配置编译器）","text":"FLTK踩坑之路：CodeBlocks配置FLTK库FLTK库 系统环境：Win7旗舰版 CodeBlocks版本：20.3 FLTK版本：1.3.8 Mingw版本：4.2.1（CodeBlocks自带的编译器，无需额外配置编译器） 本来想使用wxWidgets的，奈何wxWidgets的编译过于复杂且麻烦而且会出很多问题，于是改用FLTK FLTK历史FLTK正如他的名字Fast Light Tool Kit，是一个跨平台C++的GUI工具包，适用于 UNIX&#x2F;Linux、Windows和Mac OS；FLTK 提供了很多GUI 功能，并通过 OpenGL及其内置的 GLUT 仿真支持 3D 图形。 FLTK特点 兼容GLUT库 兼容XForms库 支持 X11 和 WIN32 上的 OpenGL 非常小且快速的便携式二维绘图库 交互式用户界面构建器程序 sizeof(Fl_Widget) &#x3D;&#x3D;64 直接在核心库上编写以实现最高速度，并针对代码大小和性能进行了优化 FLTK缺点 不支持GB2312&#x2F;GBK中文字符编码 对于大型复杂的GUI比较吃力，推荐使用QT CodeBlocks集成FLTK在官网FLTK 下载FLTK的源码，我下载的是fltk-1.3.8-source.tar.gz，下载完后进行解压，使用CMake进行编译，然后使用codeblocks打开，FLTK.cbp文件进行编译，得到编译后的文件如下： 在编译的build文件夹下新建一个文件夹include，将FLTK的源文件的头文件FLTK复制到新建的文件夹include下面。打开CodeBlocks进行库的配置，添加头文件到搜索目录，添加库文件到搜索目录，链接库文件。 第一个FLTK程序12345678910111213141516171819202122#include &lt;FL/Fl.H&gt;#include &lt;FL/Fl_Window.H&gt;#include &lt;FL/Fl_Box.H&gt;int main (int argc, char ** argv) &#123; //创建窗体:宽340,高180，窗体名为“Hello” Fl_Window *window = new Fl_Window(340, 180, &quot;Hello&quot;); //创建弹性盒子，内容为“Hello World” Fl_Box *box = new Fl_Box(20, 40, 300, 100, &quot;Hello, World!&quot;); //设置盒子的类型 box-&gt;box(FL_UP_BOX); //设置盒子的字体样式 box-&gt;labelfont(FL_BOLD + FL_ITALIC); //设置盒子字体大小 box-&gt;labelsize(36); //设置盒子标签的类型 box-&gt;labeltype(FL_SHADOW_LABEL); //窗体内容结束 window-&gt;end(); //显示窗口并进行事件循环 window-&gt;show(argc, argv); return Fl::run();&#125; FLTK按钮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;FL/Fl.H&gt;#include &lt;FL/Fl_Window.H&gt;#include &lt;FL/Fl_Button.H&gt;#include &lt;FL/Fl_Return_Button.H&gt;#include &lt;FL/Fl_Light_Button.H&gt;#include &lt;FL/Fl_Repeat_Button.H&gt;#include &lt;FL/Fl_Round_Button.H&gt;#include &lt;FL/Fl_Check_Button.H&gt;Fl_Box *box = (Fl_Box*)0;int flag = 0;void confirm_cb(Fl_Widget *w, void *data);int main (int argc, char ** argv) &#123; char *data = &quot;I Am Sad!&quot;; //创建窗体:宽340,高180，窗体名为“Demo02” Fl_Window *window = new Fl_Window(340, 250, &quot;Demo02&quot;); //创建弹性盒子 box = new Fl_Box(20, 30, 300, 100, &quot;I Am Happy!&quot;); box-&gt;box(FL_UP_BOX); box-&gt;labelfont(FL_BOLD + FL_ITALIC); box-&gt;labelsize(36); box-&gt;labeltype(_FL_SHADOW_LABEL); box-&gt;labelcolor(FL_BLUE); //创建标准按钮 Fl_Button *btn = new Fl_Button(30, 140, 120, 30, &quot;Change Mood&quot;); btn-&gt;color(FL_WHITE); btn-&gt;labelfont(FL_BOLD); //绑定快捷键 btn-&gt;shortcut(FL_CTRL + &#x27;t&#x27;); btn-&gt;callback((Fl_Callback*)confirm_cb, data); //创建返回按钮 Fl_Return_Button *retBtn = new Fl_Return_Button(160, 140, 120, 30, &quot;Return&quot;); retBtn-&gt;color(FL_WHITE); retBtn-&gt;labelfont(FL_BOLD); //创建重复按钮 Fl_Repeat_Button *repBtn = new Fl_Repeat_Button(30, 180, 120, 30, &quot;Repeat&quot;); repBtn-&gt;color(FL_WHITE); repBtn-&gt;labelfont(FL_BOLD); //创建开关按钮 Fl_Light_Button *lgBtn = new Fl_Light_Button(160, 180, 120, 30, &quot;Light&quot;); lgBtn-&gt;color(FL_WHITE); lgBtn-&gt;labelfont(FL_BOLD); //创建单选按钮(矩形) Fl_Round_Button *rouBtn = new Fl_Round_Button(30, 220, 120, 30, &quot;Round&quot;); rouBtn-&gt;color(FL_WHITE); rouBtn-&gt;labelfont(FL_BOLD); //创建单选按钮(圆形) Fl_Check_Button *checkBtn = new Fl_Check_Button(160, 220, 120, 30, &quot;Check&quot;); checkBtn-&gt;color(FL_WHITE); checkBtn-&gt;labelfont(FL_BOLD); window-&gt;end(); //显示窗口并进行事件循环 window-&gt;show(argc, argv); return Fl::run();&#125;void confirm_cb(Fl_Widget *w, void *data) &#123; if(flag == 0) &#123; box-&gt;label((char *)data); flag = 1; &#125; else &#123; box-&gt;label(&quot;I Am Happy!&quot;); flag = 0; &#125;&#125; FLTK文本框1234567891011121314151617181920212223242526272829303132333435363738#include &lt;FL/Fl.H&gt;#include &lt;FL/Fl_Window.H&gt;#include &lt;FL/Fl_Input.H&gt;#include &lt;FL/Fl_Output.H&gt;#include &lt;FL/Fl_Multiline_Input.H&gt;#include &lt;FL/Fl_Multiline_Output.H&gt;#include &lt;FL/Fl_Text_Editor.H&gt;#include &lt;FL/Fl_Help_View.H&gt;int main (int argc, char ** argv) &#123; //创建窗体:宽340,高180，窗体名为“Demo03” Fl_Window *window = new Fl_Window(340, 540, &quot;Demo03&quot;); //创建普通输入文本框(可以修改文本框的值) Fl_Input *input = new Fl_Input(100, 10, 120, 30, &quot;Enter a Value:&quot;); input-&gt;value(&quot;I am input&quot;); //创建普通输出文本框 Fl_Output *output = new Fl_Output(100, 50, 120, 30, &quot;Print a Value:&quot;); output-&gt;value(&quot;I am output&quot;); //创建多行输入文本框 Fl_Multiline_Input *multiInput = new Fl_Multiline_Input(100, 90, 200, 100, &quot;Enter a Value:&quot;); multiInput-&gt;value(&quot;I am multinput&quot;); //创建多行输出文本框 Fl_Multiline_Output *multioutput = new Fl_Multiline_Output(100, 200, 200, 100, &quot;Print a Value:&quot;); multioutput-&gt;value(&quot;I am multioutput!!&quot;); //创建Text展板 Fl_Text_Buffer *buff = new Fl_Text_Buffer(); Fl_Text_Display *disp = new Fl_Text_Display(0, 320, 340, 100, &quot;Text Display&quot;); disp-&gt;buffer(buff); buff-&gt;text(&quot;line one\\nline two&quot;); disp-&gt;linenumber_width(20); //创建一个带滚动的多行input框 Fl_Help_View *help = new Fl_Help_View(0, 440, 340, 100, &quot;Help View Display&quot;); help-&gt;load(&quot;./main.cpp.save&quot;); //窗体内容结束 window-&gt;end(); //显示窗口并进行事件循环 window-&gt;show(argc, argv); return Fl::run();&#125; FLTK滑块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;FL/Fl.H&gt;#include &lt;FL/Fl_Window.H&gt;#include &lt;FL/Fl_Box.H&gt;#include &lt;FL/Fl_Counter.H&gt;#include &lt;FL/Fl_Dial.H&gt;#include &lt;FL/Fl_Roller.H&gt;#include &lt;FL/Fl_Scrollbar.H&gt;#include &lt;FL/Fl_Slider.H&gt;#include &lt;FL/Fl_Value_Slider.H&gt;int main (int argc, char ** argv) &#123; //创建窗体:宽340,高180，窗体名为“Slider” Fl_Window *window = new Fl_Window(500, 480, &quot;Slider&quot;); Fl_Box *item = new Fl_Box(0, 0, 250, 480, &quot;ItemOne&quot;); item-&gt;color(FL_WHITE); item-&gt;box(FL_UP_BOX); item-&gt;align(FL_ALIGN_BOTTOM); //创建box Fl_Box *box = new Fl_Box(0, 0, 250, 140, &quot;Fl_Slider&quot;); box-&gt;color(FL_WHITE); box-&gt;box(FL_UP_BOX); box-&gt;align(FL_ALIGN_BOTTOM); //Fl_Slider Fl_Slider *slider = new Fl_Slider(20, 10, 20, 100); slider-&gt;type(FL_VERTICAL); slider-&gt;color(FL_RED); Fl_Slider *sliderTwo = new Fl_Slider(50, 10, 20, 100); sliderTwo-&gt;type(FL_VERT_FILL_SLIDER); Fl_Slider *sliderThree = new Fl_Slider(80, 10, 20, 100); sliderThree-&gt;type(FL_VERT_NICE_SLIDER ); Fl_Slider *sliderFour = new Fl_Slider(110, 10, 20, 100); sliderFour-&gt;type(FL_VERT_NICE_SLIDER ); Fl_Slider *sliderFive = new Fl_Slider(140, 10, 100, 20); sliderFive-&gt;type(FL_HORIZONTAL); Fl_Slider *sliderSix = new Fl_Slider(140, 50, 100, 20); sliderSix-&gt;type(FL_HOR_FILL_SLIDER); Fl_Slider *sliderSeven = new Fl_Slider(140, 90, 100, 20); sliderSeven-&gt;type(FL_HOR_NICE_SLIDER); //Fl_Scrollbar Fl_Box *boxScorll = new Fl_Box(0, 160, 250, 140, &quot;Fl_Scrollbar&quot;); boxScorll-&gt;color(FL_WHITE); boxScorll-&gt;box(FL_UP_BOX); boxScorll-&gt;align(FL_ALIGN_BOTTOM); Fl_Scrollbar *sbar = new Fl_Scrollbar(60, 180, 20, 100); Fl_Scrollbar *sbarTwo = new Fl_Scrollbar(80, 220, 100, 20); sbarTwo-&gt;type(FL_HORIZONTAL); //Fl_Counter Fl_Box *boxCot = new Fl_Box(0, 320, 250, 140, &quot;Fl_Counter&quot;); boxCot-&gt;color(FL_WHITE); boxCot-&gt;box(FL_UP_BOX); boxCot-&gt;align(FL_ALIGN_BOTTOM); Fl_Counter *cot = new Fl_Counter(60, 350, 100, 20); Fl_Counter *cotTwo = new Fl_Counter(60, 390, 100, 20); cotTwo-&gt;type(FL_SIMPLE_COUNTER); Fl_Box *itemTwo = new Fl_Box(250, 0, 250, 480, &quot;ItemTwo&quot;); itemTwo-&gt;color(FL_WHITE); itemTwo-&gt;box(FL_UP_BOX); itemTwo-&gt;align(FL_ALIGN_BOTTOM); //Fl_Roller Fl_Box *boxRoller = new Fl_Box(250, 0, 250, 140, &quot;Fl_Roller&quot;); boxRoller-&gt;color(FL_WHITE); boxRoller-&gt;box(FL_UP_BOX); boxRoller-&gt;align(FL_ALIGN_BOTTOM); Fl_Roller *roller = new Fl_Roller(280, 20, 20, 100); Fl_Roller *rollerTwo = new Fl_Roller(320, 60, 100, 20); rollerTwo-&gt;type(FL_HORIZONTAL); //Fl_Dial Fl_Box *boxDial = new Fl_Box(250, 160, 250, 140, &quot;Fl_Dial&quot;); boxDial-&gt;color(FL_WHITE); boxDial-&gt;box(FL_UP_BOX); boxDial-&gt;align(FL_ALIGN_BOTTOM); Fl_Dial *dial = new Fl_Dial(280, 180, 50, 50); Fl_Dial *dialTwo = new Fl_Dial(330, 180, 50, 50); dialTwo-&gt;type(FL_LINE_DIAL); Fl_Dial *dialThree = new Fl_Dial(380, 180, 50, 50); dialThree-&gt;type(FL_FILL_DIAL); //Fl_Value_Slider Fl_Box *boxValue_Slider = new Fl_Box(250, 320, 250, 140, &quot;Fl_Value_Slider&quot;); boxValue_Slider-&gt;color(FL_WHITE); boxValue_Slider-&gt;box(FL_UP_BOX); boxValue_Slider-&gt;align(FL_ALIGN_BOTTOM); Fl_Value_Slider *vSlider = new Fl_Value_Slider(280, 340, 20, 100); Fl_Value_Slider *vSliderTwo = new Fl_Value_Slider(320, 380, 100, 20); vSliderTwo-&gt;type(FL_HORIZONTAL); //窗体内容结束 window-&gt;end(); //显示窗口并进行事件循环 window-&gt;show(argc, argv); return Fl::run();&#125;","categories":[{"name":"IDE","slug":"IDE","permalink":"https://wkcollection.github.io/categories/IDE/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"https://wkcollection.github.io/tags/IDE/"},{"name":"CodeBlocks","slug":"CodeBlocks","permalink":"https://wkcollection.github.io/tags/CodeBlocks/"}]},{"title":"计算机操作系统","slug":"OperateSystem","date":"2022-06-21T05:10:48.000Z","updated":"2022-07-07T05:13:47.534Z","comments":true,"path":"2022/06/21/OperateSystem/","link":"","permalink":"https://wkcollection.github.io/2022/06/21/OperateSystem/","excerpt":"操作系统 本文为学习操作系统的基础 第一章 操作系统概述 操作系统：指控制和管理整个计算机系统的硬件及软件资源，并合理的组织调度计算机的工作和资源的分配，以供给用户和其他软件方便的接口和环境，是计算机中最基本的系统软件。","text":"操作系统 本文为学习操作系统的基础 第一章 操作系统概述 操作系统：指控制和管理整个计算机系统的硬件及软件资源，并合理的组织调度计算机的工作和资源的分配，以供给用户和其他软件方便的接口和环境，是计算机中最基本的系统软件。 操作系统的功能 系统资源的管理者 向上层提供方便易用的服务 最为最接近硬件的层次 操作系统的特征 并发：指两个或多个事件同一时间发生。在宏观上同时发生，微观上交替发生。并发性指计算机&quot;同时运行&quot;着多个程序。单核 CPU 同一时刻只能运行一个程序，各个程序只能并发执行。多核 CPU 同一时刻可以运行多个程序，各个程序可以并行运行。 共享：指系统中的资源可以供多个并发执行的进程共同使用。互斥共享，一个资源只能一个进程访问；同时共享允许一个时间段内有多个进程“同时”对他们进行访问。 虚拟：是指把一个物理上的实体变为若干个逻辑上的对应物。 异步：在多个程序环境下，允许多个程序并发执行，但由于资源有限，进程不是一贯到底的。 操作系统的发展和分类 手工操作阶段：使用纸带输入计算机，计算机输出到纸带上。效率极低。 单道批处理系统：引入脱机输入输出技术，并由监督程序负责控制输入输出。CPU 仍然大量在空闲等待，资源利用率低。 多道批处理系统：操作系统的诞生，每次往系统读入多道程序。 分时操作系统：计算机以时间片为单位轮流为各个用户服务。解决了人机交互的问题。 实时操作系统：计算机系统接收到外部信号后能及时处理，并在严格的时限内处理完事件。 操作系统的运行机制指令就是CPU能识别、执行的最基本的命令。 两种指令 特权指令：操作系统内核作为管理者，会让 CPU 执行一些特权指令。处于内核态的时候，可以执行特权指令。 非特权指令：处于用户态时，只能执行非特权指令。 两种处理器状态 核心态 用户态 两种程序 内核程序：和操作系统相关的程序，内核是操作系统最核心的部分。 应用程序：普通程序员写的程序 中断和异常中断是操作系统内核夺回CPU使用权的唯一途径 中断的类型 内中断：与当前执行的指令有关，中断信号来源于 CPU 内部。 外中断：与当前执行的指令无关，中断信号来源于 CPU 外部。 系统调用系统调用指操作系统提供给应用程序的接口。 系统调用的分类： 设备管理：完成设备的启动、释放等功能 文件管理：完成文件的读写等功能 进程控制：完成进程的创建、销毁等功能 进程管理：完成进程之间的消息传递等功能 内存管理：完成内存的分配、回收等功能 第二章 进程管理程序：是静态的，就是存放在磁盘里的可执行文件，就是一系列指令的集合 进程：是动态的，是程序的一次执行过程。当进程被创建时操作系统会为该进程分配一个唯一的、不重复的“身份证号”-PID 组成：PCB(进程控制块)是进程存在的唯一标志、程序段、数据段 特征：动态性、并发性、独立性、异步性和结构性 进程的状态 进程 PCB 中，会有一个变量 state 记录进程的状态 创建态、就绪态进程在创建时，它的状态是创建态，在这个阶段操作系统会为进程分配资源、初始化 PCB。 当进程创建完成后，就会进入就绪态，处于就绪态的进程已经具备了运行的条件，但是没有空闲的 CPU，暂时不能运行。 运行态如果一个进程此时在 CPU 上运行，那么他就处于运行态，CPU 会执行该进程的指令序列 阻塞态在进程运行期间可能会请求等待某个事件的发生。在这个事件发生前，进程无法向下执行，此时操作系统会让这个进程下 CPU，进入阻塞态。当 CPU 空闲时，又会选择另一个就绪态上 CPU。 终止态一个进程可以执行 exit 系统调用，请求操作系统终止该进程。该进程会进入终止态，操作系统会让该进程下 CPU，并回收内存空间等资源，还要回收 PCB。进程工作结束，彻底消失。 一个进程不可能从就绪态-&gt;阻塞态；也不可能从阻塞态-&gt;运行态 进程控制主要功能：对系统所有的进程实现有效的管理，具有创建新进程、撤销已有进程和实现进程状态转换。原语：是一种特殊程序，它的执行具有原子性，不能被中断。可以用关中断（不在例行检查是否有中断）和开中断来实现原子性 进程创建创建原语 申请 PCB 为新进程分配资源 初始化 PCB 将 PCB 插入就绪队列 引起进程创建的事件 用户登录 作业调度 提供服务 应用请求 进程终止撤销原语 从 PCB 集合找到终止进程的 PCB 进程正在运行，则剥夺其 CPU，将 CPU 分配给其他进程 终止其所有子进程 将该进程拥有的资源归还给父进程或者操作系统 删除 PCB 引起进程终止的事件 正常结束 异常结束 外界干预 进程阻塞阻塞原语 找到要阻塞的 PCB 保护进程的运行现场，将 PCB 设置为阻塞态，暂停进程的运行 将 PCB 插入相应事件的等待队列 引起进程阻塞的事件 需要等待系统分配某种资源 需要等待相互合作的其他进程完成工作 进程唤醒唤醒原语 在事件等待队列中找到 PCB 将 PCB 从等待队列移除，设置状态为就绪态 将 PCB 插入就绪队列，等待被调度 引起进程唤醒的事件 等待事件的发生 进程的切换切换原语 将运行环境的信息存入 PCB 中 PCB 移入相应队列 选择另一个进程执行，并更新其 PCB 根据 PCB 恢复新进程所需运行环境 引起进程切换的事件 当进程时间片到了 有更高优先级的进程到达 当前进程阻塞 当前进程终止 进程通信定义：指两个进程之间的数据交互共享存储：因为各进程间的内存地址是相互独立的消息传递：进程之间的数据交互以格式化的消息为单位。进程通过操作系统提供的“发生消息&#x2F;接收消息”两个原语进行交换。 直接通信方式 间接通信方式 管道通信 线程的概念线程是程序执行的最小单位，是一个基本的 CPU 单元。简单来说就是，轻量级进程。线程的实现方式 用户级线程 内核级线程 多线程模型 一对一：一个用户级线程映射一个内核级线程 多对一：多个 y 用户级线程映射到一个内核级线程 多对多：n 个用户级线程映射到 m 个内核级线程 调度概念：确定某种规则来决定处理这些任务的顺序。 进程调度的时机 当前运行的进程主动放弃处理机 进程正常终止 运行过程中发生异常而终止 进程主动请求阻塞 当前运行的进程被动的放弃处理机 分配的时间片用完 有更紧急的任务需要处理 有更高优先级的进程进入就绪队列","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://wkcollection.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://wkcollection.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"https://wkcollection.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机网络","slug":"NetWork","date":"2022-06-21T05:08:40.000Z","updated":"2022-07-08T15:35:40.510Z","comments":true,"path":"2022/06/21/NetWork/","link":"","permalink":"https://wkcollection.github.io/2022/06/21/NetWork/","excerpt":"计算机网络 基于谢希仁老师的《计算机网络 第七版》的学习，了解后能够对于网络之间的交换有更加深入的理解，学习前后端必修之课 第一章 概述互联网的历史和组成","text":"计算机网络 基于谢希仁老师的《计算机网络 第七版》的学习，了解后能够对于网络之间的交换有更加深入的理解，学习前后端必修之课 第一章 概述互联网的历史和组成 互联网的两个基本特点： 连通性：互联网上的用户之间不管相隔多远，都可以非常方便的交换信息。 共享：主要指资源共享。包括文件共享，软件共享以及硬件共享。 计算机网络是由若干结点(计算机、集线器、交换机或路由器)和连接这些结点的链路组成的。 互联网发展的三个阶段： 第一阶段：从单个网络 ARPANET 向互连网发展。1969 年美国国防部创建了第一个分组交换网 ARPANET，刚开始只是简单的分组交换网。20 世纪 70 年代，单一的网络已经无法满足所有的通信问题，于是开始研究多种网络。1983 年 TCP&#x2F;IP 协议成为 ARPANET 的标准协议，于是 1983 年作为互联网的诞生时间。 第二阶段：建成了三级结构的互联网。1985 年起，NSF 围绕六个大型计算机中心建设计算机网络，即 NSFNET。三级计算机网络分为主干网、地区网、校园网。这种三级结构覆盖了全美国主要的大学和研究所。 第三阶段：逐渐形成了多层次的 ISP 结构的互联网。 互联网的标准所有的互联网表标准都是以 RFC 的形式在互联网上发表的。但并非所有的 RFC 都是互联网标准。互联网正式标准需要经历三个阶段： 互联网草案：有效期只有六个月，此时还不能算 RFC 文档 建议标准：从这阶段开始成为 RFC 文档 互联网标准：达到正式标准后，每个标准就分配到一个编号。 互联网的组成 边缘部分：由所有连在互联网上的主机组成。 C&#x2F;S 方式：客户端&#x2F;服务器方式 P2P 方式：对等连接方式 核心部分：由大量网络和连接这些网络的路由器组成，主要为边缘部分提供服务。 路由器：实现分组交换的关键构件 分组交换的特点分组交换采用存储转发技术。将一个报文(要发送的整块数据)划分为几个分组后再进行交换。分组又称为”包”，分组的首部又称为”包头”(包含了目的地址和源地址控制信息)。 分组交换的过程:路由器收到一个分组，先暂存一下(暂存的是短分组)，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。 分组交换的优点 高效：在分组传输过程中动态分配传输带宽，对通信链路是逐段占用 灵活：为每一个分组独立地选择合适的转发路由 迅速：以分组作为传送单位，可以先不建立连接就能向其他主机发送分组 可靠：保证可靠性的网络协议，分布式多路由分组交换网 计算机网络的类别 按照网络作用范围分类 广域网：作用范围大，任务是通过长距离运送主机所发送的数据。 城域网：一般是城市，可以是一个或几个单位，也可是一种公用设施 局域网：一般用于微型计算机或工作站通过高速链路相连 个人局域网：也称为无线个人局域网 按照网络的使用者进行分类 公用网 专用网 计算机网络的性能指标速率速率指数据的传送速率，也称为数据率或比特率。单位 bit&#x2F;s(或 b&#x2F;s，bps),提到速率时往往指的是额定速率或标称速率，并非实际运行的速率。 带宽计算机中带宽指的是某通道传送数据的能力，即单位时间内网络中某信道所能通过的最高数据率。 吞吐量吞吐量指单位时间内通过某个网络的实际数据量，受网络的带宽或网络的额定速率的限制。 时延时延指数据从网络的一端传送到另一端所需时间。也被称为延迟。 时延的组成 发送时延：主机或路由器发送数据帧所需要的时间，又叫传输时延。 传播时延：传播时延是电磁波在信道传播一定距离需要花费的时间。与传输信道长度无关。信号传送距离越远，传播时延就越大。 处理时延：主机或路由器在收到分组需要花费一定时间进行处理。 排队时延：分组在传输过程中要经过许多路由器，进入路由器后要先在输入队列中排队等待处理。 总时延&#x3D;发送时延+传播时延+处理时延+排队时延 时延带宽积时延带宽积表示这个链路可以容纳的比特数 时延带宽积&#x3D;传播时延 x 带宽 往返时间 RTTRTT 表示双向交互一次所需要的时间。 利用率信道利用率指出某信道有百分之几的时间是被利用的。网络利用率则是全网络的加权平均值。信道或网络利用率过高会产生非常大的时延。 计算机网络体系结构OSI 七层参考模型1983 年正式形成了 OSI 模型，OSI 试图达到理想境界，因而全球计算机可以很方便的进行互连和数据交换。OSI 失败原因： OSI 专家缺乏实际经验，缺乏商业驱动力 OSI 协议过于复杂，运行效率低 OSI 制定的周期太长 OSI 层次划分不太合理 五层参考模型 应用层：任务是通过应用进程间的交互来完成特定的网络应用。交互的数据单元称为报文。 运输层：任务是负责向两台主机中进程之间的通信提供通用的数据传输服务。包括 TCP，UDP 协议，传输数据的单位分别是报文段和用户数据报。 网络层：负责为分组交换网上的不同主机提供通信服务。数据传输单位是 IP 数据报。 数据链路层：数据传输单位是帧。 物理层：数据传输单位是 bit。 第二章 物理层基本概念物理层考虑的是怎么才能在连接各种计算机的传输媒介上传输数据比特流。物理层的作用是要尽可能的屏蔽掉这些传输媒体和通信手段的差异。 数据通信模型一个数据通信系统可以划分为三大部分：即源系统（发送端）、传输系统和目的系统（接收端） 通信的三种方式 单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互。 双向交替通信（半双工通信）：即通信双方都可以发送消息，但不能双方同时发送。也就是说一方发送一方接收，过一段时间后可以再反过来。 双向同时通信（全双工通信）：即通信双方可以同时发送和接收消息。 传输媒介导引型 双绞线 同轴电缆 光纤 非导引型无线电波 信道复用技术频分复用用户在分配到一定的频带后，在通信过程中始终占用着这个频带。即所有用户在同样的时间段内占用着不同的带宽资源。 时分复用时分复用是指所有用户在不同时间段内占用着相同的频带宽度。 统计时分复用统计时分复用是一种改进的时分复用，他能明显的提高信道的利用率。 波分复用波分复用就是光的频分复用。 码分复用码分复用是另一种共享信道的方法。由于各用户使用经过特殊挑选的码型，因此各用户之间不会构成干扰。最初用于军事通讯。 第三章 数据链路层数据链路层使用的信道主要是：点对点信道和广播信道 点对点信道链路：指从一个结点到相邻结点的一端物理线路，而中间没有其他任何交换结点。 数据链路：除了需要一条物理线路外，还必须要有一些必要的通信协议来控制这些数据的传输。 点对点信道的协议数据单元是帧，数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出上交给网络层。 点对点信道的数据链路层进行通信的步骤： 结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧。 结点 A 把封装好的帧发送给结点 B 的数据链路层 若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层，否则丢弃这个帧。 封装成帧封装成帧就是在一端数据的前后分别添加首部和尾部，这样就够成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。 透明传输由于帧的开始和结束的标记使用专门指明的控制字符，因此所传输的数据中任何 8 比特的组合一定不允许和用作帧定界的控制符的比特编码一样，否则会导致帧定界的错误。 当传输的帧是用文本文件组成的帧时，其数据部分显然不会出现 SOH 和 EOT 这样的帧定界符，这样的传输就叫做透明传输。但是当数据部分是 ASCII 码的文本文件时，就有可能会找到错误的帧界。为了解决这样的问题，可以在出现控制字符的地方加一个转义字符，即使用字节填充法。 差错检测比特在传输过程中可能会产生差错：1 可以变成 0,0 可以变成 1。即出现比特差错。在一段时间内传输错误的比特所占传输比特总数的比率称为误码率 BER。 目前主要使用的是循环冗余检验 CRC 进行差错检测。 循环冗余 CRC 的原理：在数据(k 位数据)后面添加供差错检测用的 n 位冗余码，然后构成一个帧发送出去，一共发送 k+n 位。经过 CRC 检验后得出的余数 R 为 0，则说明传输过程无差错，否则认为出现了差错。 n 位冗余码：用二进制的模 2 运算，相当于在数据后面添加 n 个 0。得到的 k+n 位数除以收发双方事先商定的 n+1 位除数 P，得出商是 Q 而余数是 R。R 就是冗余码，又称为帧检验序列 FCS。 PPP 协议定义：PPP 协议就是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 PPP 协议要满足的要求 简单 封装成帧 透明性 多种网络层协议 多种类型链路 差错检测 检测连接状态 最大传送单元 网络层地址协商 数据压缩协商 PPP 协议的组成 一个将 IP 数据报封装到串行链路的方法。 一个用来建立、配置和测试数据链路连接的链路控制协议 LCP。 一套网络控制协议 NCP。 PPP 协议的帧格式各字段信息 首尾两个 F 表示标志位，用来表示一个帧的开始和结束；A，C 两个字段至今还未有定义；协议如果地址是 0xC021 则表示 LCP 的数据；如果是 0x0021 则表示携带的是 IP 数据报；如果是 0x8021 则表示携带的是网络层的控制数据；FCS 表示帧检测序列。 字节填充当信息字段中出现和标志字段一样的比特组合时，就要采取一些措施来解决这个问题。 当 PPP 协议使用异步传输时，转义符定义为 0x7D，并使用字节填充。 零比特填充只要出现连续的 5 个 1 就在后面填充 1 个 0；这样就可以保证不会出现连续的 6 个 1。接收端在收到帧后，先找到标志字段 F 确定边界，当出现 5 个连续 1 时就将后面的 0 删除，将数据还原为原来的比特流。 PPP 协议的工作状态 广播信道局域网：网络为一个单位所有，且地理范围和站点数目有限。 局域网按网络拓扑分类：星形网；环形网；总线网。 CSMA&#x2F;CD 协议（载波监听多点接入、碰撞检测）因为在同一时间只能允许一台计算机发送数据。于是 CSMA&#x2F;CD 协议就诞生了。 “多点接入”说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。 “载波监听”就是指用电子技术检测总线上有无其他计算机也在发送。 “碰撞检测”就是边发送边监听。 第四章 网络层IP 协议分类的 IP 地址IP 地址及其表示方法整个互联网是一个单一的、抽象的网络。IP 地址就是给互联网上的每一台主机的每一个接口分配一个在全世界范围内的唯一的 32 位的标识符。IP 地址现在由互联网名字和数字分配机构进行分配。 IP 地址的编址方法的历史过程 分类的 IP 地址定义：分类的 IP 地址就是将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成。第一个字段是网络号，表示主机所连接到的网络。第二个字段是主机号，表示该主机或路由器。一台主机号在他前面的网络号所指明的网络范围内必须唯一。 记为：IP 地址：：&#x3D;{&lt;网络号&gt;，&lt;主机号&gt;} IP 地址共分为 5 大类： 为了提高可读性，常把 32 位 IP 地址中的每 8 位插入一个空格，采用点分十进制记法。 子网的划分详情见第 135 页 IP 地址：：&#x3D;{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;} 子网掩码 使用子网掩码和 IP 地址进行与运算就可以得出网络地址 使用子网时的分组转发 路由表必须包括：目的网络地址、子网掩码、下一跳地址 构造超网（CIDR）IP 地址：：&#x3D;{&lt;网络前缀&gt;,&lt;主机号&gt;} 具体见书第 142 页 常用的三种类别的 IP 地址A 类A 类地址网络号只有 7 位可用。可以指派 2^7-2 个网络号，第一，IP 地址全 0 的是保留地址表示本网络，第二，网络号位 127 的保留作为本地软件的环回测试。A 类地址主机号占 3 个字节，A 类网络的最大主机数位 2^24-2，第一，全 0 的主机号字段表示 IP 地址是本主机所连接到的单个网络地址，第二，全 1 的表示网络上的所有主机。 B 类B 类地址网络只有 14 位可用，因为 B 类地址不可能出现全 0 或全 1 的情况，所以网络号不存在少 2 的情况，实际上 128.0.0.0 是不指派的，所以可以指派的网络数为 2^14-1，即 16383 个；而 B 类最大主机数为 2^16-2 个，需要除去全 0 和全 1 的。B 类地址占整个 IP 空间的 25%。 C 类C 类地址有 3 个字节的网络号字段，除去前面的类别位，还有 21 位可用，C 类网络地址 192.0.0.0 也不指派，可以指派的最小网络地址为 192.0.1.0，因此 C 类地址可指派的网络总数是 2^21-1，每一个 C 类地址的最大主机数为 2^8-2，占整个 IP 地址的 12.5%。 IP 地址的重要特点 每个 IP 地址都由网络号和主机号组成。IP 地址是一种分等级的地址结构。分等级后，第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。第二，路由器仅仅根据目的主机所连接的网络号来转发分组，可以使路由表的项目数大幅度减少，从而减少了路由表所占的内存以及查找路由表所需要的时间。 实际上 IP 地址时标志一台主机和一条链路的接口。 用转发器或网桥连接起来的若干局域网仍然为一个网络。 IP 地址内所分配得到的地址都是平等的。 IP 数据报格式IP 数据报格式能够说明 IP 协议具有什么功能 IP 数据报具体部分见书籍 128 页 地址解析协议 ARPIP 地址与硬件地址从层次角度看，物理地址是数据链路层和物理层使用的地址，而 IP 地址是指网络层和以上各层使用的地址，是一种逻辑地址。 ARP 协议的概念及原理地址解析协议 ARP 就是用来解决同一个局域网上，知道一个机器的 IP 地址，找到其对应的 MAC 地址。 具体实现原理：每一台主机都设有一个 ARP 高速缓存，里面有本局域网上的各个主机和路由器的 IP 地址到硬件地址的映射表。 网际控制报文协议 ICMP为了更有效的转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP。ICMP 允许主机或路由器报告差错情况和提供有关异常的情况。 ICMP 报文种类ICMP 差错报告报文 终点不可达 超时 参数问题 改变路由（重定向） ICMP 询问报文 回送请求和回答 时间戳请求和回答 重要应用就是 PING，用来测试两台主机的连通性。 网际组管理协议 IGMP","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://wkcollection.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://wkcollection.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://wkcollection.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Nodejs","slug":"Nodejs","date":"2022-06-20T11:52:10.000Z","updated":"2022-07-15T13:59:48.429Z","comments":true,"path":"2022/06/20/Nodejs/","link":"","permalink":"https://wkcollection.github.io/2022/06/20/Nodejs/","excerpt":"Nodejs学习什么是Nodejs?Nodejs是一个建立在Chrome的Javascript的V8引擎上的一个Javascript运行时环境。简单的说Nodejs就是运行在服务端的Javascript。","text":"Nodejs学习什么是Nodejs?Nodejs是一个建立在Chrome的Javascript的V8引擎上的一个Javascript运行时环境。简单的说Nodejs就是运行在服务端的Javascript。 特性： 文件读写 进程管理 网络通信","categories":[{"name":"Node","slug":"Node","permalink":"https://wkcollection.github.io/categories/Node/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://wkcollection.github.io/tags/Nodejs/"},{"name":"后端","slug":"后端","permalink":"https://wkcollection.github.io/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Git学习","slug":"Git","date":"2022-06-19T11:43:08.000Z","updated":"2022-06-21T05:42:29.729Z","comments":true,"path":"2022/06/19/Git/","link":"","permalink":"https://wkcollection.github.io/2022/06/19/Git/","excerpt":"Git学习 学习git这一种主流的版本控制系统 什么是”版本控制”？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。","text":"Git学习 学习git这一种主流的版本控制系统 什么是”版本控制”？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 git的三种状态已提交：commited已提交表示数据已经安全的保存在本地数据库中。 已修改：modified已修改表示修改了文件，但还没保存到数据库中。 已暂存：staged已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 git的三个工作区 git仓库Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作”索引”，不过一般说法还是叫暂存区域。 基本的 Git 工作流程 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 git的安装Linux上安装以Fedora 上为例： 1sudo yum install git 如果你在基于 Debian 的发行版上： 1sudo apt-get install git Mac上安装最简单的方法是安装 Xcode或者git官网 下载二进制文件安装 Windows上安装在 Windows 上安装 Git 也有几种安装方法。官方版本可以在 Git 官方网站下载。 从源代码安装如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装Git的二进制版： 12sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-develsudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev 为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包： 12sudo yum install asciidoc xmlto docbook2xsudo apt-get install asciidoc xmlto docbook2x 从 GitHub 网站上的镜像来获得最新发布版本的 tar 包 123456tar -zxf git-2.0.0.tar.gzcd git-2.0.0 make configure ./configure --prefix=/usr make all doc info sudo make install install-doc install-html install-info git的配置初次启动（配置环境变量）对于Linux系统，Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。这些变量存储在三个不同的位置： &#x2F;etc&#x2F;gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的git config 时，它会从此文件读写配置变量。 ~&#x2F;.gitconfig 或 ~&#x2F;.config&#x2F;git&#x2F;config 文件：只针对当前用户。 可以传递 –global 选项让 Git读写此文件。 当前使用仓库的 Git 目录中的 config 文件（就是 .git&#x2F;config）：针对该仓库。 每一个级别覆盖上一级别的配置，所以 .git&#x2F;config 的配置变量会覆盖 &#x2F;etc&#x2F;gitconfig 中的配置变量。 对于windows系统，Git 会查找 $HOME$ 目录下（一般情况下是 C:\\Users\\$USER$）的 .gitconfig 文件。 设置用户信息每一次 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 12git config --global user.name &quot;Mr.W&quot; #配置用户名git config --global user.email xxxxxxxx@qq.com #配置邮箱 使用–global代表全局设置，该命令只需要运行一次，之后无论你在该系统上做任何事情， Git 都会使用这些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行不带 –global 选项的命令来配置。 指定文本编辑器Git 会使用操作系统默认的文本编辑器，通常是 Vim。如果你想使用不同的文本编辑器，例如 Emacs，可以这样做： 1git config --global core.editor emacs 检查配置信息如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。 1git config --list 可以通过输入 git config ： 来检查 Git 的某一项配置： 1git config user.name 获取帮助手册123git help &lt;verb&gt; #方式一git &lt;verb&gt; --help #方式二man git-&lt;verb&gt; #在linux上可以方式三 git基础获取git仓库 在现有项目或目录下导入所有文件到 Git 中 从一个服务器克隆一个现有的 Git 仓库 初始化仓库进入该项目目录并输入： 1git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是Git 仓库的核心。 如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。你可通过 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交： 123git add *.cgit add LICENSEgit commit -m &#x27;initial project version&#x27; 克隆仓库如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令。当执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 1git clone [url] 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令： 1git clone [url] 本地仓库的名字 经常报错: OpenSSL SSL_read: Connection was reset, errno 10054解决方法如下： 1git config --global http.sslVerify &quot;false&quot; Git 支持多种数据传输协议。上面的例子使用的是 https:&#x2F;&#x2F; 协议，不过你也可以使用 git:&#x2F;&#x2F; 协议或者使用SSH 传输协议，比如 user@server:path&#x2F;to&#x2F;repo.git 记录每次更新到仓库工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放 入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。使用 Git 时文件的生命周期如下： 检查当前文件状态要查看哪些文件处于什么状态，可以用 git status 命令 1git status 如果在克隆仓库后立即使用此命令，会看到类似这样的输出： 12On branch masternothing to commit, working directory clean 这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息 还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是 “master”,这是默认的分支名。 跟踪新文件使用命令 git add 开始跟踪一个文件。所以，要跟踪 README 文件，运行： 1git add README 此时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态： 123456git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README 只要在 Changes to be committed 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。 暂存已修改文件现在我们来修改一个已被跟踪的文件。如果你修改了一个名为 Git.md 的已被跟踪的文件，然后运行 git status 命令，会看到下面内容： 12345678910On branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: Git.md new file: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Git.md 文件 Git.md 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 git add 命令。这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 123456789git add Git.mdgit statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: Git.md new file: README 现在两个文件都已暂存，下次提交时就会一并记录到仓库。假设此时，你想要在 CONTRIBUTING.md 里再加条注释，重新编辑存盘后，准备好提交。不过且慢，再运行 git status 看看： 12345678910On branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: Git.md new file: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Git.md 现在 Git.md 文件同时出现在暂存区和非暂存区。实际上 Git 只不过暂存了你运行 git add 命令时的版本，如果你现在提交，Git.md 的版本是你最后一次运行git add 命令时的那个版本，而不是你运行 git commit 时，在工作目录中的当前版本。所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来： 123456789git add Git.mdgit status On branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: Git.md new file: README 状态简览git status 命令的输出十分详细，但其用语有些繁琐。如果你使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出。 1234567git status -s M READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,lib/simplegit.rb 文件被修改了并将修改后的文件放入了暂存区。而Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。 忽略文件(.gitignore)一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文 件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为 .gitignore的文件，列出要忽略的文件模式。来看一个实际的例子： 1234cat .gitignore*.[oa]*~ 文件 .gitignore 的格式规范如下： 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以/开头防止递归。 匹配模式可以以/结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号*匹配零个或多个任意字符；[abc] 匹配任 何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号?只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。使用两个星号** 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z,a/b/z 或 a/b/c/z等。 查看已暂存和未暂存的修改如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。git diff 将通过文件补丁的格式显示具体哪些行发生了改变。 12345678910111213git diffwarning: LF will be replaced by CRLF in Git.md.The file will have its original line endings in your working directorydiff --git a/Git.md b/Git.mdindex b49f414..661e036 100644--- a/Git.md+++ b/Git.md@@ -1,3 +1,4 @@ Git Test Modified Second Modified+Third Modified 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。 若要查看已暂存的将要添加到下次提交里的内容，可以使用 git diff –staged 提交更新现在的暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit： 1git commit 默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。如果想要更详细的对修改了哪些内容的提示，可以用 -v 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。 另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行： 1git commit -m &quot;git second commit&quot; 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤： 1git commit -a -m &quot;git third commit&quot; 移除文件要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单了。 如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是未暂存清单）看到： 1234567git rm READMEgit statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) deleted: README 下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f。这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 git 恢复。 另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 12345678910git rm --cached test.txtgit statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) deleted: test.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) test.txt 移动文件1234567891011git mv Git.md git.mdgit statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) renamed: Git.md -&gt; git.md deleted: test.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) test.txt 其实，运行 git mv 就相当于运行了下面三条命令： 123mv README.md READMEgit rm README.mdgit add README 查看提交历史在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史.完成这个任务最简单而又有效的工具是 git log 命令。 1git log 默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 git log 有许多选项可以帮助你搜寻你所要找的提交，接下来我们介绍些最常用的。一个常用的选项是 -p，用来显示每次提交的内容差异。你也可以加上 -2 来仅显示最近两次提交： 1git log -p -2 你也可以为 git log 附带一系列的总结性选项。比如说，如果你想看到每次提交的简略的统计信息，你可以使用 –stat 选项： 1git log --stat 另外一个常用的选项是 –pretty。这个选项可以指定使用不同于默认格式的方式展示提交历史。这个选项有一些内建的子选项供你使用。比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。另外还有short，full 和 fuller 可以用，展示的信息或多或少有些不同。 1git log --pretty=oneline 有用的是 format，可以定制要显示的记录格式。 1git log --pretty=format:&quot;%h - %an, %ar : %s&quot; git log –pretty&#x3D;format 常用的选项 列出了常用的格式占位符写法及其代表的意义。 当 oneline 或 format 与另一个 log 选项 –graph 结合使用时尤其有用。这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史： 1git log --pretty=format:&quot;%h %s&quot; --graph git log 的常用选项: 限制输出长度除了定制输出格式的选项之外，git log 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。之前你已经看到过 -2 了，它只显示最近的两条提交，实际上，这是 - 选项的写法，其中的 n 可以是任何整数，表示仅显示最近的若干条提交。不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调 用分页程序，所以你一次只会看到一页的内容。 另外还有按照时间作限制的选项，比如 –since 和 –until 也很有用。例如，下面的命令列出所有最近两周内的提交： 1git log --since=2.weeks 另一个非常有用的筛选选项是 -S，可以列出那些添加或移除了某些字符串的提交。比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用： 1git log -SModified 限制 git log 输出的选项: 撤消操作在任何一个阶段，你都有可能想要撤消某些操作。这里，我们将会学习几个撤消你所做修改的基本工具。 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 –amend 选项的提交命令尝试重新提交，这个命令会将暂存区中的文件提交。： 1git commit --amend 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。 取消暂存的文件例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了git add * 暂存了它们两个。如何只取消暂存两个中的一个呢？ 1git reset HEAD CONTRIBUTING.md 撤消对文件的修改如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 1git checkout -- CONTRIBUTING.md git远程仓库 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 查看远程仓库如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。它会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字： 1git remote 你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。 1git remote -v 添加远程仓库首先在github上创建一个仓库，然后clone到本地，再然后运行git remote add 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写： 1git remote add gs https://github.com/mygit-WK/gStudy.git 现在你可以在命令行中使用字符串 gs来代替整个 URL。例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch gs： 1git fetch gs 从远程仓库中抓取与拉取从远程仓库中获得数据，可以执行： 1git fetch [remote-name] 这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。所以git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。必须注意 git fetch 命令会将数据拉取到你的本地仓库它并不会自动合并或修改你当前的工作。 如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送到远程仓库当你想分享你的项目时，必须将其推送到上游。这个命令很简单：git push [remote-name] [branch-name]。当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器： 1git push origin master 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 查看远程仓库如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息： 1git remote show origin 远程仓库的移除与重命名如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 1git remote rename gs gitstudy 可以使用 git remote rm 来移除远程仓库： 1git remote rm gitstudy git标签列出标签1git tag 创建标签Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated） 在 Git 中创建一个附注标签是很简单的。最简单的方式是当你在运行 tag 命令时指定 -a 选项，-m 选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息： 1git tag -a v1.0 -m &#x27;my version 1.0&#x27; 通过使用 git show 命令可以看到标签信息与对应的提交信息： 1git show v1.0 另一种给提交打标签的方式是使用轻量标签。轻量标签本质上是将提交校验和存储到一个文件中,没有保存任何其他信息。创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字： 1git tag v1.0-lw 后期打标签你也可以对过去的提交打标签。现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。你可以在之后补上标签。要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）: 1git tag -a v1.2 9fceb02 共享标签默认情况下，git push 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样 - 你可以运行 git push origin [tagname]。 1git push origin v1.5 如果想要一次性推送很多标签，也可以使用带有 –tags 选项的 git push 命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。 1git push origin --tags 检出标签在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支： 1git checkout -b version2 v2.0.0 Git 别名Git 并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的 Git 命令，可以通过 gitconfig 文件来轻松地为每一个命令设置一个别名。这里有一些例子你可以试试： 1234git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st status 这意味着，当要输入 git commit时，只需要输入 git ci。 可以向 Git 中 添加你自己的取消暂存别名： 1git config --global alias.unstage &#x27;reset HEAD --&#x27; 等价于： 12git unstage fileAgit reset HEAD -- fileA 通常也会添加一个 last 命令，可以轻松地看到最后一次提交： 1git config --global alias.last &#x27;log -1 HEAD&#x27;","categories":[{"name":"Git","slug":"Git","permalink":"https://wkcollection.github.io/categories/Git/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://wkcollection.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"git","slug":"git","permalink":"https://wkcollection.github.io/tags/git/"}]},{"title":"Cpp学习","slug":"Cpp","date":"2022-06-19T08:05:43.000Z","updated":"2022-07-19T12:37:20.639Z","comments":true,"path":"2022/06/19/Cpp/","link":"","permalink":"https://wkcollection.github.io/2022/06/19/Cpp/","excerpt":"C++学习数组 方便存放同类型的元素 一维数组一维数组数组名代表数组的首地址 一维数组名可以计算出数组在内存空间所占内存大小 二维数组二维数组名代表二维数组的首地址，也可以查看某行的首地址 二维数组可以计算出数组在内存空间所占内存大小，也可以计算出某行所占内存大小","text":"C++学习数组 方便存放同类型的元素 一维数组一维数组数组名代表数组的首地址 一维数组名可以计算出数组在内存空间所占内存大小 二维数组二维数组名代表二维数组的首地址，也可以查看某行的首地址 二维数组可以计算出数组在内存空间所占内存大小，也可以计算出某行所占内存大小 指针 作用：保存地址 指针的定义：数据类型 *指针变量名32位操作系统指针所占内存空间：4个字节 64位操作系统指针所占内存空间：8个字节 指针的两大类型空指针： 指针变量指向内存编号为0的空间 空指针指向内存无法访问，0~255内存编号给系统占用的，无法访问 可用于给指针变量初始化 野指针：指针变量指向非法空间，要尽量避免 const与指针结合const修饰指针称为常量指针:指针指向的值不能变，指针的指向可以变 123456789101112#include &lt;iostream&gt;using namespace std;int main(int argc, char** argv) &#123;// 常量指针：指针指向的值不能变，指针的指向可以变 int a=20; const int *p=&amp;a; int b=30; p=&amp;b;//指针的指向可以改，由指向a修改为指向b // *p=b; 指向的值不能改 cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; const修饰常量称为指针常量(此处为简称，为了方便记忆，事实上这样的称呼是不准确的，因为编译器可能每次为该变量分配的内存地址都不一样)：指针指向的值可以改，指针的指向不可以修改 123456789101112#include &lt;iostream&gt;using namespace std;int main(int argc, char** argv) &#123;// 指针常量：指针指向的值可以改，指针的指向不可以修改 int a=20; int * const p=&amp;a; int b=30; *p=b; //指向的值可以改// p=&amp;b;//指针的指向不能改 cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; const既修饰常量又修饰指针：指针的指向不能改，指针指向的值也不能改 123456789101112#include &lt;iostream&gt;using namespace std;int main(int argc, char** argv) &#123;// const既修饰常量又修饰指针：指针的指向不能改，指针指向的值也不能改 int a=20; const int * const p=&amp;a; int b=30;// *p=b; //指向的值不可以改// p=&amp;b;//指针的指向不能改 cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 指针与数组123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main(int argc, char** argv) &#123;// 访问数组的第一种方式 int array[10]= &#123;1,2,3,4,5,6,7,8,9,10&#125;; int *p; for(int i=0; i&lt;10; i++) &#123; cout&lt;&lt;array[i]&lt;&lt;endl; &#125; cout&lt;&lt;&quot;利用指针访问数组元素:&quot;&lt;&lt;endl; p=array;// 利用指针访问数组元素 for(int i=0; i&lt;10; i++) &#123; cout&lt;&lt;*p&lt;&lt;endl; p++; &#125; return 0;&#125; 指针与函数值传递：不会改变实参的值 地址传递（引用传递）：会改变实参的值 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;void swap(int a,int b);void swap2(int *a,int *b);int main(int argc, char** argv) &#123;// 指针函数// 值传递:不改变实参的值 int a=10,b=20; cout&lt;&lt;&quot;交换前:a:&quot;&lt;&lt;a&lt;&lt;&quot; b:&quot;&lt;&lt;b&lt;&lt;endl; swap(a,b); cout&lt;&lt;&quot;交换后:a:&quot;&lt;&lt;a&lt;&lt;&quot; b:&quot;&lt;&lt;b&lt;&lt;endl;// 引用传递：改变实参的值 cout&lt;&lt;&quot;交换前:a:&quot;&lt;&lt;a&lt;&lt;&quot; b:&quot;&lt;&lt;b&lt;&lt;endl; swap2(&amp;a,&amp;b); cout&lt;&lt;&quot;交换后:a:&quot;&lt;&lt;a&lt;&lt;&quot; b:&quot;&lt;&lt;b&lt;&lt;endl; return 0;&#125;void swap(int a,int b) &#123; int temp; temp=a; a=b; b=temp;&#125;void swap2(int *a,int *b) &#123; int temp; temp=*a; *a=*b; *b=temp;&#125; 结构体 属于用户自定义的数据类型 结构体定义语法：struct 结构体名 {结构体成员列表}； 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct people &#123; string name; int age; int sex;&#125; p3;void display(people p);int main(int argc, char** argv) &#123;// 1. struct 结构体名 变量名； struct people p1; p1.name=&quot;张三&quot;; p1.age=20; p1.sex=0; display(p1);// 2. struct 结构体名 变量名=&#123;值1，值2&#125;； struct people p2= &#123;&quot;李四&quot;,22,1&#125;; display(p2);// 3. 定义结构体时顺便创建变量； p3.name=&quot;王五&quot;; p3.age=26; p3.sex=3; display(p3); return 0;&#125;void display(people p) &#123; cout&lt;&lt;&quot;name:&quot;&lt;&lt;p.name&lt;&lt;&quot; age:&quot;&lt;&lt;p.age&lt;&lt;&quot; sex:&quot;&lt;&lt;p.sex&lt;&lt;endl;&#125; 结构体数组12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct people &#123; string name; int age;&#125;;int main(int argc, char** argv) &#123;// 结构体数组定义 people ps[2]= &#123; &#123;&quot;刘邦&quot;,200&#125;, &#123;&quot;周瑜&quot;,2000&#125; &#125;;// 结构体遍历 for(int i=0; i&lt;2; i++) &#123; cout&lt;&lt;&quot;name:&quot;&lt;&lt;ps[i].name&lt;&lt;&quot; age:&quot;&lt;&lt;ps[i].age&lt;&lt;endl; &#125; return 0;&#125; 结构体指针作用：通过指针访问结构体中的成员 结构体变量通过.操作符访问，结构体指针通过-&gt;访问结构体成员 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct people &#123; string name; int age;&#125;;int main(int argc, char** argv) &#123; people p1= &#123;&quot;张三&quot;,100&#125;; people *p=&amp;p1;// 利用结构体指针进行访问 cout&lt;&lt;&quot;name:&quot;&lt;&lt;p-&gt;name&lt;&lt;&quot; age:&quot;&lt;&lt;p-&gt;age&lt;&lt;endl; return 0;&#125; 内存四区代码区用途：存放函数体的二进制代码，由操作系统进行管理 代码区是共享的，共享是针对需要频繁执行的程序，只需要在内存中有一份代码即可 代码区是只读的，只读为了防止程序意外修改了指令 栈区用途：有编译器自动分配释放，存放函数的参数值、局部变量等 堆区用途：由程序员分配和释放，若程序员不分配释放，程序结束时由操作系统回收 使用new关键字进行内存申请，使用delete关键字进行内存释放，数组需要使用delete[]进行释放 全局区用途：存放全局变量、静态变量以及常量 包含常量区、字符串常量和其他常量 包括全局变量、全局常量、静态变量和字符串常量 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;// 全局变量int g=10;int h=10;// 全局常量const int i=10;const int j=10;int main(int argc, char** argv) &#123;// 局部变量 int a=10; int b=10; cout&lt;&lt;&quot;&amp;a=&quot;&lt;&lt;(int *)&amp;a&lt;&lt;&quot; &amp;b=&quot;&lt;&lt;(int *)&amp;b&lt;&lt;endl;// 局部常量 const int c=20; const int d=20; cout&lt;&lt;&quot;&amp;c=&quot;&lt;&lt;(int *)&amp;c&lt;&lt;&quot; &amp;d=&quot;&lt;&lt;(int *)&amp;d&lt;&lt;endl;// 静态变量 static int e=10; static int f=10; cout&lt;&lt;&quot;&amp;e=&quot;&lt;&lt;(int *)&amp;e&lt;&lt;&quot; &amp;f=&quot;&lt;&lt;(int *)&amp;f&lt;&lt;endl; cout&lt;&lt;&quot;&amp;g=&quot;&lt;&lt;(int *)&amp;g&lt;&lt;&quot; &amp;h=&quot;&lt;&lt;(int *)&amp;h&lt;&lt;endl; cout&lt;&lt;&quot;&amp;i=&quot;&lt;&lt;(int *)&amp;i&lt;&lt;&quot; &amp;j=&quot;&lt;&lt;(int *)&amp;j&lt;&lt;endl;// 字符串常量 cout&lt;&lt;&quot;&amp;str=&quot;&lt;&lt;(int *)&amp;&quot;hello world&quot;&lt;&lt;endl; return 0;&#125; C++特点引用 给内存地址取别名，本质是指针常量 基本语法：数据类型 &amp;别名&#x3D;原名 注意事项：引用必须初始化，一旦初始化不可更改 引用做函数参数：可以简化指针修改实参 引用做函数返回值：可以作为函数左值，但是不要返回局部变量的引用 常引用：可以防止形参改变实参，即变为只读状态 函数进阶函数默认参数：返回值类型 函数名（参数&#x3D;默认值）{}，如果某个参数有默认值那么从这个默认值开始从左向右都得有默认值；函数声明有默认值，那么实现就不能有默认值。 函数的占位参数：调用时必须传递实参。 函数重载：同一个作用域，函数名称相同，函数的参数类型不同或者个数不同或者顺序不同；返回值不作为函数重载的条件。 面向对象封装ex:设计圆类，通过半径求周长 1234567891011121314151617#include &lt;iostream&gt;#define PI 3.14using namespace std;class Circle &#123; public : //半径 float radius; float calc() &#123; return 2*PI*radius; &#125;&#125;;int main(int argc, char** argv) &#123; Circle c; c.radius=10; cout&lt;&lt;&quot;圆的周长为：&quot;&lt;&lt;c.calc()&lt;&lt;endl; return 0;&#125; 访问权限： 权限类型 类内 类外 public 允许 允许 protected 允许 不允许 private 允许 不允许 对于protected儿子可以访问父亲的保护内容 对于private儿子不可以访问父亲的保护内容 对象特性 空对象占用1bit的内存空间，编译器会给每个空对象也分配一个字节，是为了区分空对象的位置 构造函数和析构函数不提供构造函数和析构函数，编译器会默认提供空实现的构造函数和析构函数。 构造函数（进行初始化操作）：类名（）{} 构造函数的分类： 有参构造和无参构造 普通构造和拷贝构造 调用方法： 括号法：调用无参构造函数时别带小括号，否则编译器会认为是函数的声明 显示法：不能用拷贝构造函数初始化匿名对象，编译器会默认忽视小括号，从而造成重定义 隐式法 调用规则： 如果用户自定义有参构造函数，C++就不再提供默认无参构造函数，但是会提供默认拷贝构造函数 如果用户自定义拷贝构造函数，C++不在提供其他构造函数 析构函数（进行销毁操作）：~类名（）{} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Man &#123; public: Man() &#123; cout&lt;&lt;&quot;无参构造函数调用&quot;&lt;&lt;endl; &#125; Man(string name) &#123; this-&gt;name=name; cout&lt;&lt;&quot;有参构造函数调用&quot;&lt;&lt;endl; &#125; Man(const Man &amp;m) &#123; this-&gt;name=m.name; this-&gt;age=m.age; cout&lt;&lt;&quot;拷贝构造函数调用&quot;&lt;&lt;endl; &#125; ~Man() &#123; cout&lt;&lt;&quot;析构函数调用&quot;&lt;&lt;endl; &#125; private: string name; int age;&#125;;int main(int argc, char** argv) &#123; /** 调用方式: 括号法 显示法 隐式法 */// 方式一:括号法 Man m; Man m1(&quot;张三&quot;); Man m2(m1); /*注意：调用无参构造函数时别带小括号，这一点可Java有所不同， 同时使用this-&gt;而不是this.*/// 方式二：显示法 Man m3=Man(); Man m4=Man(&quot;李四&quot;); Man m5=Man(m4);// 匿名对象 Man(&quot;赵四&quot;); /*不能用拷贝构造函数初始化匿名对象 Man(m5)==Man m5,编译器会忽略小括号 */// 方式三：隐式法 Man m6=m5; return 0;&#125; 拷贝构造函数的作用： 使用一个已经创建完毕的对象来初始化新对象 值传递的方式传参 值方式返回局部对象 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class People &#123; public: People() &#123; cout&lt;&lt;&quot;默认构造函数调用&quot;&lt;&lt;endl; &#125; People(string name,int age) &#123; this-&gt;name=name; this-&gt;age=age; cout&lt;&lt;&quot;有参构造函数调用&quot;&lt;&lt;endl; &#125; People(const People &amp;p) &#123; this-&gt;name=p.name; this-&gt;age=p.age; cout&lt;&lt;&quot;拷贝构造函数调用&quot;&lt;&lt;endl; &#125; string name; int age;&#125;;void test(People p) &#123;&#125;People test1() &#123; People p(&quot;王五&quot;,10); return p;&#125;int main(int argc, char** argv) &#123;// 方式一：用一个已经创建好的对象来初始化新对象// People p(&quot;张三&quot;,18);// People p1(p);// 方式二：用于函数传参// test(p);// 方式三：用于返回局部对象 People p1=test1(); cout&lt;&lt;&quot;name:&quot;&lt;&lt;p1.name&lt;&lt;&quot; age:&quot;&lt;&lt;p1.age&lt;&lt;endl; return 0;&#125; 深拷贝与浅拷贝浅拷贝：简单的赋值操作，会导致内存重复释放 深拷贝：在堆区重新申请空间，进行拷贝操作 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class People &#123; public: People() &#123; cout&lt;&lt;&quot;无参构造函数&quot;&lt;&lt;endl; &#125; People(string name,int age,int height) &#123; this-&gt;name=name; this-&gt;age=age; this-&gt;height=new int(height); cout&lt;&lt;&quot;有参构造函数&quot;&lt;&lt;endl; &#125; People(const People &amp;p) &#123; this-&gt;name=p.name; this-&gt;age=p.age;// this-&gt;height=p.height;//为了解决浅拷贝所带来的内存重复释放的问题，在拷贝时主动向堆区申请一块内存空间 this-&gt;height=new int(*p.height);//此语句解决浅拷贝所带的问题 cout&lt;&lt;&quot;拷贝构造函数&quot;&lt;&lt;endl; &#125; ~People() &#123; if(height!=NULL) &#123; delete height; height=NULL; &#125; cout&lt;&lt;&quot;析构函数调用&quot;&lt;&lt;endl; &#125; string name;//姓名 int age;//年龄 int *height;//身高&#125;;int main(int argc, char** argv) &#123; People p(&quot;张胜男&quot;,18,170); cout&lt;&lt;&quot;name:&quot;&lt;&lt;p.name&lt;&lt;&quot; age:&quot;&lt;&lt;p.age&lt;&lt;&quot; height:&quot;&lt;&lt;*p.height&lt;&lt;endl; People p1(p); cout&lt;&lt;&quot;name:&quot;&lt;&lt;p1.name&lt;&lt;&quot; age:&quot;&lt;&lt;p1.age&lt;&lt;&quot; height:&quot;&lt;&lt;*p1.height&lt;&lt;endl; return 0;&#125; 初始化列表12345678910111213#include &lt;iostream&gt;using namespace std; class People&#123; public: People(int age,int sex):age(age),sex(sex)&#123; &#125; int age; int sex;&#125;;int main(int argc, char** argv) &#123; People p(18,0); return 0;&#125; 静态成员 静态成员变量 所有对象共享一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数：可以通过对象或类名访问 所有对象共享同一个函数 静态成员函数只能访问静态成员变量，不能访问非静态成员变量 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class People &#123; public: People() &#123; &#125; People(int age) &#123; this-&gt;age=age; &#125; int age; static int sex; static void func() &#123; cout&lt;&lt;&quot;性别是:&quot;&lt;&lt;sex&lt;&lt;endl; &#125;&#125;;// 类外初始化int People::sex=1;int main(int argc, char** argv) &#123;// 方式一：对象名 People p(10); p.func();// 方式二：类名 People::func(); return 0;&#125; this指针与空指针this的用途：解决命名冲突和制造链式调用 空指针也能访问成员函数，需要加以判断保证代码的健壮性 常函数和常对象 常函数内不可以修改成员属性 成员属性加mutable后就可以修改属性 常对象只能调用常函数 123456789101112131415161718#include &lt;iostream&gt;using namespace std;class People &#123; public: People(int age,int sex) &#123; this-&gt;age=age; this-sex=sex; &#125;// 常函数 ，加const后实际上修饰的是this，则this指向的内容也不可以改 void print() const &#123; cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;&quot; sex:&quot;&lt;&lt;sex&lt;&lt;endl; &#125; int age; int sex;&#125;;int main(int argc, char** argv) &#123; return 0;&#125; 友元全局函数做友元12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class People &#123;// 告诉编译器goodBrother是People的友元函数，可以访问People的private变量 friend void goodBrother(People &amp;p); public: People() &#123; this-&gt;sitroom=&quot;客厅&quot;; this-&gt;bedroom=&quot;卧室&quot;; &#125; public: string sitroom; private: string bedroom;&#125;;void goodBrother(People &amp;p) &#123; cout&lt;&lt;&quot;好兄弟正在进入你的&quot;&lt;&lt;p.sitroom&lt;&lt;endl; cout&lt;&lt;&quot;好兄弟正在进入你的&quot;&lt;&lt;p.bedroom&lt;&lt;endl;&#125;int main(int argc, char** argv) &#123; People p; goodBrother(p); return 0;&#125; 友元类12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Brother &#123;// 声明People是Brother的友元类 friend class People; public: Brother() &#123; wc=&quot;厕所&quot;; bathroom=&quot;浴室&quot;; &#125; string wc; private: string bathroom;&#125;;class People &#123; public: People() &#123; sittingroom=&quot;客厅&quot;; bedroom=&quot;卧室&quot;; &#125; string sittingroom; void visit(Brother &amp;b) &#123; cout&lt;&lt;&quot;正在访问好兄弟的&quot;&lt;&lt;b.bathroom&lt;&lt;endl; &#125; private: string bedroom;&#125;;int main(int argc, char** argv) &#123; Brother b; People p; p.visit(b); return 0;&#125; 成员函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;//成员函数做友元class Building;class GoodGay&#123;public: GoodGay(); ~GoodGay(); void visit();// 让 visit 访问Building中的私有函数 void visit2();// 让 visit2 不可以访问Building中的私有函数 Building *building;//指向对象的指针，在构造函数中要初始化指针&#125;;class Building&#123; //GoodGay类下的visit成员函数作为本类的好朋友，可以访问私有成员变量 friend void GoodGay::visit();public: string m_SittingRoom; Building();private: string m_BedRoom;&#125;;Building::Building()&#123; m_SittingRoom = &quot;客厅&quot;; m_BedRoom = &quot;卧室&quot;;&#125;GoodGay::GoodGay()&#123; //创建一个建筑物的对象 //用new再堆区中申请一片空间返回的是一个指针，用building来接受这个指针，完成building初始化 building = new Building; &#125;GoodGay::~GoodGay()&#123; delete building;&#125;void GoodGay::visit()&#123; cout &lt;&lt; &quot;visit函数: Public &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;visit函数: Private &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void GoodGay::visit2()&#123; cout &lt;&lt; &quot;visit2函数: Public &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //visit2函数不是Building的友元函数，不能访问其私有变量m_BedRoom&#125;void test01()&#123; GoodGay gg; gg.visit(); gg.visit2();&#125;int main()&#123; test01(); return 0;&#125; 运算符重载加号运算符重载成员函数重载+运算符和全局函数重载+运算符 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 加号运算符重载class Number &#123; public: Number() &#123; &#125; Number(int n) &#123; this-&gt;num=n; &#125;// 成员函数重载+// Number operator+(Number &amp;n) &#123;// Number temp;// temp.num=this-&gt;num+n.num;// return temp;// &#125; int num;&#125;;// 全局函数重载+Number operator+(Number &amp;n1,Number &amp;n2) &#123; Number n3; n3.num= n1.num+n2.num; return n3;&#125;int main(int argc, char** argv) &#123; Number n(10); Number n1(15); Number n2=n+n1; cout&lt;&lt;n2.num&lt;&lt;endl; return 0;&#125; 左移运算符重载只能利用全局函数重载左移运算符 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//左移运算符重载&lt;&lt;class Number &#123;// 如果数据私有可以使用友元 public: Number(int n) &#123; this-&gt;num=n; &#125; int num;&#125;;// 全局函数重载&lt;&lt;运算符ostream&amp; operator&lt;&lt;(ostream &amp;cout,Number &amp;n) &#123; cout&lt;&lt;n.num; return cout;&#125;int main(int argc, char** argv) &#123; Number n1(10); cout&lt;&lt;n1&lt;&lt;endl; return 0;&#125; 递增运算符重载前置++运算符重载 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Number &#123; public : Number() &#123; &#125; Number(int num) &#123; this-&gt;num=num; &#125; int num;// 前置++重载 Number&amp; operator++() &#123; ++num; return *this; &#125;&#125;;ostream&amp; operator&lt;&lt;(ostream &amp;cout,Number n) &#123; cout&lt;&lt;n.num; return cout;&#125;int main(int argc, char** argv) &#123; Number n(10); cout&lt;&lt;++(++n)&lt;&lt;endl; cout&lt;&lt;n&lt;&lt;endl; return 0;&#125; 后置++运算符重载 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Number &#123; friend ostream&amp; operator&lt;&lt;(ostream &amp;cout,Number n); public : Number() &#123; &#125; Number(int num) &#123; this-&gt;num=num; &#125;// 前置++重载 Number&amp; operator++() &#123; ++num; return *this; &#125;// 后置 ++重载 Number operator++(int) &#123; Number temp=*this; num++; return temp; &#125; int num;&#125;;ostream&amp; operator&lt;&lt;(ostream &amp;cout,Number n) &#123; cout&lt;&lt;n.num; return cout;&#125;int main(int argc, char** argv) &#123; Number n(10); cout&lt;&lt;n++; return 0;&#125; 赋值运算符重载123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class People &#123; public: People(int age) &#123; p_age=new int(age); &#125; ~People() &#123; if(p_age!=NULL) &#123; delete p_age; p_age=NULL; &#125; &#125;// =运算符重载 People&amp; operator=(People &amp;p) &#123;// 如果自身有内存先释放干净 if(p_age!=NULL) &#123; delete p_age; p_age=NULL; &#125; this-&gt;p_age= new int(*p.p_age); return *this; &#125; int *p_age;&#125;;int main(int argc, char** argv) &#123; People p1(10); People p2(18); p2=p1; cout&lt;&lt;&quot;age:&quot;&lt;&lt;*p2.p_age&lt;&lt;endl; return 0;&#125; 关系运算符重载123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123; public: Person() &#123; &#125; Person(int age) &#123; this-&gt;age=age; &#125;// 关系运算符重载 bool operator==(Person &amp;p) &#123; if(p.age==this-&gt;age) &#123; return true; &#125; else &#123; return false; &#125; &#125; int age;&#125;;ostream&amp; operator&lt;&lt;(ostream &amp;cout,Person &amp;p) &#123; cout&lt;&lt;p.age; return cout;&#125;int main(int argc, char** argv) &#123; Person p(10); Person p1(10); if(p==p1) &#123; cout&lt;&lt;&quot;相等&quot;&lt;&lt;endl; &#125; return 0;&#125; 函数调用运算符重载又称为仿函数，写法很灵活 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Print &#123; public: Print() &#123; &#125; void operator()(string valueString) &#123; cout&lt;&lt;valueString&lt;&lt;endl; &#125;&#125;;int main(int argc, char** argv) &#123; Print print; print(&quot;hello world!&quot;); return 0;&#125; 继承用处：去重，减少冗余 语法:class 派生类：继承方式 父类 三种继承方式：（父类中的私有属性，子类无论哪种继承都访问不到） 公共继承：父类的public和protected属性保持不变，私有属性访问不到 保护继承：父类的public和protected属性变为子类的protected属性，私有属性访问不到 私有继承：父类的public和protected属性变为子类的private属性，私有属性访问不到 父类中所有的非静态成员属性都会被子类继承下去，只是私有属性被编译器隐藏了，所以访问不到 查看对象模型： 1cl /dl reportSingleClassLayout类名 文件名 继承中的构造和析构的顺序析构顺序与构造顺序相反 父类构造-&gt;子类构造-&gt;子类析构-&gt;父类析构 子类继承访问同名成员的处理 访问子类同名成员，直接访问即可 访问父类同名成员，加作用域即可 子类出现和父类同名的成员，子类会隐藏父类所有的同名成员函数 子类继承访问静态成员的处理两种访问方式：对象名和类名 访问子类同名成员，直接访问即可 访问父类同名成员，加作用域即可 子类出现和父类同名的静态成员，子类会隐藏父类所有的同名静态成员函数 多继承（不建议使用） 语法：class 子类：继承方式 父类1，继承方式 父类2 菱形继承概念：两个类继承一个基类，又有一个类继承这两个派生类 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//动物类//通过使用virtual关键字解决菱形继承问题class Animal &#123; public: int age;&#125;;//羊类class Sheep:virtual public Animal &#123;&#125;;//驼类class Tuo:virtual public Animal &#123;&#125;;//羊驼类class SheepTuo:public Sheep,public Tuo &#123;&#125;;int main(int argc, char** argv) &#123; SheepTuo st; st.Tuo::age=28; st.Sheep::age=18; cout&lt;&lt;&quot;st.Sheep::age:&quot;&lt;&lt;st.Sheep::age&lt;&lt;endl; cout&lt;&lt;&quot;st.Tuo::age:&quot;&lt;&lt;st.Tuo::age&lt;&lt;endl; cout&lt;&lt;&quot;st.age:&quot;&lt;&lt;st.age&lt;&lt;endl; return 0;&#125; 多态 静态多态：函数重载和运算符重载，编译阶段确定函数地址，地址早绑定 动态多态：派生类和虚函数，运行阶段确定函数地址，地址晚绑定 虚函数12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Animal &#123; public:// 此刻地址早绑定// void speak() &#123;// cout&lt;&lt;&quot;动物在说话&quot;&lt;&lt;endl;// &#125;// 加virtual变成虚函数地址晚绑定 virtual void speak() &#123; cout&lt;&lt;&quot;动物在说话&quot;&lt;&lt;endl; &#125;&#125;;class Cat:public Animal &#123; public : void speak() &#123; cout&lt;&lt;&quot;喵喵~~&quot;&lt;&lt;endl; &#125;&#125;;class Dog:public Animal &#123; public : void speak() &#123; cout&lt;&lt;&quot;汪汪~~&quot;&lt;&lt;endl; &#125;&#125;;int main(int argc, char** argv) &#123; Cat cat; Dog dog;// Animal &amp;animal=cat; Animal &amp;animal=dog; animal.speak(); return 0;&#125; 纯虚函数和抽象类有纯虚函数的类称为抽象类 语法：virtual 返回值类型 函数名（参数列表）&#x3D;0； 抽象类特点： 无法实例化 子类必须重写抽象类的纯虚函数，否则子类也属于抽象类 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Animal &#123; public:// 变成纯虚函数 virtual void speak()=0;&#125;;class Cat:public Animal &#123; public : void speak() &#123; cout&lt;&lt;&quot;喵喵~~&quot;&lt;&lt;endl; &#125;&#125;;class Dog:public Animal &#123; public : void speak() &#123; cout&lt;&lt;&quot;汪汪~~&quot;&lt;&lt;endl; &#125;&#125;;int main(int argc, char** argv) &#123; Cat cat; Dog dog;// Animal &amp;animal=cat; Animal &amp;animal=dog; animal.speak(); return 0;&#125; 虚析构和纯虚析构有纯虚析构的类也称为抽象类 用处：如果子类属性开辟到堆区，那么父类指针在释放时无法调用子类的析构代码 虚析构语法：virtual ~类名（）{} 纯虚析构：virtual ~类名（）&#x3D;0；必须要有具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Animal &#123; public: Animal() &#123; cout&lt;&lt;&quot;Animal构造函数调用&quot;&lt;&lt;endl; &#125;// 利用虚析构// virtual ~Animal() &#123;// cout&lt;&lt;&quot;Animal析构函数调用&quot;&lt;&lt;endl;// &#125;// 利用纯虚析构 virtual ~Animal()=0;&#125;;class Cat:public Animal &#123; public : Cat() &#123; cout&lt;&lt;&quot;Cat构造函数调用&quot;&lt;&lt;endl; &#125; Cat(string name) &#123; this-&gt;name=new string(name); cout&lt;&lt;&quot;Cat有参构造函数调用&quot;&lt;&lt;endl; &#125; ~Cat() &#123; if(name!=NULL) &#123; delete name; name=NULL; &#125; cout&lt;&lt;&quot;Cat析构函数调用&quot;&lt;&lt;endl; &#125; string *name;&#125;;Animal::~Animal() &#123; cout&lt;&lt;&quot;Animal析构函数调用&quot;&lt;&lt;endl;&#125;int main(int argc, char** argv) &#123; Animal *animal=new Cat(&quot;小白&quot;); delete animal; return 0;&#125; C++泛型编程模板 用途：提高复用性 函数模板语法：template，typename可以用class代替 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//利用模板template &lt;typename T&gt;void Swap(T &amp;a,T &amp;b) &#123; T temp; temp=a; a=b; b=temp;&#125;int main(int argc, char** argv) &#123; int a=10,b=20; float c=10.9,d=10.6; Swap(a,b); cout&lt;&lt;a&lt;&lt;&quot; ,&quot;&lt;&lt;b&lt;&lt;endl; Swap(c,d); cout&lt;&lt;c&lt;&lt;&quot; ,&quot;&lt;&lt;d&lt;&lt;endl; return 0;&#125; 普通函数与模板函数的区别 普通函数可以自动类型转换 函数模板如果使用自动类型，不会发生自动类型转换 函数模板如果使用指定类型，会发生自动类型转换 普通函数与模板函数的调用规则 函数模板和普通函数都可以，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以重载 如果函数模板能更好匹配，优先调用函数模板 模板的局限性对于数组和对象来说，可以使用template&lt;&gt;重写一个模板具体实现 类模板123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;template &lt;class NameType,class AgeType&gt;class People &#123; public: People(NameType name,AgeType age) &#123; this-&gt;name=name; this-&gt;age=age; &#125; NameType name; AgeType age;&#125;;int main(int argc, char** argv) &#123; People&lt;string,int&gt; p(&quot;张三&quot;,18); cout&lt;&lt;p.name&lt;&lt;p.age&lt;&lt;endl; return 0;&#125; 类模板的成员函数的创建时机类模板中成员函数只在调用时才去创建 类模板对象做函数参数传入方式 指定传入方式 参数模板化 整个类模板化 类模板继承 当子类继承父类是一个类模板时，子类在声明时，要指出父类中的数据类型 不指定，编译器无法给子类分配内存 如果要灵活支出父类中的数据类型，子类也要变成类模板 STL 查阅API即可，深入理解阅读《STL源码剖析》 容器String string本质上是一个类，内部封装了char *,是一个char *的容器 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(int argc, char** argv) &#123; string str=&quot;hello&quot;; const char *ch=&quot;china&quot;; string str1(ch); string str2(10,&#x27;a&#x27;); str+=&quot;world&quot;; cout&lt;&lt;str&lt;&lt;&quot; &quot;&lt;&lt;str1&lt;&lt;&quot; &quot;&lt;&lt;str2&lt;&lt;endl; return 0;&#125; Vector 功能：类似数组，又称为单端数组，可以动态扩展（找更大的内存空间，将数据拷贝，释放原空间） vector存放内置数据类型12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void print(int value) &#123; cout&lt;&lt;value&lt;&lt;endl;&#125;int main(int argc, char** argv) &#123;// vector容器，类似于数组 vector&lt;int&gt; v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); vector&lt;int&gt;::iterator itBegin=v.begin();//起始迭代器，指向容器中第一个元素 vector&lt;int&gt;::iterator itEnd=v.end();//结束迭代器，指向容器中最后一个元素的下一个位置 cout&lt;&lt;&quot;while循环遍历&quot;&lt;&lt;endl; while(itBegin!=itEnd) &#123; cout&lt;&lt;*itBegin&lt;&lt;endl; itBegin++; &#125; cout&lt;&lt;&quot;for循环遍历&quot;&lt;&lt;endl; for(vector&lt;int&gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; cout&lt;&lt;&quot;stl遍历算法&quot;&lt;&lt;endl; for_each(v.begin(),v.end(),print); return 0;&#125; vector存放自定义数据类型1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class People &#123; public: People(string name,int age) &#123; this-&gt;age=age; this-&gt;name=name; &#125; string name; int age;&#125;;int main(int argc, char** argv) &#123; People p1(&quot;李白&quot;,2000); People p2(&quot;达摩&quot;,1000); People p3(&quot;王昭君&quot;,900); People p4(&quot;公孙离&quot;,20); People p5(&quot;赵云&quot;,200); vector&lt;People&gt; v; v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); vector&lt;People*&gt; v1; v1.push_back(&amp;p1); v1.push_back(&amp;p2); v1.push_back(&amp;p3); v1.push_back(&amp;p4); v1.push_back(&amp;p5); for(vector&lt;People&gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; cout&lt;&lt;&quot;姓名:&quot;&lt;&lt;it-&gt;name&lt;&lt;&quot; 年龄：&quot;&lt;&lt;it-&gt;age&lt;&lt;endl; &#125; cout&lt;&lt;&quot;遍历自定义数据类型指针&quot;&lt;&lt;endl; for(vector&lt;People*&gt;::iterator it=v1.begin(); it!=v1.end(); it++) &#123; cout&lt;&lt;&quot;姓名:&quot;&lt;&lt;(*it)-&gt;name&lt;&lt;&quot; 年龄：&quot;&lt;&lt;(*it)-&gt;age&lt;&lt;endl; &#125; return 0;&#125; vector容器嵌套123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;//vector容器嵌套int main(int argc, char** argv) &#123; vector&lt;vector&lt;int&gt; &gt; v; vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector&lt;int&gt; v3; vector&lt;int&gt; v4; for(int i=0; i&lt;4; i++) &#123; v1.push_back(i); v2.push_back(i+1); v3.push_back(i+2); v4.push_back(i+3); &#125; v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); for(vector&lt;vector&lt;int&gt; &gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; for(vector&lt;int&gt;::iterator vit=(*it).begin(); vit!=(*it).end(); vit++) &#123; cout&lt;&lt;*vit&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; vector容器插入和删除12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void print(vector&lt;int&gt; &amp;v) &#123; for(vector&lt;int&gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125;&#125;int main(int argc, char** argv) &#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); print(v); v.pop_back(); print(v); v.insert(v.begin(),60); print(v); v.erase(v.begin(),v.end()); print(v); v.clear(); print(v); return 0;&#125; Deque双端数组，可以对头端进行插入和删除 Stack（栈）：没啥可说的Queue（队列）：没啥可说的List注意：list不支持随机存取，所以没有[]和at的访问方式 Set和Multiserset结构会自动排序，底层是二叉树 set中不允许有重复的值 multiset允许有重复的值 Mapmap中所以元素都是pair,底层为二叉树，可以根据key快速找到value map中不允许有重复key值元素 multimap中允许有重复key值元素","categories":[{"name":"C++","slug":"C","permalink":"https://wkcollection.github.io/categories/C/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://wkcollection.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"C++","slug":"C","permalink":"https://wkcollection.github.io/tags/C/"}]}],"categories":[{"name":"C","slug":"C","permalink":"https://wkcollection.github.io/categories/C/"},{"name":"Python","slug":"Python","permalink":"https://wkcollection.github.io/categories/Python/"},{"name":"IDE","slug":"IDE","permalink":"https://wkcollection.github.io/categories/IDE/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://wkcollection.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Node","slug":"Node","permalink":"https://wkcollection.github.io/categories/Node/"},{"name":"Git","slug":"Git","permalink":"https://wkcollection.github.io/categories/Git/"},{"name":"C++","slug":"C","permalink":"https://wkcollection.github.io/categories/C/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://wkcollection.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C","slug":"C","permalink":"https://wkcollection.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://wkcollection.github.io/tags/Python/"},{"name":"IDE","slug":"IDE","permalink":"https://wkcollection.github.io/tags/IDE/"},{"name":"CodeBlocks","slug":"CodeBlocks","permalink":"https://wkcollection.github.io/tags/CodeBlocks/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://wkcollection.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"https://wkcollection.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://wkcollection.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://wkcollection.github.io/tags/Nodejs/"},{"name":"后端","slug":"后端","permalink":"https://wkcollection.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"版本控制","slug":"版本控制","permalink":"https://wkcollection.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"git","slug":"git","permalink":"https://wkcollection.github.io/tags/git/"},{"name":"C++","slug":"C","permalink":"https://wkcollection.github.io/tags/C/"}]}