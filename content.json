{"meta":{"title":"Kang的博客","subtitle":"Learn More,Know More!","description":"Coding Never Stop!","author":"Kang","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-06-19T07:55:46.000Z","updated":"2022-06-19T09:37:35.268Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-06-19T06:17:26.000Z","updated":"2022-06-19T09:37:56.315Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-06-19T09:09:48.000Z","updated":"2022-06-19T09:37:45.387Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Cpp学习","slug":"Cpp","date":"2022-06-19T08:05:43.000Z","updated":"2022-06-19T09:45:21.041Z","comments":true,"path":"2022/06/19/Cpp/","link":"","permalink":"http://example.com/2022/06/19/Cpp/","excerpt":"C++学习","text":"C++学习 数组 方便存放同类型的元素 一维数组一维数组数组名代表数组的首地址 一维数组名可以计算出数组在内存空间所占内存大小 二维数组二维数组名代表二维数组的首地址，也可以查看某行的首地址 二维数组可以计算出数组在内存空间所占内存大小，也可以计算出某行所占内存大小 指针 作用：保存地址 指针的定义：数据类型 *指针变量名 32位操作系统指针所占内存空间：4个字节 64位操作系统指针所占内存空间：8个字节 指针的两大类型空指针： 指针变量指向内存编号为0的空间 空指针指向内存无法访问，0~255内存编号给系统占用的，无法访问 可用于给指针变量初始化 野指针：指针变量指向非法空间，要尽量避免 const与指针结合const修饰指针称为常量指针:指针指向的值不能变，指针的指向可以变 #include &lt;iostream> using namespace std; int main(int argc, char** argv) &#123; // 常量指针：指针指向的值不能变，指针的指向可以变 int a=20; const int *p=&amp;a; int b=30; p=&amp;b;//指针的指向可以改，由指向a修改为指向b // *p=b; 指向的值不能改 cout&lt;&lt;*p&lt;&lt;endl; return 0; &#125; const修饰常量称为指针常量：指针指向的值可以改，指针的指向不可以修改 #include &lt;iostream> using namespace std; int main(int argc, char** argv) &#123; // 指针常量：指针指向的值可以改，指针的指向不可以修改 int a=20; int * const p=&amp;a; int b=30; *p=b; //指向的值可以改 // p=&amp;b;//指针的指向不能改 cout&lt;&lt;*p&lt;&lt;endl; return 0; &#125; const既修饰常量又修饰指针：指针的指向不能改，指针指向的值也不能改 #include &lt;iostream> using namespace std; int main(int argc, char** argv) &#123; // const既修饰常量又修饰指针：指针的指向不能改，指针指向的值也不能改 int a=20; const int * const p=&amp;a; int b=30; // *p=b; //指向的值不可以改 // p=&amp;b;//指针的指向不能改 cout&lt;&lt;*p&lt;&lt;endl; return 0; &#125; 指针与数组#include &lt;iostream> using namespace std; int main(int argc, char** argv) &#123; // 访问数组的第一种方式 int array[10]= &#123;1,2,3,4,5,6,7,8,9,10&#125;; int *p; for(int i=0; i&lt;10; i++) &#123; cout&lt;&lt;array[i]&lt;&lt;endl; &#125; cout&lt;&lt;\"利用指针访问数组元素:\"&lt;&lt;endl; p=array; // 利用指针访问数组元素 for(int i=0; i&lt;10; i++) &#123; cout&lt;&lt;*p&lt;&lt;endl; p++; &#125; return 0; &#125; 指针与函数值传递：不会改变实参的值 地址传递（引用传递）：会改变实参的值 #include &lt;iostream> using namespace std; void swap(int a,int b); void swap2(int *a,int *b); int main(int argc, char** argv) &#123; // 指针函数 // 值传递:不改变实参的值 int a=10,b=20; cout&lt;&lt;\"交换前:a:\"&lt;&lt;a&lt;&lt;\" b:\"&lt;&lt;b&lt;&lt;endl; swap(a,b); cout&lt;&lt;\"交换后:a:\"&lt;&lt;a&lt;&lt;\" b:\"&lt;&lt;b&lt;&lt;endl; // 引用传递：改变实参的值 cout&lt;&lt;\"交换前:a:\"&lt;&lt;a&lt;&lt;\" b:\"&lt;&lt;b&lt;&lt;endl; swap2(&amp;a,&amp;b); cout&lt;&lt;\"交换后:a:\"&lt;&lt;a&lt;&lt;\" b:\"&lt;&lt;b&lt;&lt;endl; return 0; &#125; void swap(int a,int b) &#123; int temp; temp=a; a=b; b=temp; &#125; void swap2(int *a,int *b) &#123; int temp; temp=*a; *a=*b; *b=temp; &#125; 结构体 属于用户自定义的数据类型 结构体定义语法：struct 结构体名 {结构体成员列表}； #include &lt;iostream> #include &lt;string> using namespace std; struct people &#123; string name; int age; int sex; &#125; p3; void display(people p); int main(int argc, char** argv) &#123; // 1. struct 结构体名 变量名； struct people p1; p1.name=\"张三\"; p1.age=20; p1.sex=0; display(p1); // 2. struct 结构体名 变量名=&#123;值1，值2&#125;； struct people p2= &#123;\"李四\",22,1&#125;; display(p2); // 3. 定义结构体时顺便创建变量； p3.name=\"王五\"; p3.age=26; p3.sex=3; display(p3); return 0; &#125; void display(people p) &#123; cout&lt;&lt;\"name:\"&lt;&lt;p.name&lt;&lt;\" age:\"&lt;&lt;p.age&lt;&lt;\" sex:\"&lt;&lt;p.sex&lt;&lt;endl; &#125; 结构体数组#include &lt;iostream> #include &lt;string> using namespace std; struct people &#123; string name; int age; &#125;; int main(int argc, char** argv) &#123; // 结构体数组定义 people ps[2]= &#123; &#123;\"刘邦\",200&#125;, &#123;\"周瑜\",2000&#125; &#125;; // 结构体遍历 for(int i=0; i&lt;2; i++) &#123; cout&lt;&lt;\"name:\"&lt;&lt;ps[i].name&lt;&lt;\" age:\"&lt;&lt;ps[i].age&lt;&lt;endl; &#125; return 0; &#125; 结构体指针作用：通过指针访问结构体中的成员 结构体变量通过.操作符访问，结构体指针通过-&gt;访问结构体成员 #include &lt;iostream> #include &lt;string> using namespace std; struct people &#123; string name; int age; &#125;; int main(int argc, char** argv) &#123; people p1= &#123;\"张三\",100&#125;; people *p=&amp;p1; // 利用结构体指针进行访问 cout&lt;&lt;\"name:\"&lt;&lt;p->name&lt;&lt;\" age:\"&lt;&lt;p->age&lt;&lt;endl; return 0; &#125; 内存四区代码区用途：存放函数体的二进制代码，由操作系统进行管理 代码区是共享的，共享是针对需要频繁执行的程序，只需要在内存中有一份代码即可 代码区是只读的，只读为了防止程序意外修改了指令 栈区用途：有编译器自动分配释放，存放函数的参数值、局部变量等 堆区用途：由程序员分配和释放，若程序员不分配释放，程序结束时由操作系统回收 使用new关键字进行内存申请，使用delete关键字进行内存释放，数组需要使用delete[]进行释放 全局区用途：存放全局变量、静态变量以及常量 包含常量区、字符串常量和其他常量 包括全局变量、全局常量、静态变量和字符串常量 #include &lt;iostream> using namespace std; // 全局变量 int g=10; int h=10; // 全局常量 const int i=10; const int j=10; int main(int argc, char** argv) &#123; // 局部变量 int a=10; int b=10; cout&lt;&lt;\"&amp;a=\"&lt;&lt;(int *)&amp;a&lt;&lt;\" &amp;b=\"&lt;&lt;(int *)&amp;b&lt;&lt;endl; // 局部常量 const int c=20; const int d=20; cout&lt;&lt;\"&amp;c=\"&lt;&lt;(int *)&amp;c&lt;&lt;\" &amp;d=\"&lt;&lt;(int *)&amp;d&lt;&lt;endl; // 静态变量 static int e=10; static int f=10; cout&lt;&lt;\"&amp;e=\"&lt;&lt;(int *)&amp;e&lt;&lt;\" &amp;f=\"&lt;&lt;(int *)&amp;f&lt;&lt;endl; cout&lt;&lt;\"&amp;g=\"&lt;&lt;(int *)&amp;g&lt;&lt;\" &amp;h=\"&lt;&lt;(int *)&amp;h&lt;&lt;endl; cout&lt;&lt;\"&amp;i=\"&lt;&lt;(int *)&amp;i&lt;&lt;\" &amp;j=\"&lt;&lt;(int *)&amp;j&lt;&lt;endl; // 字符串常量 cout&lt;&lt;\"&amp;str=\"&lt;&lt;(int *)&amp;\"hello world\"&lt;&lt;endl; return 0; &#125; C++特点引用 给内存地址取别名，本质是指针常量 基本语法：数据类型 &amp;别名&#x3D;原名 注意事项：引用必须初始化，一旦初始化不可更改 引用做函数参数：可以简化指针修改实参 引用做函数返回值：可以作为函数左值，但是不要返回局部变量的引用 常引用：可以防止形参改变实参，即变为只读状态 函数进阶函数默认参数：返回值类型 函数名（参数&#x3D;默认值）{}，如果某个参数有默认值那么从这个默认值开始从左向右都得有默认值；函数声明有默认值，那么实现就不能有默认值。 函数的占位参数：调用时必须传递实参。 函数重载：同一个作用域，函数名称相同，函数的参数类型不同或者个数不同或者顺序不同；返回值不作为函数重载的条件。 面向对象封装ex:设计圆类，通过半径求周长 #include &lt;iostream> #define PI 3.14 using namespace std; class Circle &#123; public : //半径 float radius; float calc() &#123; return 2*PI*radius; &#125; &#125;; int main(int argc, char** argv) &#123; Circle c; c.radius=10; cout&lt;&lt;\"圆的周长为：\"&lt;&lt;c.calc()&lt;&lt;endl; return 0; &#125; 访问权限： 权限类型 类内 类外 public 允许 允许 protected 允许 不允许 private 允许 不允许 对于protected儿子可以访问父亲的保护内容 对于private儿子不可以访问父亲的保护内容 对象特性 空对象占用1bit的内存空间，编译器会给每个空对象也分配一个字节，是为了区分空对象的位置 构造函数和析构函数不提供构造函数和析构函数，编译器会默认提供空实现的构造函数和析构函数。 构造函数（进行初始化操作）：类名（）{} 构造函数的分类： 有参构造和无参构造 普通构造和拷贝构造 调用方法： 括号法：调用无参构造函数时别带小括号，否则编译器会认为是函数的声明 显示法：不能用拷贝构造函数初始化匿名对象，编译器会默认忽视小括号，从而造成重定义 隐式法 调用规则： 如果用户自定义有参构造函数，C++就不再提供默认无参构造函数，但是会提供默认拷贝构造函数 如果用户自定义拷贝构造函数，C++不在提供其他构造函数 析构函数（进行销毁操作）：~类名（）{} #include &lt;iostream> #include &lt;string> using namespace std; class Man &#123; public: Man() &#123; cout&lt;&lt;\"无参构造函数调用\"&lt;&lt;endl; &#125; Man(string name) &#123; this->name=name; cout&lt;&lt;\"有参构造函数调用\"&lt;&lt;endl; &#125; Man(const Man &amp;m) &#123; this->name=m.name; this->age=m.age; cout&lt;&lt;\"拷贝构造函数调用\"&lt;&lt;endl; &#125; ~Man() &#123; cout&lt;&lt;\"析构函数调用\"&lt;&lt;endl; &#125; private: string name; int age; &#125;; int main(int argc, char** argv) &#123; /** 调用方式: 括号法 显示法 隐式法 */ // 方式一:括号法 Man m; Man m1(\"张三\"); Man m2(m1); /*注意：调用无参构造函数时别带小括号，这一点可Java有所不同， 同时使用this->而不是this.*/ // 方式二：显示法 Man m3=Man(); Man m4=Man(\"李四\"); Man m5=Man(m4); // 匿名对象 Man(\"赵四\"); /*不能用拷贝构造函数初始化匿名对象 Man(m5)==Man m5,编译器会忽略小括号 */ // 方式三：隐式法 Man m6=m5; return 0; &#125; 拷贝构造函数的作用： 使用一个已经创建完毕的对象来初始化新对象 值传递的方式传参 值方式返回局部对象 #include &lt;iostream> #include &lt;string> using namespace std; class People &#123; public: People() &#123; cout&lt;&lt;\"默认构造函数调用\"&lt;&lt;endl; &#125; People(string name,int age) &#123; this->name=name; this->age=age; cout&lt;&lt;\"有参构造函数调用\"&lt;&lt;endl; &#125; People(const People &amp;p) &#123; this->name=p.name; this->age=p.age; cout&lt;&lt;\"拷贝构造函数调用\"&lt;&lt;endl; &#125; string name; int age; &#125;; void test(People p) &#123; &#125; People test1() &#123; People p(\"王五\",10); return p; &#125; int main(int argc, char** argv) &#123; // 方式一：用一个已经创建好的对象来初始化新对象 // People p(\"张三\",18); // People p1(p); // 方式二：用于函数传参 // test(p); // 方式三：用于返回局部对象 People p1=test1(); cout&lt;&lt;\"name:\"&lt;&lt;p1.name&lt;&lt;\" age:\"&lt;&lt;p1.age&lt;&lt;endl; return 0; &#125; 深拷贝与浅拷贝浅拷贝：简单的赋值操作，会导致内存重复释放 深拷贝：在堆区重新申请空间，进行拷贝操作 #include &lt;iostream> #include &lt;string> using namespace std; class People &#123; public: People() &#123; cout&lt;&lt;\"无参构造函数\"&lt;&lt;endl; &#125; People(string name,int age,int height) &#123; this->name=name; this->age=age; this->height=new int(height); cout&lt;&lt;\"有参构造函数\"&lt;&lt;endl; &#125; People(const People &amp;p) &#123; this->name=p.name; this->age=p.age; // this->height=p.height;//为了解决浅拷贝所带来的内存重复释放的问题，在拷贝时主动向堆区申请一块内存空间 this->height=new int(*p.height);//此语句解决浅拷贝所带的问题 cout&lt;&lt;\"拷贝构造函数\"&lt;&lt;endl; &#125; ~People() &#123; if(height!=NULL) &#123; delete height; height=NULL; &#125; cout&lt;&lt;\"析构函数调用\"&lt;&lt;endl; &#125; string name;//姓名 int age;//年龄 int *height;//身高 &#125;; int main(int argc, char** argv) &#123; People p(\"张胜男\",18,170); cout&lt;&lt;\"name:\"&lt;&lt;p.name&lt;&lt;\" age:\"&lt;&lt;p.age&lt;&lt;\" height:\"&lt;&lt;*p.height&lt;&lt;endl; People p1(p); cout&lt;&lt;\"name:\"&lt;&lt;p1.name&lt;&lt;\" age:\"&lt;&lt;p1.age&lt;&lt;\" height:\"&lt;&lt;*p1.height&lt;&lt;endl; return 0; &#125; 初始化列表#include &lt;iostream> using namespace std; class People&#123; public: People(int age,int sex):age(age),sex(sex)&#123; &#125; int age; int sex; &#125;; int main(int argc, char** argv) &#123; People p(18,0); return 0; &#125; 静态成员 静态成员变量 所有对象共享一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数：可以通过对象或类名访问 所有对象共享同一个函数 静态成员函数只能访问静态成员变量，不能访问非静态成员变量 #include &lt;iostream> using namespace std; class People &#123; public: People() &#123; &#125; People(int age) &#123; this->age=age; &#125; int age; static int sex; static void func() &#123; cout&lt;&lt;\"性别是:\"&lt;&lt;sex&lt;&lt;endl; &#125; &#125;; // 类外初始化 int People::sex=1; int main(int argc, char** argv) &#123; // 方式一：对象名 People p(10); p.func(); // 方式二：类名 People::func(); return 0; &#125; this指针与空指针this的用途：解决命名冲突和制造链式调用 空指针也能访问成员函数，需要加以判断保证代码的健壮性 常函数和常对象 常函数内不可以修改成员属性 成员属性加mutable后就可以修改属性 常对象只能调用常函数 #include &lt;iostream> using namespace std; class People &#123; public: People(int age,int sex) &#123; this->age=age; this-sex=sex; &#125; // 常函数 ，加const后实际上修饰的是this，则this指向的内容也不可以改 void print() const &#123; cout&lt;&lt;\"age:\"&lt;&lt;age&lt;&lt;\" sex:\"&lt;&lt;sex&lt;&lt;endl; &#125; int age; int sex; &#125;; int main(int argc, char** argv) &#123; return 0; &#125; 友元全局函数做友元#include &lt;iostream> #include &lt;string> using namespace std; class People &#123; // 告诉编译器goodBrother是People的友元函数，可以访问People的private变量 friend void goodBrother(People &amp;p); public: People() &#123; this->sitroom=\"客厅\"; this->bedroom=\"卧室\"; &#125; public: string sitroom; private: string bedroom; &#125;; void goodBrother(People &amp;p) &#123; cout&lt;&lt;\"好兄弟正在进入你的\"&lt;&lt;p.sitroom&lt;&lt;endl; cout&lt;&lt;\"好兄弟正在进入你的\"&lt;&lt;p.bedroom&lt;&lt;endl; &#125; int main(int argc, char** argv) &#123; People p; goodBrother(p); return 0; &#125; 友元类#include &lt;iostream> #include &lt;string> using namespace std; class Brother &#123; // 声明People是Brother的友元类 friend class People; public: Brother() &#123; wc=\"厕所\"; bathroom=\"浴室\"; &#125; string wc; private: string bathroom; &#125;; class People &#123; public: People() &#123; sittingroom=\"客厅\"; bedroom=\"卧室\"; &#125; string sittingroom; void visit(Brother &amp;b) &#123; cout&lt;&lt;\"正在访问好兄弟的\"&lt;&lt;b.bathroom&lt;&lt;endl; &#125; private: string bedroom; &#125;; int main(int argc, char** argv) &#123; Brother b; People p; p.visit(b); return 0; &#125; 成员函数做友元#include&lt;iostream> using namespace std; #include&lt;string> //成员函数做友元 class Building; class GoodGay &#123; public: GoodGay(); ~GoodGay(); void visit();// 让 visit 访问Building中的私有函数 void visit2();// 让 visit2 不可以访问Building中的私有函数 Building *building;//指向对象的指针，在构造函数中要初始化指针 &#125;; class Building &#123; //GoodGay类下的visit成员函数作为本类的好朋友，可以访问私有成员变量 friend void GoodGay::visit(); public: string m_SittingRoom; Building(); private: string m_BedRoom; &#125;; Building::Building() &#123; m_SittingRoom = \"客厅\"; m_BedRoom = \"卧室\"; &#125; GoodGay::GoodGay() &#123; //创建一个建筑物的对象 //用new再堆区中申请一片空间返回的是一个指针，用building来接受这个指针，完成building初始化 building = new Building; &#125; GoodGay::~GoodGay() &#123; delete building; &#125; void GoodGay::visit() &#123; cout &lt;&lt; \"visit函数: Public \" &lt;&lt; building->m_SittingRoom &lt;&lt; endl; cout &lt;&lt; \"visit函数: Private \" &lt;&lt; building->m_BedRoom &lt;&lt; endl; &#125; void GoodGay::visit2() &#123; cout &lt;&lt; \"visit2函数: Public \" &lt;&lt; building->m_SittingRoom &lt;&lt; endl; //visit2函数不是Building的友元函数，不能访问其私有变量m_BedRoom &#125; void test01() &#123; GoodGay gg; gg.visit(); gg.visit2(); &#125; int main() &#123; test01(); return 0; &#125; 运算符重载加号运算符重载成员函数重载+运算符和全局函数重载+运算符 #include &lt;iostream> #include &lt;string> using namespace std; // 加号运算符重载 class Number &#123; public: Number() &#123; &#125; Number(int n) &#123; this->num=n; &#125; // 成员函数重载+ // Number operator+(Number &amp;n) &#123; // Number temp; // temp.num=this->num+n.num; // return temp; // &#125; int num; &#125;; // 全局函数重载+ Number operator+(Number &amp;n1,Number &amp;n2) &#123; Number n3; n3.num= n1.num+n2.num; return n3; &#125; int main(int argc, char** argv) &#123; Number n(10); Number n1(15); Number n2=n+n1; cout&lt;&lt;n2.num&lt;&lt;endl; return 0; &#125; 左移运算符重载只能利用全局函数重载左移运算符 #include &lt;iostream> #include &lt;string> using namespace std; //左移运算符重载&lt;&lt; class Number &#123; // 如果数据私有可以使用友元 public: Number(int n) &#123; this->num=n; &#125; int num; &#125;; // 全局函数重载&lt;&lt;运算符 ostream&amp; operator&lt;&lt;(ostream &amp;cout,Number &amp;n) &#123; cout&lt;&lt;n.num; return cout; &#125; int main(int argc, char** argv) &#123; Number n1(10); cout&lt;&lt;n1&lt;&lt;endl; return 0; &#125; 递增运算符重载前置++运算符重载 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Number &#123; public : Number() &#123; &#125; Number(int num) &#123; this-&gt;num&#x3D;num; &#125; int num; &#x2F;&#x2F; 前置++重载 Number&amp; operator++() &#123; ++num; return *this; &#125; &#125;; ostream&amp; operator&lt;&lt;(ostream &amp;cout,Number n) &#123; cout&lt;&lt;n.num; return cout; &#125; int main(int argc, char** argv) &#123; Number n(10); cout&lt;&lt;++(++n)&lt;&lt;endl; cout&lt;&lt;n&lt;&lt;endl; return 0; &#125; 后置++运算符重载 #include &lt;iostream> #include &lt;string> using namespace std; class Number &#123; friend ostream&amp; operator&lt;&lt;(ostream &amp;cout,Number n); public : Number() &#123; &#125; Number(int num) &#123; this->num=num; &#125; // 前置++重载 Number&amp; operator++() &#123; ++num; return *this; &#125; // 后置 ++重载 Number operator++(int) &#123; Number temp=*this; num++; return temp; &#125; int num; &#125;; ostream&amp; operator&lt;&lt;(ostream &amp;cout,Number n) &#123; cout&lt;&lt;n.num; return cout; &#125; int main(int argc, char** argv) &#123; Number n(10); cout&lt;&lt;n++; return 0; &#125; 赋值运算符重载#include &lt;iostream> #include &lt;string> using namespace std; class People &#123; public: People(int age) &#123; p_age=new int(age); &#125; ~People() &#123; if(p_age!=NULL) &#123; delete p_age; p_age=NULL; &#125; &#125; // =运算符重载 People&amp; operator=(People &amp;p) &#123; // 如果自身有内存先释放干净 if(p_age!=NULL) &#123; delete p_age; p_age=NULL; &#125; this->p_age= new int(*p.p_age); return *this; &#125; int *p_age; &#125;; int main(int argc, char** argv) &#123; People p1(10); People p2(18); p2=p1; cout&lt;&lt;\"age:\"&lt;&lt;*p2.p_age&lt;&lt;endl; return 0; &#125; 关系运算符重载#include &lt;iostream> #include &lt;string> using namespace std; class Person &#123; public: Person() &#123; &#125; Person(int age) &#123; this->age=age; &#125; // 关系运算符重载 bool operator==(Person &amp;p) &#123; if(p.age==this->age) &#123; return true; &#125; else &#123; return false; &#125; &#125; int age; &#125;; ostream&amp; operator&lt;&lt;(ostream &amp;cout,Person &amp;p) &#123; cout&lt;&lt;p.age; return cout; &#125; int main(int argc, char** argv) &#123; Person p(10); Person p1(10); if(p==p1) &#123; cout&lt;&lt;\"相等\"&lt;&lt;endl; &#125; return 0; &#125; 函数调用运算符重载又称为仿函数，写法很灵活 #include &lt;iostream> #include &lt;string> using namespace std; class Print &#123; public: Print() &#123; &#125; void operator()(string valueString) &#123; cout&lt;&lt;valueString&lt;&lt;endl; &#125; &#125;; int main(int argc, char** argv) &#123; Print print; print(\"hello world!\"); return 0; &#125; 继承用处：去重，减少冗余 语法:class 派生类：继承方式 父类 三种继承方式：（父类中的私有属性，子类无论哪种继承都访问不到） 公共继承：父类的public和protected属性保持不变，私有属性访问不到 保护继承：父类的public和protected属性变为子类的protected属性，私有属性访问不到 私有继承：父类的public和protected属性变为子类的private属性，私有属性访问不到 父类中所有的非静态成员属性都会被子类继承下去，只是私有属性被编译器隐藏了，所以访问不到 查看对象模型： cl /dl reportSingleClassLayout类名 文件名 继承中的构造和析构的顺序析构顺序与构造顺序相反 父类构造-&gt;子类构造-&gt;子类析构-&gt;父类析构 子类继承访问同名成员的处理 访问子类同名成员，直接访问即可 访问父类同名成员，加作用域即可 子类出现和父类同名的成员，子类会隐藏父类所有的同名成员函数 子类继承访问静态成员的处理两种访问方式：对象名和类名 访问子类同名成员，直接访问即可 访问父类同名成员，加作用域即可 子类出现和父类同名的静态成员，子类会隐藏父类所有的同名静态成员函数 多继承（不建议使用） 语法：class 子类：继承方式 父类1，继承方式 父类2 菱形继承概念：两个类继承一个基类，又有一个类继承这两个派生类 #include &lt;iostream> #include &lt;string> using namespace std; //动物类 //通过使用virtual关键字解决菱形继承问题 class Animal &#123; public: int age; &#125;; //羊类 class Sheep:virtual public Animal &#123; &#125;; //驼类 class Tuo:virtual public Animal &#123; &#125;; //羊驼类 class SheepTuo:public Sheep,public Tuo &#123; &#125;; int main(int argc, char** argv) &#123; SheepTuo st; st.Tuo::age=28; st.Sheep::age=18; cout&lt;&lt;\"st.Sheep::age:\"&lt;&lt;st.Sheep::age&lt;&lt;endl; cout&lt;&lt;\"st.Tuo::age:\"&lt;&lt;st.Tuo::age&lt;&lt;endl; cout&lt;&lt;\"st.age:\"&lt;&lt;st.age&lt;&lt;endl; return 0; &#125; 多态 静态多态：函数重载和运算符重载，编译阶段确定函数地址，地址早绑定 动态多态：派生类和虚函数，运行阶段确定函数地址，地址晚绑定 虚函数#include &lt;iostream> #include &lt;string> using namespace std; class Animal &#123; public: // 此刻地址早绑定 // void speak() &#123; // cout&lt;&lt;\"动物在说话\"&lt;&lt;endl; // &#125; // 加virtual变成虚函数地址晚绑定 virtual void speak() &#123; cout&lt;&lt;\"动物在说话\"&lt;&lt;endl; &#125; &#125;; class Cat:public Animal &#123; public : void speak() &#123; cout&lt;&lt;\"喵喵~~\"&lt;&lt;endl; &#125; &#125;; class Dog:public Animal &#123; public : void speak() &#123; cout&lt;&lt;\"汪汪~~\"&lt;&lt;endl; &#125; &#125;; int main(int argc, char** argv) &#123; Cat cat; Dog dog; // Animal &amp;animal=cat; Animal &amp;animal=dog; animal.speak(); return 0; &#125; 纯虚函数和抽象类有纯虚函数的类称为抽象类 语法：virtual 返回值类型 函数名（参数列表）&#x3D;0； 抽象类特点： 无法实例化 子类必须重写抽象类的纯虚函数，否则子类也属于抽象类 #include &lt;iostream> #include &lt;string> using namespace std; class Animal &#123; public: // 变成纯虚函数 virtual void speak()=0; &#125;; class Cat:public Animal &#123; public : void speak() &#123; cout&lt;&lt;\"喵喵~~\"&lt;&lt;endl; &#125; &#125;; class Dog:public Animal &#123; public : void speak() &#123; cout&lt;&lt;\"汪汪~~\"&lt;&lt;endl; &#125; &#125;; int main(int argc, char** argv) &#123; Cat cat; Dog dog; // Animal &amp;animal=cat; Animal &amp;animal=dog; animal.speak(); return 0; &#125; 虚析构和纯虚析构有纯虚析构的类也称为抽象类 用处：如果子类属性开辟到堆区，那么父类指针在释放时无法调用子类的析构代码 虚析构语法：virtual ~类名（）{} 纯虚析构：virtual ~类名（）&#x3D;0；必须要有具体实现 #include &lt;iostream> #include &lt;string> using namespace std; class Animal &#123; public: Animal() &#123; cout&lt;&lt;\"Animal构造函数调用\"&lt;&lt;endl; &#125; // 利用虚析构 // virtual ~Animal() &#123; // cout&lt;&lt;\"Animal析构函数调用\"&lt;&lt;endl; // &#125; // 利用纯虚析构 virtual ~Animal()=0; &#125;; class Cat:public Animal &#123; public : Cat() &#123; cout&lt;&lt;\"Cat构造函数调用\"&lt;&lt;endl; &#125; Cat(string name) &#123; this->name=new string(name); cout&lt;&lt;\"Cat有参构造函数调用\"&lt;&lt;endl; &#125; ~Cat() &#123; if(name!=NULL) &#123; delete name; name=NULL; &#125; cout&lt;&lt;\"Cat析构函数调用\"&lt;&lt;endl; &#125; string *name; &#125;; Animal::~Animal() &#123; cout&lt;&lt;\"Animal析构函数调用\"&lt;&lt;endl; &#125; int main(int argc, char** argv) &#123; Animal *animal=new Cat(\"小白\"); delete animal; return 0; &#125; C++泛型编程模板 用途：提高复用性 函数模板语法：template，typename可以用class代替 #include &lt;iostream> #include &lt;string> using namespace std; //利用模板 template &lt;typename T> void Swap(T &amp;a,T &amp;b) &#123; T temp; temp=a; a=b; b=temp; &#125; int main(int argc, char** argv) &#123; int a=10,b=20; float c=10.9,d=10.6; Swap(a,b); cout&lt;&lt;a&lt;&lt;\" ,\"&lt;&lt;b&lt;&lt;endl; Swap(c,d); cout&lt;&lt;c&lt;&lt;\" ,\"&lt;&lt;d&lt;&lt;endl; return 0; &#125; 普通函数与模板函数的区别 普通函数可以自动类型转换 函数模板如果使用自动类型，不会发生自动类型转换 函数模板如果使用指定类型，会发生自动类型转换 普通函数与模板函数的调用规则 函数模板和普通函数都可以，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以重载 如果函数模板能更好匹配，优先调用函数模板 模板的局限性对于数组和对象来说，可以使用template&lt;&gt;重写一个模板具体实现 类模板#include &lt;iostream> #include &lt;string> using namespace std; template &lt;class NameType,class AgeType> class People &#123; public: People(NameType name,AgeType age) &#123; this->name=name; this->age=age; &#125; NameType name; AgeType age; &#125;; int main(int argc, char** argv) &#123; People&lt;string,int> p(\"张三\",18); cout&lt;&lt;p.name&lt;&lt;p.age&lt;&lt;endl; return 0; &#125; 类模板的成员函数的创建时机类模板中成员函数只在调用时才去创建 类模板对象做函数参数传入方式 指定传入方式 参数模板化 整个类模板化 类模板继承 当子类继承父类是一个类模板时，子类在声明时，要指出父类中的数据类型 不指定，编译器无法给子类分配内存 如果要灵活支出父类中的数据类型，子类也要变成类模板 STL 查阅API即可，深入理解阅读《STL源码剖析》 容器String string本质上是一个类，内部封装了char *,是一个char *的容器 #include &lt;iostream> #include &lt;string> using namespace std; int main(int argc, char** argv) &#123; string str=\"hello\"; const char *ch=\"china\"; string str1(ch); string str2(10,'a'); str+=\"world\"; cout&lt;&lt;str&lt;&lt;\" \"&lt;&lt;str1&lt;&lt;\" \"&lt;&lt;str2&lt;&lt;endl; return 0; &#125; Vector 功能：类似数组，又称为单端数组，可以动态扩展（找更大的内存空间，将数据拷贝，释放原空间） vector存放内置数据类型#include &lt;iostream> #include &lt;string> #include &lt;vector> #include &lt;algorithm> using namespace std; void print(int value) &#123; cout&lt;&lt;value&lt;&lt;endl; &#125; int main(int argc, char** argv) &#123; // vector容器，类似于数组 vector&lt;int> v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); vector&lt;int>::iterator itBegin=v.begin();//起始迭代器，指向容器中第一个元素 vector&lt;int>::iterator itEnd=v.end();//结束迭代器，指向容器中最后一个元素的下一个位置 cout&lt;&lt;\"while循环遍历\"&lt;&lt;endl; while(itBegin!=itEnd) &#123; cout&lt;&lt;*itBegin&lt;&lt;endl; itBegin++; &#125; cout&lt;&lt;\"for循环遍历\"&lt;&lt;endl; for(vector&lt;int>::iterator it=v.begin(); it!=v.end(); it++) &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; cout&lt;&lt;\"stl遍历算法\"&lt;&lt;endl; for_each(v.begin(),v.end(),print); return 0; &#125; vector存放自定义数据类型#include &lt;iostream> #include &lt;string> #include &lt;vector> #include &lt;algorithm> using namespace std; class People &#123; public: People(string name,int age) &#123; this->age=age; this->name=name; &#125; string name; int age; &#125;; int main(int argc, char** argv) &#123; People p1(\"李白\",2000); People p2(\"达摩\",1000); People p3(\"王昭君\",900); People p4(\"公孙离\",20); People p5(\"赵云\",200); vector&lt;People> v; v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); vector&lt;People*> v1; v1.push_back(&amp;p1); v1.push_back(&amp;p2); v1.push_back(&amp;p3); v1.push_back(&amp;p4); v1.push_back(&amp;p5); for(vector&lt;People>::iterator it=v.begin(); it!=v.end(); it++) &#123; cout&lt;&lt;\"姓名:\"&lt;&lt;it->name&lt;&lt;\" 年龄：\"&lt;&lt;it->age&lt;&lt;endl; &#125; cout&lt;&lt;\"遍历自定义数据类型指针\"&lt;&lt;endl; for(vector&lt;People*>::iterator it=v1.begin(); it!=v1.end(); it++) &#123; cout&lt;&lt;\"姓名:\"&lt;&lt;(*it)->name&lt;&lt;\" 年龄：\"&lt;&lt;(*it)->age&lt;&lt;endl; &#125; return 0; &#125; vector容器嵌套#include &lt;iostream> #include &lt;string> #include &lt;vector> #include &lt;algorithm> using namespace std; //vector容器嵌套 int main(int argc, char** argv) &#123; vector&lt;vector&lt;int> > v; vector&lt;int> v1; vector&lt;int> v2; vector&lt;int> v3; vector&lt;int> v4; for(int i=0; i&lt;4; i++) &#123; v1.push_back(i); v2.push_back(i+1); v3.push_back(i+2); v4.push_back(i+3); &#125; v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); for(vector&lt;vector&lt;int> >::iterator it=v.begin(); it!=v.end(); it++) &#123; for(vector&lt;int>::iterator vit=(*it).begin(); vit!=(*it).end(); vit++) &#123; cout&lt;&lt;*vit&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125; return 0; &#125; vector容器插入和删除#include &lt;iostream> #include &lt;string> #include &lt;vector> #include &lt;algorithm> using namespace std; void print(vector&lt;int> &amp;v) &#123; for(vector&lt;int>::iterator it=v.begin(); it!=v.end(); it++) &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; &#125; int main(int argc, char** argv) &#123; vector&lt;int> v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); print(v); v.pop_back(); print(v); v.insert(v.begin(),60); print(v); v.erase(v.begin(),v.end()); print(v); v.clear(); print(v); return 0; &#125; Deque双端数组，可以对头端进行插入和删除 Stack（栈）：没啥可说的Queue（队列）：没啥可说的List注意：list不支持随机存取，所以没有[]和at的访问方式 Set和Multiserset结构会自动排序，底层是二叉树 set中不允许有重复的值 multiset允许有重复的值 Mapmap中所以元素都是pair,底层为二叉树，可以根据key快速找到value map中不允许有重复key值元素 multimap中允许有重复key值元素","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]}],"categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]}