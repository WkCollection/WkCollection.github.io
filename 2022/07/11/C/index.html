<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-flash.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"wkcollection.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"manual"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C语言突破 C和C++语言相关知识点深入理解  C和Cpp C语言相关知识点深入理解  第一关：C和指针宽字符常量如果一个多字节字符常量前面带有一个L，那么他就是宽字符常量。例如：L‘X’ 枚举类型枚举类型的实质是以整型形式进行存储的，符号名其实都是整型值。如果某个符号未显式复制那个他的值就比前面的一个符号名的值大1。第一个未命名的初始化为0。 浮点类型浮点数在缺省情况下都是double类型的，加">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言突破">
<meta property="og:url" content="https://wkcollection.github.io/2022/07/11/C/index.html">
<meta property="og:site_name" content="编程の路">
<meta property="og:description" content="C语言突破 C和C++语言相关知识点深入理解  C和Cpp C语言相关知识点深入理解  第一关：C和指针宽字符常量如果一个多字节字符常量前面带有一个L，那么他就是宽字符常量。例如：L‘X’ 枚举类型枚举类型的实质是以整型形式进行存储的，符号名其实都是整型值。如果某个符号未显式复制那个他的值就比前面的一个符号名的值大1。第一个未命名的初始化为0。 浮点类型浮点数在缺省情况下都是double类型的，加">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-11T13:49:56.000Z">
<meta property="article:modified_time" content="2022-08-10T06:12:21.459Z">
<meta property="article:author" content="BlueHole">
<meta property="article:tag" content="编程语言">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wkcollection.github.io/2022/07/11/C/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://wkcollection.github.io/2022/07/11/C/","path":"2022/07/11/C/","title":"C语言突破"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C语言突破 | 编程の路</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">编程の路</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Coding成神之路!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">8</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">13</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E7%AA%81%E7%A0%B4"><span class="nav-number">1.</span> <span class="nav-text">C语言突破</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E5%92%8CCpp"><span class="nav-number">2.</span> <span class="nav-text">C和Cpp</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E5%85%B3%EF%BC%9AC%E5%92%8C%E6%8C%87%E9%92%88"><span class="nav-number">2.1.</span> <span class="nav-text">第一关：C和指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%BD%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F"><span class="nav-number">2.1.1.</span> <span class="nav-text">宽字符常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text">枚举类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.3.</span> <span class="nav-text">浮点类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="nav-number">2.1.4.</span> <span class="nav-text">字符串常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%B8%B8%E9%87%8F"><span class="nav-number">2.1.5.</span> <span class="nav-text">指针与常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.1.6.</span> <span class="nav-text">作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">代码块作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.1.6.2.</span> <span class="nav-text">文件作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.1.6.3.</span> <span class="nav-text">原型作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.1.6.4.</span> <span class="nav-text">函数作用域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7"><span class="nav-number">2.1.7.</span> <span class="nav-text">链接属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#external%EF%BC%9A%E6%97%A0%E8%AE%BA%E8%A2%AB%E5%A3%B0%E6%98%8E%E5%A4%9A%E5%B0%91%E6%AC%A1%EF%BC%8C%E4%BD%8D%E4%BA%8E%E4%B8%8D%E5%90%8C%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E9%83%BD%E8%A1%A8%E7%A4%BA%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93"><span class="nav-number">2.1.7.0.1.</span> <span class="nav-text">external：无论被声明多少次，位于不同源文件的都表示同一个实体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#internal%EF%BC%9A%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E5%A3%B0%E6%98%8E%E4%B8%AD%E9%83%BD%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E4%B8%8D%E5%90%8C%E6%BA%90%E6%96%87%E4%BB%B6%E5%B1%9E%E4%BA%8E%E4%B8%8D%E5%90%8C%E5%AE%9E%E4%BD%93"><span class="nav-number">2.1.7.0.2.</span> <span class="nav-text">internal：在同一个源文件内的所有声明中都指向同一个实体，不同源文件属于不同实体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#none%EF%BC%9A%E6%80%BB%E6%98%AF%E8%A2%AB%E5%BD%93%E5%81%9A%E5%8D%95%E7%8B%AC%E7%9A%84%E4%B8%AA%E4%BD%93"><span class="nav-number">2.1.7.0.3.</span> <span class="nav-text">none：总是被当做单独的个体</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="nav-number">2.1.8.</span> <span class="nav-text">编译和链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.9.</span> <span class="nav-text">存储类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.10.</span> <span class="nav-text">字符串常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="nav-number">2.1.10.1.</span> <span class="nav-text">字符串长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.1.10.2.</span> <span class="nav-text">复制字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.1.10.3.</span> <span class="nav-text">连接字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="nav-number">2.1.10.4.</span> <span class="nav-text">字符串比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.11.</span> <span class="nav-text">内存操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#memcpy%EF%BC%9Avoid-memcpy-void-dest-const-void-src-size-t-count"><span class="nav-number">2.1.11.1.</span> <span class="nav-text">memcpy：void* memcpy( void *dest, const void *src, size_t count );</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memmove%EF%BC%9Avoid-memmove-void-dest-const-void-src-size-t-count"><span class="nav-number">2.1.11.2.</span> <span class="nav-text">memmove：void* memmove( void* dest, const void* src, size_t count );</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memcmp%EF%BC%9Aint-memcmp-const-void-lhs-const-void-rhs-size-t-count"><span class="nav-number">2.1.11.3.</span> <span class="nav-text">memcmp：int memcmp( const void* lhs, const void* rhs, size_t count );</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memchr%EF%BC%9Avoid-memchr-const-void-ptr-int-ch-size-t-count"><span class="nav-number">2.1.11.4.</span> <span class="nav-text">memchr：void* memchr( const void* ptr, int ch, size_t count );</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memset%EF%BC%9Avoid-memset-void-dest-int-ch-size-t-count"><span class="nav-number">2.1.11.5.</span> <span class="nav-text">memset：void *memset( void *dest, int ch, size_t count );</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">2.1.12.</span> <span class="nav-text">动态内存分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%85%B3%EF%BC%9AC%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7"><span class="nav-number">2.2.</span> <span class="nav-text">第二关：C陷阱与缺陷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%85%B3%EF%BC%9AC%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">第三关：C专家编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%85%B3%EF%BC%9ALinux-C%E7%BC%96%E7%A8%8B"><span class="nav-number">2.4.</span> <span class="nav-text">第四关：Linux C编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E5%85%B3%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">2.5.</span> <span class="nav-text">第五关：数据结构与算法分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E5%85%B3%EF%BC%9AMakefile"><span class="nav-number">2.6.</span> <span class="nav-text">第六关：Makefile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%BB%80%E4%B9%88%E6%98%AFmakefile%EF%BC%9F"><span class="nav-number">2.6.1.</span> <span class="nav-text">第一章	什么是makefile？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="nav-number">2.6.2.</span> <span class="nav-text">第二章	程序的编译和链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0Makefile%E7%AE%80%E4%BB%8B"><span class="nav-number">2.6.3.</span> <span class="nav-text">第三章	Makefile简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#makefile%E8%A7%84%E5%88%99"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">makefile规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#makefile%E4%BE%8B%E5%AD%90"><span class="nav-number">2.6.3.2.</span> <span class="nav-text">makefile例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#make%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">2.6.3.3.</span> <span class="nav-text">make的工作方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#makefile%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="nav-number">2.6.3.4.</span> <span class="nav-text">makefile中使用变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#make%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC%E5%8A%9F%E8%83%BD"><span class="nav-number">2.6.3.5.</span> <span class="nav-text">make的自动推导功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#makefile%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E9%A3%8E%E6%A0%BC"><span class="nav-number">2.6.3.6.</span> <span class="nav-text">makefile的另一种风格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%85%E7%A9%BA%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84makefile%E6%9C%80%E4%BD%B3%E8%A7%84%E5%88%99"><span class="nav-number">2.6.3.7.</span> <span class="nav-text">清空目标文件的makefile最佳规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0Makefile%E5%85%A8%E8%B2%8C"><span class="nav-number">2.6.4.</span> <span class="nav-text">第四章	Makefile全貌</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#makefile%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">2.6.4.1.</span> <span class="nav-text">makefile的内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#makefile%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="nav-number">2.6.4.2.</span> <span class="nav-text">makefile的文件名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E7%9A%84makefile%E6%96%87%E4%BB%B6"><span class="nav-number">2.6.4.3.</span> <span class="nav-text">引用其他的makefile文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-MAKEFILES"><span class="nav-number">2.6.4.4.</span> <span class="nav-text">环境变量 MAKEFILES</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#make-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">2.6.4.5.</span> <span class="nav-text">make 的工作方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99"><span class="nav-number">2.6.5.</span> <span class="nav-text">第五章	书写规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%84%E5%88%99%E8%AF%AD%E6%B3%95"><span class="nav-number">2.6.5.1.</span> <span class="nav-text">规则语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E8%A7%84%E5%88%99%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">2.6.5.2.</span> <span class="nav-text">在规则中使用通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%90%9C%E5%AF%BB"><span class="nav-number">2.6.5.3.</span> <span class="nav-text">文件搜寻</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%AA%E7%9B%AE%E6%A0%87"><span class="nav-number">2.6.5.4.</span> <span class="nav-text">伪目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%9B%AE%E6%A0%87"><span class="nav-number">2.6.5.5.</span> <span class="nav-text">多目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.6.5.6.</span> <span class="nav-text">静态模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BE%9D%E8%B5%96"><span class="nav-number">2.6.5.7.</span> <span class="nav-text">自动生成依赖</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">2.6.6.</span> <span class="nav-text">第六章	常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E6%8F%90%E7%A4%BA%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-number">2.6.6.1.</span> <span class="nav-text">显示提示的命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-number">2.6.6.2.</span> <span class="nav-text">执行命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E5%87%BA%E9%94%99"><span class="nav-number">2.6.6.3.</span> <span class="nav-text">命令出错</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E6%89%A7%E8%A1%8Cmake"><span class="nav-number">2.6.6.4.</span> <span class="nav-text">嵌套执行make</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E5%8C%85"><span class="nav-number">2.6.6.5.</span> <span class="nav-text">命令包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%8F%98%E9%87%8F"><span class="nav-number">2.6.7.</span> <span class="nav-text">第七章	变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8"><span class="nav-number">2.6.7.1.</span> <span class="nav-text">变量的嵌套使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="nav-number">2.6.7.2.</span> <span class="nav-text">变量的高级用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0%E5%8F%98%E9%87%8F%E5%80%BC"><span class="nav-number">2.6.7.3.</span> <span class="nav-text">追加变量值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#override-%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-number">2.6.7.4.</span> <span class="nav-text">override 指示符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%A1%8C%E5%8F%98%E9%87%8F"><span class="nav-number">2.6.7.5.</span> <span class="nav-text">多行变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E5%8F%98%E9%87%8F"><span class="nav-number">2.6.7.6.</span> <span class="nav-text">目标变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8F%98%E9%87%8F"><span class="nav-number">2.6.7.7.</span> <span class="nav-text">模式变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">2.6.8.</span> <span class="nav-text">第八章	条件判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.9.</span> <span class="nav-text">第九章	函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#foreach%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.9.1.</span> <span class="nav-text">foreach函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E5%85%B3%EF%BC%9ACMake"><span class="nav-number">2.7.</span> <span class="nav-text">第七关：CMake</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="BlueHole"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">BlueHole</p>
  <div class="site-description" itemprop="description">这辈子只管努力,剩下的交给命运!</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/WkCollection" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WkCollection" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/WkCollection" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wkcollection.github.io/2022/07/11/C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="BlueHole">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编程の路">
      <meta itemprop="description" content="这辈子只管努力,剩下的交给命运!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C语言突破 | 编程の路">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C语言突破
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-11 21:49:56" itemprop="dateCreated datePublished" datetime="2022-07-11T21:49:56+08:00">2022-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-08-10 14:12:21" itemprop="dateModified" datetime="2022-08-10T14:12:21+08:00">2022-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>28 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="C语言突破"><a href="#C语言突破" class="headerlink" title="C语言突破"></a>C语言突破</h1><blockquote>
<p>C和C++语言相关知识点深入理解</p>
</blockquote>
<h1 id="C和Cpp"><a href="#C和Cpp" class="headerlink" title="C和Cpp"></a>C和Cpp</h1><blockquote>
<p>C语言相关知识点深入理解</p>
</blockquote>
<h2 id="第一关：C和指针"><a href="#第一关：C和指针" class="headerlink" title="第一关：C和指针"></a>第一关：C和指针</h2><h3 id="宽字符常量"><a href="#宽字符常量" class="headerlink" title="宽字符常量"></a>宽字符常量</h3><p>如果一个多字节字符常量前面带有一个L，那么他就是宽字符常量。例如：<code>L‘X’</code></p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型的实质是以整型形式进行存储的，符号名其实都是整型值。如果某个符号未显式复制那个他的值就比前面的一个符号名的值大1。第一个未命名的初始化为0。</p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>浮点数在缺省情况下都是double类型的，加L或l表示为long double类型的，或者加F或f表示是float类型的值。</p>
<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>字符串常量在程序中使用会生成一个”指向字符的常量指针”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *message = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">/*等价于</span></span><br><span class="line"><span class="comment">char *message;</span></span><br><span class="line"><span class="comment">message = “Hello”;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="指针与常量"><a href="#指针与常量" class="headerlink" title="指针与常量"></a>指针与常量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> *p;<span class="comment">//可以修改指针的值，无法修改指针指向的值</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p1;<span class="comment">//指针为常量无法修改，指针指向的值可以修改</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> p2;<span class="comment">//指针的指向和指针指向的值都不可以改变</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="代码块作用域"><a href="#代码块作用域" class="headerlink" title="代码块作用域"></a>代码块作用域</h4><p>位于一对花括号之间的所有语句都称为一个代码块，任何在代码块的开始位置声明的标识符都具有代码块作用域。</p>
<h4 id="文件作用域"><a href="#文件作用域" class="headerlink" title="文件作用域"></a>文件作用域</h4><p>任何在所有代码块之外声明的标识符都具有文件作用域。</p>
<h4 id="原型作用域"><a href="#原型作用域" class="headerlink" title="原型作用域"></a>原型作用域</h4><p>原型作用域只适用于在函数原型中声明的参数名。</p>
<h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><p>函数作用域只适用于语句标签，指在函数内声明的所有变量在函数体内始终是可见的,可以在整个函数的范围内使用及复用。</p>
<span id="more"></span>

<h3 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h3><ol>
<li><h5 id="external：无论被声明多少次，位于不同源文件的都表示同一个实体"><a href="#external：无论被声明多少次，位于不同源文件的都表示同一个实体" class="headerlink" title="external：无论被声明多少次，位于不同源文件的都表示同一个实体"></a>external：无论被声明多少次，位于不同源文件的都表示同一个实体</h5></li>
<li><h5 id="internal：在同一个源文件内的所有声明中都指向同一个实体，不同源文件属于不同实体"><a href="#internal：在同一个源文件内的所有声明中都指向同一个实体，不同源文件属于不同实体" class="headerlink" title="internal：在同一个源文件内的所有声明中都指向同一个实体，不同源文件属于不同实体"></a>internal：在同一个源文件内的所有声明中都指向同一个实体，不同源文件属于不同实体</h5></li>
<li><h5 id="none：总是被当做单独的个体"><a href="#none：总是被当做单独的个体" class="headerlink" title="none：总是被当做单独的个体"></a>none：总是被当做单独的个体</h5></li>
</ol>
<p><code>关键字extern和static可用来修改链接属性，使用static可以使得链接属性变为internal,但是只对缺省的external有效</code></p>
<p><code>当extern关键字用于标识符第一次声明，指定有external属性，用于变量第二次或以后的声明则不会更改第一次声明的链接属性</code></p>
<h3 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h3><ol>
<li><p>编译一个源文件main.c</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c</span><br></pre></td></tr></table></figure>

<p>会产生一个a.exe的可执行程序</p>
</li>
<li><p>编译并链接几个C源文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c hello.c</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译一个源文件并把其和现存文件链接在一起</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o hello.c</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译单个C源文件，并产生目标文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译几个C源文件，并为每个文件产生一个目标文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c hello.c</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h3><p>凡是存在于任何代码块之外声明的变量总是存储于静态内存中，即存储在全局区中，存在于全局区的变量于程序运行前创建，在程序执行的整个期间始终存在，始终保持原来的值，除非赋新的值。</p>
<p>在代码块内部声明的变量的缺省类型是自动的，存储于堆栈中，<code>在程序执行到声明的变量时，该变量才被创建，当程序的执行离开代码块时，该变量被销毁</code>。在代码块内部给声明的变量加上static可以让变量放到全局区内去，但是该变量的作用域依旧不变。</p>
<p>register关键字可以用于自动变量的声明，表示这个变量应该存储于寄存器中而不是内存中，也被称为寄存器变量。通常寄存器变量比内存的变量访问效率更高，但是寄存器不一定会理睬寄存器变量，只会选取前几个实际存储于寄存器中。</p>
<h3 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h3><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *msg = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(msg);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;msg的长度是:%d\n&quot;</span>, len);</span><br></pre></td></tr></table></figure>

<h4 id="复制字符串"><a href="#复制字符串" class="headerlink" title="复制字符串"></a>复制字符串</h4><p><code>strcpy</code>返回目标函数的一个拷贝</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *msg = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="type">char</span> copy[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(copy, msg);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;copy数组内为:%s\n&quot;</span>, copy);</span><br></pre></td></tr></table></figure>

<h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str3[] = <span class="string">&quot;I Love &quot;</span>;</span><br><span class="line"><span class="type">char</span> str4[] = <span class="string">&quot;China&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(str3, str4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str3为:%s\n&quot;</span>, str3);</span><br></pre></td></tr></table></figure>

<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;bceg&quot;</span>;</span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;abceg&quot;</span>;</span><br><span class="line"><span class="type">int</span>  result = <span class="built_in">strcmp</span>(str, str1);</span><br><span class="line"><span class="keyword">if</span>(result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str大于str1\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str小于str1\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str等于str1\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h3><h4 id="memcpy：void-memcpy-void-dest-const-void-src-size-t-count"><a href="#memcpy：void-memcpy-void-dest-const-void-src-size-t-count" class="headerlink" title="memcpy：void* memcpy( void *dest, const void *src, size_t count );"></a>memcpy：<code>void* memcpy( void *dest, const void *src, size_t count );</code></h4><p>从 <code>src</code> 所指向的对象复制 <code>count</code> 个字节到 <code>dest</code> 所指向的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> msg[<span class="number">13</span>] = <span class="string">&quot;Hello World~&quot;</span>;</span><br><span class="line"><span class="type">char</span> msgDst[<span class="number">13</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(msgDst, msg, <span class="number">13</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;msgDst is %s\n&quot;</span>, msgDst);</span><br></pre></td></tr></table></figure>

<h4 id="memmove：void-memmove-void-dest-const-void-src-size-t-count"><a href="#memmove：void-memmove-void-dest-const-void-src-size-t-count" class="headerlink" title="memmove：void* memmove( void* dest, const void* src, size_t count );"></a>memmove：<code>void* memmove( void* dest, const void* src, size_t count );</code></h4><p> 从 <code>src</code> 所指向的对象复制 <code>count</code> 个字节到 <code>dest</code> 所指向的对象。与memcpy不同的是，memmove的源和目标数可以重叠。也就是说<code>src</code>和<code>dest</code>可以相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> msgSrc[<span class="number">5</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> msgDstTwo[<span class="number">6</span>];</span><br><span class="line">memmove(msgDstTwo, msgSrc, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;msgDstTwo is %s\n&quot;</span>, msgDstTwo);</span><br></pre></td></tr></table></figure>

<h4 id="memcmp：int-memcmp-const-void-lhs-const-void-rhs-size-t-count"><a href="#memcmp：int-memcmp-const-void-lhs-const-void-rhs-size-t-count" class="headerlink" title="memcmp：int memcmp( const void* lhs, const void* rhs, size_t count );"></a>memcmp：<code>int memcmp( const void* lhs, const void* rhs, size_t count );</code></h4><p>比较 <code>lhs</code> 和 <code>rhs</code> 所指向对象的首 <code>count</code> 个字节。如果<code>lhs</code>小于<code>rhs</code>则小于0；如果<code>lhs</code>大于<code>rhs</code>则大于0;如果<code>lhs</code>等于<code>rhs</code>则等于0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> info[] = <span class="string">&quot;Hi,I am Tom&quot;</span>;</span><br><span class="line"><span class="type">char</span> infoTwo[] = <span class="string">&quot;hi,I am Tom&quot;</span>;</span><br><span class="line"><span class="type">int</span>  result = <span class="built_in">memcmp</span>(info, infoTwo, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">if</span>(result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;info大于infoTwo\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;info小于infoTwo\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;info等于infoTwo\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="memchr：void-memchr-const-void-ptr-int-ch-size-t-count"><a href="#memchr：void-memchr-const-void-ptr-int-ch-size-t-count" class="headerlink" title="memchr：void* memchr( const void* ptr, int ch, size_t count );"></a>memchr：<code>void* memchr( const void* ptr, int ch, size_t count );</code></h4><p>从<code>ptr</code>的起始位置开始查找<code>ch</code>的首次出现的位置，返回一个指向该位置的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> info[] = <span class="string">&quot;Hi,I am Tom&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">memchr</span>(info, <span class="number">97</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p is %s\n&quot;</span>, p);</span><br></pre></td></tr></table></figure>

<h4 id="memset：void-memset-void-dest-int-ch-size-t-count"><a href="#memset：void-memset-void-dest-int-ch-size-t-count" class="headerlink" title="memset：void *memset( void *dest, int ch, size_t count );"></a>memset：<code>void *memset( void *dest, int ch, size_t count );</code></h4><p>从 <code>dest</code>开始的<code>count</code>个字节都设置为<code>ch</code> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> zero[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">memset</span>(zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(zero));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(zero) / <span class="keyword">sizeof</span>(zero[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;zero[%d] = %d\n&quot;</span>, i, zero[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>动态内存分配两个主要的函数<code>malloc</code>和<code>free</code>。</p>
<p><code>malloc</code>和<code>calloc</code>都用于分配内存，区别在于后者在返回指向内存的指针前会将其初始化为0。</p>
<h2 id="第二关：C陷阱与缺陷"><a href="#第二关：C陷阱与缺陷" class="headerlink" title="第二关：C陷阱与缺陷"></a>第二关：C陷阱与缺陷</h2><h2 id="第三关：C专家编程"><a href="#第三关：C专家编程" class="headerlink" title="第三关：C专家编程"></a>第三关：C专家编程</h2><h2 id="第四关：Linux-C编程"><a href="#第四关：Linux-C编程" class="headerlink" title="第四关：Linux C编程"></a>第四关：Linux C编程</h2><h2 id="第五关：数据结构与算法分析"><a href="#第五关：数据结构与算法分析" class="headerlink" title="第五关：数据结构与算法分析"></a>第五关：数据结构与算法分析</h2><h2 id="第六关：Makefile"><a href="#第六关：Makefile" class="headerlink" title="第六关：Makefile"></a>第六关：Makefile</h2><h3 id="第一章什么是makefile？"><a href="#第一章什么是makefile？" class="headerlink" title="第一章	什么是makefile？"></a>第一章	什么是makefile？</h3><p>makefile关系到整个工程的编译规则，makefile定义了一些规则来指定哪些文件需要先进行编译，哪些文件需要后进行编译，哪些文件需要重新进行编译，甚至于进行更加复杂的操作。值得一提的是makefile也可以执行操作系统的命令。makefile带来的好处就是——自动化编译，一旦makefile文件写好，只需要一个make命令就可以完成整个工程的完全自动化编译，可以极大的提高软件开发的效率。make是一个解释makefile文件中指令的命令工具。</p>
<h3 id="第二章程序的编译和链接"><a href="#第二章程序的编译和链接" class="headerlink" title="第二章	程序的编译和链接"></a>第二章	程序的编译和链接</h3><p>一般来说对于编译型语言，首先要做的就是将源文件编译成中间代码文件，对于C，C++,在Windwos下来说也就是.obj文件，这个过程就是编译。然后再把大量编译好的目标文件链接在一起合成一个可执行文件，这个过程就是链接。编译时，编译器只检查程序的语法，变量和函数是否被声明，如果未被声明那么编译器会给出警告，此时可以成功生成目标文件，但是在链接过程中，链接器会在所有的目标文件中查找函数的定义，找不到则会报链接错误。</p>
<h3 id="第三章Makefile简介"><a href="#第三章Makefile简介" class="headerlink" title="第三章	Makefile简介"></a>第三章	Makefile简介</h3><h4 id="makefile规则"><a href="#makefile规则" class="headerlink" title="makefile规则"></a>makefile规则</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target : prerequisites</span><br><span class="line">	command</span><br></pre></td></tr></table></figure>

<p>target：可以是一个目标文件，也可以是一个可执行程序，还可以是一个标签。</p>
<p>prerequisites：指要生成那个target所需要的文件或是目标。</p>
<p>command：是指make需要执行的命令，可以是任意是shell命令。</p>
<p><code>总结：如果prerequisites中有一个以上的文件比target的文件要新的话，command所定义的命令就会被执行。</code></p>
<h4 id="makefile例子"><a href="#makefile例子" class="headerlink" title="makefile例子"></a>makefile例子</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line">	gcc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">	gcc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">	gcc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">	gcc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">	gcc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">	gcc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">	gcc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">	gcc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">	gcc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">	rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>

<p>这里要说明一点的是，clean 不是一个文件，它只不过是一个动作名字，有点像 C 语言中的 lable 一样，其冒号后什么也没有，那么，make 就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在 make 命令后明显得指出这个lable 的名字。  </p>
<h4 id="make的工作方式"><a href="#make的工作方式" class="headerlink" title="make的工作方式"></a>make的工作方式</h4><p>在默认的方式下，也就是我们只输入 make 命令。那么</p>
<ol>
<li>make 会在当前目录下找名字叫“Makefile”或“makefile”的文件。</li>
<li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。</li>
<li>如果 edit 文件不存在， 或是 edit 所依赖的后面的 .o 文件的文件修改时间要比 edit这个文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。</li>
<li>如果 edit 所依赖的.o 文件也存在，那么 make 会在当前文件中找目标为.o 文件的依赖性，如果找到则再根据那一个规则生成.o 文件。 </li>
<li>当然，你的 C 文件和 H 文件是存在的啦， 于是 make 会生成 .o 文件， 然后再用 .o 文件生命 make 的终极任务，也就是执行文件 edit 了。</li>
</ol>
<h4 id="makefile中使用变量"><a href="#makefile中使用变量" class="headerlink" title="makefile中使用变量"></a>makefile中使用变量</h4><p>从上面的例子中可以看到<code>main.o kbd.o command.o display.o insert.o search.o files.o utils.o</code>被使用了3次。如果工程很大的话，需要依赖的目标文件很多的话，那么就很容易忘掉需要添加的目标文件，为了makefile便于维护，我们可以使用变量，makefile的变量就类似于C语言中的宏。</p>
<p>所以对于需要使用多次的目标文件，可以对其定义一个变量来表示。即<code>obj = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</code>。然后通过<code>$(obj)</code>来进行使用。经过修改后那么makefile文件如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">obj = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(obj)</span></span><br><span class="line">	gcc -o edit <span class="variable">$(obj)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">	gcc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">	gcc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">	gcc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">	gcc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">	gcc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">	gcc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">	gcc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">	gcc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">	rm edit <span class="variable">$(obj)</span></span><br></pre></td></tr></table></figure>

<h4 id="make的自动推导功能"><a href="#make的自动推导功能" class="headerlink" title="make的自动推导功能"></a>make的自动推导功能</h4><p>GNU的make很强大，可以自动推导文件及其文件依赖后面的命令。只要make看到一个.o文件，他就会自动的将.c文件加在依赖关系中，并且gcc -c也会被自动推导出来。于是改良版plus的makefile如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">obj = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(obj)</span></span><br><span class="line">	gcc -o edit <span class="variable">$(obj)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">	rm edit <span class="variable">$(obj)</span></span><br></pre></td></tr></table></figure>

<p><code>.PHONY</code> 表示clean是一个伪目标文件。</p>
<h4 id="makefile的另一种风格"><a href="#makefile的另一种风格" class="headerlink" title="makefile的另一种风格"></a>makefile的另一种风格</h4><p>这种风格就是将相同的.h和.o文件进行收拢。没有上一种情况可以那么清楚的显示依赖关系。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(obj)</span></span><br><span class="line">	gcc -o edit <span class="variable">$(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(obj)</span> : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">	rm edit <span class="variable">$(obj)</span></span><br></pre></td></tr></table></figure>

<h4 id="清空目标文件的makefile最佳规则"><a href="#清空目标文件的makefile最佳规则" class="headerlink" title="清空目标文件的makefile最佳规则"></a>清空目标文件的makefile最佳规则</h4><p>一般的风格都是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm edit <span class="variable">$(objects)</span>  </span><br></pre></td></tr></table></figure>

<p>更为稳健的做法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">	-rm edit <span class="variable">$(objects)</span> </span><br></pre></td></tr></table></figure>

<p> 在 rm 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean 的规则不要放在文件的开头，不然，这就会变成 make 的默认目标。 </p>
<h3 id="第四章Makefile全貌"><a href="#第四章Makefile全貌" class="headerlink" title="第四章	Makefile全貌"></a>第四章	Makefile全貌</h3><h4 id="makefile的内容"><a href="#makefile的内容" class="headerlink" title="makefile的内容"></a>makefile的内容</h4><ol>
<li><p>显式规则</p>
<p>显式规则说明了，如何生成一个或多的的目标文件。这是由 Makefile 的书写者明显指<br>出，要生成的文件，文件的依赖文件，生成的命令。  </p>
</li>
<li><p>隐式规则</p>
<p>由于我们的 make 有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书<br>写 Makefile，这是由 make 所支持的。  </p>
</li>
<li><p>变量</p>
<p>在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点类似C 语言中<br>的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。  </p>
</li>
<li><p>文件引用</p>
<p>一个是在一个makefile文件中包含另一个makefile,类似C的include一样，另一种情况则是根据某些情况指定makefile的有效部分，类似于C语言的#if一样，还有就是定义一个多行的命令。</p>
</li>
<li><p>注释</p>
<p>makefile中只有行注释，注释是使用<code>#</code>号，需要使用到#号的地方可以进行转义。</p>
</li>
</ol>
<p><code>makefile中的命令必须以Tab键开头进行缩进。</code></p>
<h4 id="makefile的文件名"><a href="#makefile的文件名" class="headerlink" title="makefile的文件名"></a>makefile的文件名</h4><p>默认情况下，make会寻找文件名为”GNUmakefile”,”makefile”,”Makefile”这三个文件。GNUmakefile只支持GNU，大多数都支持：”makefile”,”Makefile”。</p>
<p>如果想要使用别的文件名来书写makefile,可以使用<code>make -f  文件名</code>或者<code>make --file 文件名</code>来指定特定的文件。</p>
<h4 id="引用其他的makefile文件"><a href="#引用其他的makefile文件" class="headerlink" title="引用其他的makefile文件"></a>引用其他的makefile文件</h4><p>在 Makefile 使用 include 关键字可以把别的 Makefile 包含进来，这很像 C 语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include 的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>filename 可以是当前操作系统 Shell 的文件模式（可以保含路径和通配符） 在 include前面可以有一些空字符，但是绝不能是[Tab]键开始。include 和<filename>可以用一个或多个空格隔开。  </p>
<p>如果文件都没有指定绝对路径或是相对路径的话，make 会在当前目录下首先寻找，如果当前目录下没有找到，那么，make 还会在下面的几个目录下找：  </p>
<ol>
<li>如果 make 执行时，有<code>-I</code>或<code>--include-dir</code>参数，那么 make 就会在这个参数所指定的目录下去寻找 。</li>
<li>如果目录<prefix>&#x2F;include（一般是：&#x2F;usr&#x2F;local&#x2F;bin 或&#x2F;usr&#x2F;include）存在的话，make 也会去找。如果有文件没有找到的话，make 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找到，或是不能读取的文件，如果还是不行，make 才会出现一条致命信息。如果你想让 make不理那些无法读取的文件，而继续执行，你可以在 include 前加一个减号“-”。</li>
</ol>
<h4 id="环境变量-MAKEFILES"><a href="#环境变量-MAKEFILES" class="headerlink" title="环境变量 MAKEFILES"></a>环境变量 MAKEFILES</h4><p>如果你的当前环境中定义了环境变量 MAKEFILES，那么，make 会把这个变量中的值做一个类似include 的动作。这个变量中的值是其它的 Makefile，用空格分隔。只是， 它和 include不同的是，从这个环境变中引入的 Makefile 的“目标”不会起作用，如果环境变量中定义的文件发现错误，make 也会不理。</p>
<h4 id="make-的工作方式"><a href="#make-的工作方式" class="headerlink" title="make 的工作方式"></a>make 的工作方式</h4><p>GNU 的 make 工作时的执行步骤入下： </p>
<ol>
<li>读入所有的 Makefile。</li>
<li>读入被 include 的其它 Makefile。</li>
<li>初始化文件中的变量。</li>
<li>推导隐晦规则，并分析所有规则。</li>
<li>为所有的目标文件创建依赖关系链。</li>
<li>根据依赖关系，决定哪些目标要重新生成。</li>
<li>执行生成命令。</li>
</ol>
<h3 id="第五章书写规则"><a href="#第五章书写规则" class="headerlink" title="第五章	书写规则"></a>第五章	书写规则</h3><p>在 Makefile 中，规则的顺序是很重要的，因为，Makefile 中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让 make 知道你的最终目标是什么。一般来说，定义在 Makefile 中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。 </p>
<h4 id="规则语法"><a href="#规则语法" class="headerlink" title="规则语法"></a>规则语法</h4><p>第一种写法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">targets : prerequisites</span><br><span class="line">	command </span><br></pre></td></tr></table></figure>

<p> 第二种写法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targets : prerequisites ; command</span><br></pre></td></tr></table></figure>

<p>如果命令太长，你可以使用反斜框（‘\’）作为换行符。</p>
<h4 id="在规则中使用通配符"><a href="#在规则中使用通配符" class="headerlink" title="在规则中使用通配符"></a>在规则中使用通配符</h4><p>make 支持三种通配符： <code>*</code>，<code>?</code>和<code>[]</code>。 波浪号（“<del>”）字符在文件名中也有比较特殊的用途。如果是“</del>&#x2F;test”，这就表示当前用户的$HOME 目录下的 test 目录。而“~hchen&#x2F;test”则表示用户 hchen 的宿主目录下的 test 目录。 在 Windows 下则指的是环境变量“HOME”  。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects = *.o</span><br></pre></td></tr></table></figure>

<p>此时objects的值就是*.o，如果需要objects的值是所有.o文件的集合，那么需要用到<code>wildcard</code>关键字，即 <code>objects := $(wildcard *.o)</code>。</p>
<h4 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h4><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当 make 需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉 make，让 make 在自动去找。  </p>
<p>Makefile 文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make 只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。 </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure>

<p>另一个设置文件搜索路径的方法是使用 make 的“vpath”关键字 ，它的用法有三种：</p>
<ol>
<li><p><code>vpath &lt;pattern&gt; &lt;directories&gt;</code></p>
<p>为符合模式<pattern>的文件指定搜索目录<directories>。  </p>
</li>
<li><p><code>vpath &lt;pattern&gt;  </code></p>
<p>清除符合模式<pattern>的文件的搜索目录。  </p>
</li>
<li><p><code>vpath  </code></p>
<p>清除所有已被设置好了的文件搜索目录。</p>
</li>
</ol>
<p>vapth 使用方法中的<pattern>需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。<pattern>指定了要搜索的文件集，而<directories>则指定了<pattern>的文件集的搜索的目录。  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.h ../headers</span><br></pre></td></tr></table></figure>

<p>该语句表示，要求 make 在“..&#x2F;headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）  </p>
<h4 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h4><p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的 Makefile 需要一口气生成若干个可执行文件，但你只想简单地敲一个 make 完事，并且，所有的目标文件都写在一个 Makefile 中，那么你可以使用“伪目标”这个特性：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">all : prog1 prog2 prog3</span><br><span class="line">.PHONY : all</span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">	cc -o prog1 prog1.o utils.o</span><br><span class="line">prog2 : prog2.o</span><br><span class="line">	cc -o prog2 prog2.o</span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">	cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>

<p>伪目标同样也可成为依赖。看下面的例子：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: cleanall cleanobj cleandiff</span></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">	rm program</span><br><span class="line">cleanobj :</span><br><span class="line">	rm *.o</span><br><span class="line">cleandiff :</span><br><span class="line">	rm *.diff</span><br></pre></td></tr></table></figure>

<p>我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。  </p>
<h4 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h4><p>Makefile 的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”  ，这个变量表示着目前规则中所有的目标的集合。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>  等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bigoutput : text.g</span><br><span class="line">generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure>

<p>其中，-$(subst output,$@)中的“$”表示执行一个 Makefile 的函数，函数名为 subst，后面的为参数。 这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。   </p>
<h4 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h4><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活 。</p>
<p>语法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;targets ...&gt; : &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;</span><br><span class="line">	&lt;commands&gt;</span><br></pre></td></tr></table></figure>

<p>targets 定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p>
<p>target-parrtern 是指明了 targets 的模式，也就是的目标集模式。</p>
<p>prereq-parrterns 是目标的依赖模式，它对 target-parrtern 形成的模式再进行一次依赖目标的定义。  </p>
<p>看一个例子：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，指明了我们的目标从$object 中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object 集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，<code>$&lt;</code>表示所有的依赖目标集（也就是“foo.c bar.c”）， <code>$@</code>表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>

<p>如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o,<span class="variable">$(files)</span>)</span>: %.o: %.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.elc,<span class="variable">$(files)</span>)</span>: %.elc: %.el</span><br><span class="line">emacs -f batch-byte-compile <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>

<h4 id="自动生成依赖"><a href="#自动生成依赖" class="headerlink" title="自动生成依赖"></a>自动生成依赖</h4><p>如果是一个比较大型的工程，你必需清楚哪些 C 文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改 Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用 C&#x2F;C++编译的一个功能。大多数的C&#x2F;C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。 </p>
<p> <code>如果你使用 GNU 的 C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。  </code></p>
<p>GNU 组织建议把编译器为每一个源 文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的 Makefile 文件，[.d]文件中就存放对应[.c]文件的依赖关系。于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让 make 自动更新或自成[.d]文件，并把其包含在我们的Makefile 中，这样，我们就可以自动化地生成每个文件的依赖关系了。这里，我们给出了一个模式规则来产生[.d]文件：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">@set -e; rm -f <span class="variable">$@</span>; \</span><br><span class="line"><span class="variable">$(CC)</span> -M <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span>.$$$$; \</span><br><span class="line">sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.$$$$ &gt; <span class="variable">$@</span>; \</span><br><span class="line">rm -f <span class="variable">$@</span>.$$$$</span><br></pre></td></tr></table></figure>

<p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm -f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$&lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式“ %.d” 文件，如果有一个 C 文件是 name.c，那么“%”就是“name”，“$$$$”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用 sed 命令做了一个替换。第四行就是删除临时文件。  </p>
<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：  </p>
<p><code>main.o : main.c defs.h</code>转成：<code>main.o main.d : main.c defs.h  </code>。</p>
<p>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主 Makefile 中。 我们可以使用Makefile 的“include”命令，来引入别的 Makefile 文件，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure>

<p>上述语句中的“$(sources:.c&#x3D;.d)”中的“.c&#x3D;.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]。当然，你得注意次序，因为 include 是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。    </p>
<h3 id="第六章常用命令"><a href="#第六章常用命令" class="headerlink" title="第六章	常用命令"></a>第六章	常用命令</h3><h4 id="显示提示的命令"><a href="#显示提示的命令" class="headerlink" title="显示提示的命令"></a>显示提示的命令</h4><p>通常，make 会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被 make 显示出来，最具代表性的例子是，我们用这个功能来向屏幕显示一些信息。如：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@echo 正在编译 XXX 模块......</span><br></pre></td></tr></table></figure>

<p>当 make 执行时，会输出“正在编译 XXX 模块……”字串，但不会输出命令，如果没有“@”，那么，make 将输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 正在编译 XXX 模块......</span><br><span class="line"></span><br><span class="line">正在编译 XXX 模块......  </span><br></pre></td></tr></table></figure>

<p>如果 make 执行时，带入 make 参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的 Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。  而 make 参数“-s”或“–slient”则是全面禁止命令的显示。  </p>
<h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make 会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是 cd 命令，你希望第二条命令得在 cd 之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。  如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例一：</span></span><br><span class="line">exec:</span><br><span class="line">cd /home/hchen</span><br><span class="line">pwd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例二：</span></span><br><span class="line">exec:</span><br><span class="line">cd /home/hchen; pwd</span><br></pre></td></tr></table></figure>

<p>当我们执行“make exec”时，第一个例子中的 cd 没有作用，pwd 会打印出当前的Makefile 目录，而第二个例子中，cd 就起作用了，pwd 会打印出“&#x2F;home&#x2F;hchen”。  </p>
<h4 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h4><p>每当命令运行完后，make 会检测每个命令的返回码，如果命令返回成功，那么 make 会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么 make 就会终止执行当前规则，这将有可能终止所有规则的执行。 </p>
<p> 有些时候，命令的出错并不表示就是错误的。  为了忽略命令的出错，我们可以在 Makefile 的命令行前加一个减号“-”（在 Tab 键之后），标记为不管命令出不出错都认为是成功的。还有一个全局的办是，给 make 加上“-i”或是“ –ignore-errors”参数，那么，Makefile 中所有命令都会忽略错误。 而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。还有一个要提一下的 make 的参数的是“-k”或是“–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p>
<h4 id="嵌套执行make"><a href="#嵌套执行make" class="headerlink" title="嵌套执行make"></a>嵌套执行make</h4><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的 Makefile，这有利于让我们的 Makefile 变得更加地简洁，而不至于把所有的东西全部写在一个 Makefile 中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。  </p>
<p>例如，我们有一个子目录叫 subdir，这个目录下有个 Makefile 文件，来指明了这个目录下文件的编译规则。那么我们总控的 Makefile 可以这样书写：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">	cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>

<p>如果你要传递变量到下级 Makefile 中，那么你可以使用这样的声明：<code>export &lt;variable ...&gt;</code></p>
<p>如果你不想让某些变量传递到下级 Makefile 中，那么可以这样声明：<code>unexport &lt;variable ...&gt;  </code></p>
<p>需要注意的是，有两个变量，一个是 SHELL，一个是 MAKEFLAGS，这两个变量不管你是否 export，其总是要传递到下层 Makefile 中，特别是 MAKEFILES 变量，其中包含了 make的参数信息，如果我们执行“总控 Makefile”时有 make 参数或是在上层 Makefile 中定义了这个变量，那么 MAKEFILES 变量将会是这些参数，并会传递到下层 Makefile 中，这是一个系统级的环境变量 。但是 make 命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”  ,如果你不想往下层传递参数，那么，你可以这样来：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">	cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> MAKEFLAGS= </span><br></pre></td></tr></table></figure>

<h4 id="命令包"><a href="#命令包" class="headerlink" title="命令包"></a>命令包</h4><p>如果 Makefile 中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>

<p>这里，“ run-yacc”是这个命令包的名字，其不要和 Makefile 中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行 Yacc程序，因为 Yacc 程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。 </p>
<h3 id="第七章变量"><a href="#第七章变量" class="headerlink" title="第七章	变量"></a>第七章	变量</h3><blockquote>
<p>变量是大小写敏感的  </p>
</blockquote>
<h4 id="变量的嵌套使用"><a href="#变量的嵌套使用" class="headerlink" title="变量的嵌套使用"></a>变量的嵌套使用</h4><p>第一种方式，也就是简单的使用“&#x3D;”号，在“&#x3D;”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	echo <span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure>

<p>第二种方式，使用:&#x3D;操作符，如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br><span class="line">其等价于：</span><br><span class="line">y := foo bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>

<p>还有一个比较有用的操作符是“?&#x3D;”  ,如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure>

<p>其含义是，如果 FOO 没有被定义过，那么变量 FOO 的值就是“bar”，如果 FOO 先前被定义过，那么这条语将什么也不做。  </p>
<h4 id="变量的高级用法"><a href="#变量的高级用法" class="headerlink" title="变量的高级用法"></a>变量的高级用法</h4><p>第一种是变量值的替换。  如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br></pre></td></tr></table></figure>

<p>这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。 </p>
<p>另外一种变量替换的技术是以“静态模式”  ，如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:%.o=%.c)</span><br></pre></td></tr></table></figure>

<p>第二种高级用法是——“把变量的值再当成变量”。  如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure>

<h4 id="追加变量值"><a href="#追加变量值" class="headerlink" title="追加变量值"></a>追加变量值</h4><p>我们可以使用“+&#x3D;”操作符给变量追加值，  如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br></pre></td></tr></table></figure>

<h4 id="override-指示符"><a href="#override-指示符" class="headerlink" title="override 指示符"></a>override 指示符</h4><p>如果有变量是通常 make 的命令行参数设置的，那么 Makefile 中对这个变量的赋值会被忽略。如果你想在 Makefile 中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt; = &lt;value&gt;</span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt; := &lt;value&gt;  </span><br></pre></td></tr></table></figure>

<h4 id="多行变量"><a href="#多行变量" class="headerlink" title="多行变量"></a>多行变量</h4><p>还有一种设置变量值的方法是使用 define 关键字。 使用 define 关键字设置变量的值可以有换行，这有利于定义一系列的命令 。</p>
<p>define 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以 endef 关键字结束。其工作方式和“&#x3D;”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。 因为命令需要以[Tab]键开头， 所以如果你用 define 定义的命令变量中没有以[Tab]键开头，那么 make 就不会把其认为是命令。  </p>
<h4 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h4><p>目标变量的作用范围只在这条规则以及连带规则中。语法是：<br><code>&lt;target ...&gt; : &lt;variable-assignment&gt; &lt;target ...&gt; : overide &lt;variable-assignment&gt;</code></p>
<p>  如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.o foo.o bar.o</span><br><span class="line">prog.o : prog.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.c</span><br><span class="line">foo.o : foo.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> foo.c</span><br><span class="line">bar.o : bar.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> bar.c</span><br></pre></td></tr></table></figure>

<h4 id="模式变量"><a href="#模式变量" class="headerlink" title="模式变量"></a>模式变量</h4><p>通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。  如：给所有以[.o]结尾的目标定义目标变量 。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o : CFLAGS = -O</span><br></pre></td></tr></table></figure>

<h3 id="第八章条件判断"><a href="#第八章条件判断" class="headerlink" title="第八章	条件判断"></a>第八章	条件判断</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">	<span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>特别注意的是，make 是在读取 Makefile 时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。  </p>
<h3 id="第九章函数"><a href="#第九章函数" class="headerlink" title="第九章	函数"></a>第九章	函数</h3><p>语法：<code>$(&lt;function&gt; &lt;arguments&gt;)  </code>或者是<code>$&#123;&lt;function&gt; &lt;arguments&gt;&#125;  </code>。</p>
<h4 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h4><p>语法：<code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)  </code>。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> n,<span class="variable">$(names)</span>,<span class="variable">$(n)</span>.o)</span></span><br></pre></td></tr></table></figure>

<h2 id="第七关：CMake"><a href="#第七关：CMake" class="headerlink" title="第七关：CMake"></a>第七关：CMake</h2>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请作者喝瓶脉动~</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="BlueHole 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag"><i class="fa fa-tag"></i> 编程语言</a>
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/08/Python/" rel="next" title="深度学习之路：Python配置Pytorch">
                  深度学习之路：Python配置Pytorch <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BlueHole</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">71k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:59</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"forest"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js","integrity":"sha256-8L3O8tirFUa8Va4NSTAyIbHJeLd6OnlcxgupV9F77e0="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"left","width":300,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<script src="https://cdn.jsdelivr.net/gh/WkCollection/live2d-widget/autoload.js"></script>
