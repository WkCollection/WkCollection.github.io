<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cpp深入学习</title>
    <url>/2022/06/21/CppDeep/</url>
    <content><![CDATA[<h1 id="C-深入学习"><a href="#C-深入学习" class="headerlink" title="C++深入学习"></a>C++深入学习</h1><blockquote>
<p>本文用来进行Cpp的深入学习</p>
</blockquote>
<span id="more"></span>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2022/06/21/NetWork/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><blockquote>
<p>基于《计算机网络 自顶向下》的学习，了解后能够对于网络之间的交换有更加深入的理解，学习前后端必修之课</p>
</blockquote>
<span id="more"></span>]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统</title>
    <url>/2022/06/21/OperateSystem/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><blockquote>
<p>本文为学习操作系统的基础</p>
</blockquote>
<span id="more"></span>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs</title>
    <url>/2022/06/20/Nodejs/</url>
    <content><![CDATA[<h1 id="Nodejs学习"><a href="#Nodejs学习" class="headerlink" title="Nodejs学习"></a>Nodejs学习</h1><h2 id="什么是Nodejs"><a href="#什么是Nodejs" class="headerlink" title="什么是Nodejs?"></a>什么是Nodejs?</h2><p>Nodejs是一个建立在Chrome的Javascript的V8引擎上的一个Javascript运行时环境。</p>
<p>特性：</p>
<ul>
<li>文件读写</li>
<li>进程管理</li>
<li>网络通信<span id="more"></span></li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp学习</title>
    <url>/2022/06/19/Cpp/</url>
    <content><![CDATA[<h1 id="C-学习"><a href="#C-学习" class="headerlink" title="C++学习"></a>C++学习</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>方便存放同类型的元素</p>
</blockquote>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>一维数组数组名代表数组的首地址</p>
<p>一维数组名可以计算出数组在内存空间所占内存大小</p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组名代表二维数组的首地址，也可以查看某行的首地址</p>
<p>二维数组可以计算出数组在内存空间所占内存大小，也可以计算出某行所占内存大小</p>
<span id="more"></span>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote>
<p>作用：保存地址</p>
</blockquote>
<p>指针的定义：数据类型	*指针变量名<br>32位操作系统指针所占内存空间：4个字节</p>
<p>64位操作系统指针所占内存空间：8个字节</p>
<h3 id="指针的两大类型"><a href="#指针的两大类型" class="headerlink" title="指针的两大类型"></a>指针的两大类型</h3><p>空指针：</p>
<ol>
<li>指针变量指向内存编号为0的空间</li>
<li><strong>空指针指向内存无法访问</strong>，0~255内存编号给系统占用的，无法访问</li>
<li>可用于给指针变量初始化</li>
</ol>
<p>野指针：指针变量指向非法空间，要尽量避免</p>
<h3 id="const与指针结合"><a href="#const与指针结合" class="headerlink" title="const与指针结合"></a>const与指针结合</h3><p>const修饰指针称为常量指针:<strong>指针指向的值不能变，指针的指向可以变</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	常量指针：指针指向的值不能变，指针的指向可以变</span></span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> *p=&amp;a;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">30</span>;</span><br><span class="line">	p=&amp;b;<span class="comment">//指针的指向可以改，由指向a修改为指向b </span></span><br><span class="line"><span class="comment">//	*p=b; 指向的值不能改 </span></span><br><span class="line">	cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const修饰常量称为指针常量：<strong>指针指向的值可以改，指针的指向不可以修改</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	指针常量：指针指向的值可以改，指针的指向不可以修改</span></span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> * <span class="type">const</span> p=&amp;a;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">30</span>;</span><br><span class="line">	*p=b; <span class="comment">//指向的值可以改</span></span><br><span class="line"><span class="comment">//	p=&amp;b;//指针的指向不能改</span></span><br><span class="line">	cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const既修饰常量又修饰指针：指针的指向不能改，指针指向的值也不能改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	const既修饰常量又修饰指针：指针的指向不能改，指针指向的值也不能改</span></span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p=&amp;a;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">30</span>;</span><br><span class="line"><span class="comment">//	*p=b; //指向的值不可以改</span></span><br><span class="line"><span class="comment">//	p=&amp;b;//指针的指向不能改</span></span><br><span class="line">	cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	访问数组的第一种方式</span></span><br><span class="line">	<span class="type">int</span> array[<span class="number">10</span>]= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		cout&lt;&lt;array[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;利用指针访问数组元素:&quot;</span>&lt;&lt;endl; </span><br><span class="line">	p=array;</span><br><span class="line"><span class="comment">//	利用指针访问数组元素</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><p>值传递：不会改变实参的值</p>
<p>地址传递（引用传递）：会改变实参的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	指针函数</span></span><br><span class="line"><span class="comment">//	值传递:不改变实参的值</span></span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;交换前:a:&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b:&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">swap</span>(a,b);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;交换后:a:&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b:&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"><span class="comment">//	引用传递：改变实参的值</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;交换前:a:&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b:&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">swap2</span>(&amp;a,&amp;b);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;交换后:a:&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b:&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	temp=a;</span><br><span class="line">	a=b;</span><br><span class="line">	b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	temp=*a;</span><br><span class="line">	*a=*b;</span><br><span class="line">	*b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><blockquote>
<p>属于用户自定义的数据类型</p>
</blockquote>
<p>结构体定义语法：struct 结构体名 {结构体成员列表}；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">people</span> &#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> sex;</span><br><span class="line">&#125; p3;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(people p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	1. struct 结构体名	变量名；</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">people</span> p1;</span><br><span class="line">	p1.name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	p1.age=<span class="number">20</span>;</span><br><span class="line">	p1.sex=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">display</span>(p1);</span><br><span class="line"><span class="comment">//	2. struct 结构体名	变量名=&#123;值1，值2&#125;；</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">people</span> p2= &#123;<span class="string">&quot;李四&quot;</span>,<span class="number">22</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="built_in">display</span>(p2);</span><br><span class="line"><span class="comment">//	3. 定义结构体时顺便创建变量；</span></span><br><span class="line">	p3.name=<span class="string">&quot;王五&quot;</span>;</span><br><span class="line">	p3.age=<span class="number">26</span>;</span><br><span class="line">	p3.sex=<span class="number">3</span>;</span><br><span class="line">	<span class="built_in">display</span>(p3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(people p)</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;name:&quot;</span>&lt;&lt;p.name&lt;&lt;<span class="string">&quot; age:&quot;</span>&lt;&lt;p.age&lt;&lt;<span class="string">&quot; sex:&quot;</span>&lt;&lt;p.sex&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">people</span> &#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	结构体数组定义</span></span><br><span class="line">	people ps[<span class="number">2</span>]= &#123;</span><br><span class="line">		&#123;<span class="string">&quot;刘邦&quot;</span>,<span class="number">200</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;周瑜&quot;</span>,<span class="number">2000</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">//	结构体遍历 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;name:&quot;</span>&lt;&lt;ps[i].name&lt;&lt;<span class="string">&quot; age:&quot;</span>&lt;&lt;ps[i].age&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>作用：通过指针访问结构体中的成员</p>
<p>结构体变量通过.操作符访问，结构体指针通过-&gt;访问结构体成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">people</span> &#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	people p1= &#123;<span class="string">&quot;张三&quot;</span>,<span class="number">100</span>&#125;;</span><br><span class="line">	people *p=&amp;p1;</span><br><span class="line"><span class="comment">//	利用结构体指针进行访问</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;name:&quot;</span>&lt;&lt;p-&gt;name&lt;&lt;<span class="string">&quot; age:&quot;</span>&lt;&lt;p-&gt;age&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存四区"><a href="#内存四区" class="headerlink" title="内存四区"></a>内存四区</h2><h3 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h3><p>用途：存放<strong>函数体的二进制代码</strong>，由操作系统进行管理</p>
<p>代码区是共享的，共享是针对需要频繁执行的程序，只需要在内存中有一份代码即可</p>
<p>代码区是只读的，只读为了防止程序意外修改了指令</p>
<h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>用途：有编译器自动分配释放，存放<strong>函数的参数值、局部变量</strong>等</p>
<h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>用途：由程序员分配和释放，若程序员不分配释放，程序结束时由操作系统回收</p>
<p>使用new关键字进行内存申请，使用delete关键字进行内存释放，数组需要使用delete[]进行释放</p>
<h3 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h3><p>用途：存放<strong>全局变量、静态变量以及常量</strong></p>
<p>包含常量区、字符串常量和其他常量</p>
<p>包括<strong>全局变量、全局常量、静态变量和字符串常量</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//	全局变量</span></span><br><span class="line"><span class="type">int</span> g=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//	全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	局部变量</span></span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;&amp;a=&quot;</span>&lt;&lt;(<span class="type">int</span> *)&amp;a&lt;&lt;<span class="string">&quot; &amp;b=&quot;</span>&lt;&lt;(<span class="type">int</span> *)&amp;b&lt;&lt;endl;</span><br><span class="line"><span class="comment">//	局部常量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c=<span class="number">20</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> d=<span class="number">20</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;&amp;c=&quot;</span>&lt;&lt;(<span class="type">int</span> *)&amp;c&lt;&lt;<span class="string">&quot; &amp;d=&quot;</span>&lt;&lt;(<span class="type">int</span> *)&amp;d&lt;&lt;endl;</span><br><span class="line"><span class="comment">//	静态变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> e=<span class="number">10</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> f=<span class="number">10</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;&amp;e=&quot;</span>&lt;&lt;(<span class="type">int</span> *)&amp;e&lt;&lt;<span class="string">&quot; &amp;f=&quot;</span>&lt;&lt;(<span class="type">int</span> *)&amp;f&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;&amp;g=&quot;</span>&lt;&lt;(<span class="type">int</span> *)&amp;g&lt;&lt;<span class="string">&quot; &amp;h=&quot;</span>&lt;&lt;(<span class="type">int</span> *)&amp;h&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;&amp;i=&quot;</span>&lt;&lt;(<span class="type">int</span> *)&amp;i&lt;&lt;<span class="string">&quot; &amp;j=&quot;</span>&lt;&lt;(<span class="type">int</span> *)&amp;j&lt;&lt;endl;</span><br><span class="line"><span class="comment">//	字符串常量</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;&amp;str=&quot;</span>&lt;&lt;(<span class="type">int</span> *)&amp;<span class="string">&quot;hello world&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-特点"><a href="#C-特点" class="headerlink" title="C++特点"></a>C++特点</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote>
<p>给内存地址取别名，本质是指针常量</p>
</blockquote>
<p>基本语法：数据类型 &amp;别名&#x3D;原名</p>
<p>注意事项：引用必须初始化，一旦初始化不可更改</p>
<p>引用做函数参数：可以简化指针修改实参</p>
<p>引用做函数返回值：可以作为函数左值，但是不要返回局部变量的引用</p>
<p>常引用：可以防止形参改变实参，即变为只读状态</p>
<h3 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h3><p>函数默认参数：返回值类型	函数名（参数&#x3D;默认值）{}，如果某个参数有默认值那么从这个默认值开始从左向右都得有默认值；函数声明有默认值，那么实现就不能有默认值。</p>
<p>函数的占位参数：调用时必须传递实参。</p>
<p>函数重载：同一个作用域，函数名称相同，函数的参数类型不同或者个数不同或者顺序不同；返回值不作为函数重载的条件。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>ex:设计圆类，通过半径求周长</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="comment">//半径</span></span><br><span class="line">		<span class="type">float</span> radius;</span><br><span class="line">		<span class="function"><span class="type">float</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>*PI*radius;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	Circle c;</span><br><span class="line">	c.radius=<span class="number">10</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;圆的周长为：&quot;</span>&lt;&lt;c.<span class="built_in">calc</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问权限：</p>
<table>
<thead>
<tr>
<th>权限类型</th>
<th>类内</th>
<th>类外</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>protected</td>
<td>允许</td>
<td>不允许</td>
</tr>
<tr>
<td>private</td>
<td>允许</td>
<td>不允许</td>
</tr>
</tbody></table>
<p>对于protected儿子可以访问父亲的保护内容</p>
<p>对于private儿子不可以访问父亲的保护内容</p>
<h3 id="对象特性"><a href="#对象特性" class="headerlink" title="对象特性"></a>对象特性</h3><blockquote>
<p>空对象占用1bit的内存空间，编译器会给每个空对象也分配一个字节，是为了区分空对象的位置</p>
</blockquote>
<h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p>不提供构造函数和析构函数，编译器会默认提供空实现的构造函数和析构函数。</p>
<p>构造函数（进行初始化操作）：类名（）{}</p>
<p>构造函数的分类：</p>
<ol>
<li>有参构造和无参构造</li>
<li>普通构造和拷贝构造</li>
</ol>
<p>调用方法：</p>
<ol>
<li>括号法：调用无参构造函数时别带小括号，否则编译器会认为是函数的声明</li>
<li>显示法：不能用拷贝构造函数初始化匿名对象，编译器会默认忽视小括号，从而造成重定义</li>
<li>隐式法</li>
</ol>
<p>调用规则：</p>
<ol>
<li>如果用户自定义有参构造函数，C++就不再提供默认无参构造函数，但是会提供默认拷贝构造函数</li>
<li>如果用户自定义拷贝构造函数，C++不在提供其他构造函数</li>
</ol>
<p>析构函数（进行销毁操作）：~类名（）{}</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Man</span>() &#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;无参构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Man</span>(string name) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;有参构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Man</span>(<span class="type">const</span> Man &amp;m) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;name=m.name;</span><br><span class="line">			<span class="keyword">this</span>-&gt;age=m.age;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;拷贝构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">Man</span>() &#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string name;</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		调用方式:</span></span><br><span class="line"><span class="comment">		括号法</span></span><br><span class="line"><span class="comment">		显示法</span></span><br><span class="line"><span class="comment">		隐式法</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="comment">//	方式一:括号法</span></span><br><span class="line">	Man m;</span><br><span class="line">	<span class="function">Man <span class="title">m1</span><span class="params">(<span class="string">&quot;张三&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">Man <span class="title">m2</span><span class="params">(m1)</span></span>;</span><br><span class="line">	<span class="comment">/*注意：调用无参构造函数时别带小括号，这一点可Java有所不同，</span></span><br><span class="line"><span class="comment">			同时使用this-&gt;而不是this.*/</span></span><br><span class="line"><span class="comment">//	方式二：显示法</span></span><br><span class="line">	Man m3=<span class="built_in">Man</span>();</span><br><span class="line">	Man m4=<span class="built_in">Man</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">	Man m5=<span class="built_in">Man</span>(m4);</span><br><span class="line"><span class="comment">//	匿名对象</span></span><br><span class="line">	<span class="built_in">Man</span>(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">	<span class="comment">/*不能用拷贝构造函数初始化匿名对象</span></span><br><span class="line"><span class="comment">	Man(m5)==Man m5,编译器会忽略小括号</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="comment">//	方式三：隐式法</span></span><br><span class="line">	Man m6=m5;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝构造函数的作用：</p>
<ol>
<li>使用一个已经创建完毕的对象来初始化新对象</li>
<li>值传递的方式传参</li>
<li>值方式返回局部对象</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">People</span>() &#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;默认构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">People</span>(string name,<span class="type">int</span> age) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">			<span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;有参构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">People</span>(<span class="type">const</span> People &amp;p) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;name=p.name;</span><br><span class="line">			<span class="keyword">this</span>-&gt;age=p.age;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;拷贝构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		string name;</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(People p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">People <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">People <span class="title">p</span><span class="params">(<span class="string">&quot;王五&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	方式一：用一个已经创建好的对象来初始化新对象</span></span><br><span class="line"><span class="comment">//	People p(&quot;张三&quot;,18);</span></span><br><span class="line"><span class="comment">//	People p1(p);</span></span><br><span class="line"><span class="comment">//	方式二：用于函数传参</span></span><br><span class="line"><span class="comment">//	test(p);</span></span><br><span class="line"><span class="comment">//	方式三：用于返回局部对象</span></span><br><span class="line">	People p1=<span class="built_in">test1</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;name:&quot;</span>&lt;&lt;p1.name&lt;&lt;<span class="string">&quot; age:&quot;</span>&lt;&lt;p1.age&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p>浅拷贝：简单的赋值操作，会导致内存重复释放</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">People</span>() &#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;无参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">People</span>(string name,<span class="type">int</span> age,<span class="type">int</span> height) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">			<span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">			<span class="keyword">this</span>-&gt;height=<span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;有参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">People</span>(<span class="type">const</span> People &amp;p) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;name=p.name;</span><br><span class="line">			<span class="keyword">this</span>-&gt;age=p.age;</span><br><span class="line"><span class="comment">//			this-&gt;height=p.height;//为了解决浅拷贝所带来的内存重复释放的问题，在拷贝时主动向堆区申请一块内存空间</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;height=<span class="keyword">new</span> <span class="built_in">int</span>(*p.height);<span class="comment">//此语句解决浅拷贝所带的问题 </span></span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">People</span>() &#123;</span><br><span class="line">			<span class="keyword">if</span>(height!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">delete</span> height;</span><br><span class="line">				height=<span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		string name;<span class="comment">//姓名</span></span><br><span class="line">		<span class="type">int</span> age;<span class="comment">//年龄</span></span><br><span class="line">		<span class="type">int</span> *height;<span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="function">People <span class="title">p</span><span class="params">(<span class="string">&quot;张胜男&quot;</span>,<span class="number">18</span>,<span class="number">170</span>)</span></span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;name:&quot;</span>&lt;&lt;p.name&lt;&lt;<span class="string">&quot; age:&quot;</span>&lt;&lt;p.age&lt;&lt;<span class="string">&quot; height:&quot;</span>&lt;&lt;*p.height&lt;&lt;endl;</span><br><span class="line">	<span class="function">People <span class="title">p1</span><span class="params">(p)</span></span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;name:&quot;</span>&lt;&lt;p1.name&lt;&lt;<span class="string">&quot; age:&quot;</span>&lt;&lt;p1.age&lt;&lt;<span class="string">&quot; height:&quot;</span>&lt;&lt;*p1.height&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">People</span>(<span class="type">int</span> age,<span class="type">int</span> sex):<span class="built_in">age</span>(age),<span class="built_in">sex</span>(sex)&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		<span class="type">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="function">People <span class="title">p</span><span class="params">(<span class="number">18</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><ul>
<li><p>静态成员变量</p>
<ul>
<li>所有对象共享一份数据</li>
<li>在编译阶段分配内存</li>
<li><code>类内声明，类外初始化</code></li>
</ul>
</li>
<li><p>静态成员函数：可以通过对象或类名访问</p>
<ul>
<li>所有对象共享同一个函数</li>
<li><code>静态成员函数只能访问静态成员变量</code>，不能访问非静态成员变量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">People</span>() &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">People</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> sex;</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;性别是:&quot;</span>&lt;&lt;sex&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  类外初始化</span></span><br><span class="line"><span class="type">int</span> People::sex=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	方式一：对象名</span></span><br><span class="line">	<span class="function">People <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//	方式二：类名</span></span><br><span class="line">	People::<span class="built_in">func</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="this指针与空指针"><a href="#this指针与空指针" class="headerlink" title="this指针与空指针"></a>this指针与空指针</h4><p>this的用途：解决命名冲突和制造链式调用</p>
<p>空指针也能访问成员函数，需要加以判断保证代码的健壮性</p>
<h4 id="常函数和常对象"><a href="#常函数和常对象" class="headerlink" title="常函数和常对象"></a>常函数和常对象</h4><ol>
<li>常函数内不可以修改成员属性</li>
<li>成员属性加mutable后就可以修改属性</li>
</ol>
<p>常对象只能调用常函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">People</span>(<span class="type">int</span> age,<span class="type">int</span> sex) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">			<span class="keyword">this</span>-sex=sex;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		常函数 ，加const后实际上修饰的是this，则this指向的内容也不可以改 </span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;age:&quot;</span>&lt;&lt;age&lt;&lt;<span class="string">&quot; sex:&quot;</span>&lt;&lt;sex&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		<span class="type">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"><span class="comment">//	告诉编译器goodBrother是People的友元函数，可以访问People的private变量</span></span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodBrother</span><span class="params">(People &amp;p)</span></span>;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">People</span>() &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;sitroom=<span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;bedroom=<span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		string sitroom;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodBrother</span><span class="params">(People &amp;p)</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;好兄弟正在进入你的&quot;</span>&lt;&lt;p.sitroom&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;好兄弟正在进入你的&quot;</span>&lt;&lt;p.bedroom&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	People p;</span><br><span class="line">	<span class="built_in">goodBrother</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Brother</span> &#123;</span><br><span class="line"><span class="comment">//		声明People是Brother的友元类</span></span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">People</span>;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Brother</span>() &#123;</span><br><span class="line">			wc=<span class="string">&quot;厕所&quot;</span>;</span><br><span class="line">			bathroom=<span class="string">&quot;浴室&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		string wc;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string bathroom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">People</span>() &#123;</span><br><span class="line">			sittingroom=<span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">			bedroom=<span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		string sittingroom;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(Brother &amp;b)</span> </span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;正在访问好兄弟的&quot;</span>&lt;&lt;b.bathroom&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	Brother b;</span><br><span class="line">	People p;</span><br><span class="line">	p.<span class="built_in">visit</span>(b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//成员函数做友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGay</span>();</span><br><span class="line">    ~<span class="built_in">GoodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">// 让 visit 访问Building中的私有函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;<span class="comment">// 让 visit2 不可以访问Building中的私有函数</span></span><br><span class="line">    Building *building;<span class="comment">//指向对象的指针，在构造函数中要初始化指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//GoodGay类下的visit成员函数作为本类的好朋友，可以访问私有成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个建筑物的对象</span></span><br><span class="line">    <span class="comment">//用new再堆区中申请一片空间返回的是一个指针，用building来接受这个指针，完成building初始化</span></span><br><span class="line">    building = <span class="keyword">new</span> Building; </span><br><span class="line">&#125;</span><br><span class="line">GoodGay::~<span class="built_in">GoodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> building;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;visit函数: Public &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;visit函数: Private &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;visit2函数: Public &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//visit2函数不是Building的友元函数，不能访问其私有变量m_BedRoom</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GoodGay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line">    gg.<span class="built_in">visit2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h4 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h4><p>成员函数重载+运算符和全局函数重载+运算符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//	加号运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Number</span>() &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Number</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;num=n;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		成员函数重载+</span></span><br><span class="line"><span class="comment">//		Number operator+(Number &amp;n) &#123;</span></span><br><span class="line"><span class="comment">//			Number temp;</span></span><br><span class="line"><span class="comment">//			temp.num=this-&gt;num+n.num;</span></span><br><span class="line"><span class="comment">//			return temp;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//	全局函数重载+</span></span><br><span class="line">Number <span class="keyword">operator</span>+(Number &amp;n1,Number &amp;n2) &#123;</span><br><span class="line">	Number n3;</span><br><span class="line">	n3.num= n1.num+n2.num;</span><br><span class="line">	<span class="keyword">return</span> n3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="function">Number <span class="title">n</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Number <span class="title">n1</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">	Number n2=n+n1;</span><br><span class="line">	cout&lt;&lt;n2.num&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h4><p>只能利用全局函数重载左移运算符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//左移运算符重载&lt;&lt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="comment">//	如果数据私有可以使用友元</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Number</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;num=n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//	全局函数重载&lt;&lt;运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,Number &amp;n) &#123;</span><br><span class="line">	cout&lt;&lt;n.num;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="function">Number <span class="title">n1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout&lt;&lt;n1&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h4><p>前置++运算符重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="built_in">Number</span>() &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Number</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;num=num;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> num;</span><br><span class="line"><span class="comment">//		前置++重载</span></span><br><span class="line">		Number&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">			++num;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,Number n) &#123;</span><br><span class="line">	cout&lt;&lt;n.num;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="function">Number <span class="title">n</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout&lt;&lt;++(++n)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后置++运算符重载</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">		<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,Number n);</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="built_in">Number</span>() &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Number</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;num=num;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		前置++重载</span></span><br><span class="line">		Number&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">			++num;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		后置 ++重载</span></span><br><span class="line">		Number <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">			Number temp=*<span class="keyword">this</span>;</span><br><span class="line">			num++;</span><br><span class="line">			<span class="keyword">return</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,Number n) &#123;</span><br><span class="line">	cout&lt;&lt;n.num;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="function">Number <span class="title">n</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout&lt;&lt;n++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">People</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">			p_age=<span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">People</span>() &#123;</span><br><span class="line">			<span class="keyword">if</span>(p_age!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">delete</span> p_age;</span><br><span class="line">				p_age=<span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		=运算符重载</span></span><br><span class="line">		People&amp; <span class="keyword">operator</span>=(People &amp;p) &#123;</span><br><span class="line"><span class="comment">//			如果自身有内存先释放干净</span></span><br><span class="line">			<span class="keyword">if</span>(p_age!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">delete</span> p_age;</span><br><span class="line">				p_age=<span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>-&gt;p_age= <span class="keyword">new</span> <span class="built_in">int</span>(*p.p_age);</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> *p_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="function">People <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">People <span class="title">p2</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	p2=p1;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;age:&quot;</span>&lt;&lt;*p2.p_age&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Person</span>() &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//	关系运算符重载</span></span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp;p) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p.age==<span class="keyword">this</span>-&gt;age) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,Person &amp;p) &#123;</span><br><span class="line">	cout&lt;&lt;p.age;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(p==p1) &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;相等&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h4><p>又称为仿函数，写法很灵活</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Print</span>() &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string valueString)</span> </span>&#123;</span><br><span class="line">			cout&lt;&lt;valueString&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	Print print;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>用处：去重，减少冗余</p>
<blockquote>
<p>语法:class 派生类：继承方式 	父类</p>
</blockquote>
<p>三种继承方式：（父类中的私有属性，子类无论哪种继承都访问不到）</p>
<ol>
<li>公共继承：父类的public和protected属性保持不变，私有属性访问不到</li>
<li>保护继承：父类的public和protected属性变为子类的protected属性，私有属性访问不到</li>
<li>私有继承：父类的public和protected属性变为子类的private属性，私有属性访问不到</li>
</ol>
<p><strong>父类中所有的非静态成员属性都会被子类继承下去，只是私有属性被编译器隐藏了，所以访问不到</strong></p>
<p>查看对象模型：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cl /dl reportSingleClassLayout类名 文件名</span><br></pre></td></tr></table></figure>

<h4 id="继承中的构造和析构的顺序"><a href="#继承中的构造和析构的顺序" class="headerlink" title="继承中的构造和析构的顺序"></a>继承中的构造和析构的顺序</h4><p>析构顺序与构造顺序相反</p>
<p>父类构造-&gt;子类构造-&gt;子类析构-&gt;父类析构</p>
<h4 id="子类继承访问同名成员的处理"><a href="#子类继承访问同名成员的处理" class="headerlink" title="子类继承访问同名成员的处理"></a>子类继承访问同名成员的处理</h4><ol>
<li>访问子类同名成员，直接访问即可</li>
<li>访问父类同名成员，加作用域即可</li>
<li>子类出现和父类同名的成员，子类会隐藏父类所有的同名成员函数</li>
</ol>
<h4 id="子类继承访问静态成员的处理"><a href="#子类继承访问静态成员的处理" class="headerlink" title="子类继承访问静态成员的处理"></a>子类继承访问静态成员的处理</h4><p>两种访问方式：对象名和类名</p>
<ol>
<li>访问子类同名成员，直接访问即可</li>
<li>访问父类同名成员，加作用域即可</li>
<li>子类出现和父类同名的静态成员，子类会隐藏父类所有的同名静态成员函数</li>
</ol>
<h4 id="多继承（不建议使用）"><a href="#多继承（不建议使用）" class="headerlink" title="多继承（不建议使用）"></a>多继承（不建议使用）</h4><blockquote>
<p>语法：class	子类：继承方式	父类1，继承方式	父类2</p>
</blockquote>
<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>概念：两个类继承一个基类，又有一个类继承这两个派生类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="comment">//通过使用virtual关键字解决菱形继承问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//羊类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//驼类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//羊驼类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span>:<span class="keyword">public</span> Sheep,<span class="keyword">public</span> Tuo &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Tuo::age=<span class="number">28</span>;</span><br><span class="line">	st.Sheep::age=<span class="number">18</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;st.Sheep::age:&quot;</span>&lt;&lt;st.Sheep::age&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;st.Tuo::age:&quot;</span>&lt;&lt;st.Tuo::age&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;st.age:&quot;</span>&lt;&lt;st.age&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ol>
<li>静态多态：函数重载和运算符重载，编译阶段确定函数地址，地址早绑定</li>
<li>动态多态：派生类和虚函数，运行阶段确定函数地址，地址晚绑定</li>
</ol>
<h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//		此刻地址早绑定</span></span><br><span class="line"><span class="comment">//		void speak() &#123;</span></span><br><span class="line"><span class="comment">//			cout&lt;&lt;&quot;动物在说话&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		加virtual变成虚函数地址晚绑定</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span>	<span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;动物在说话&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="keyword">public</span> Animal &#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;喵喵~~&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:<span class="keyword">public</span> Animal  &#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;汪汪~~&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	Dog dog;</span><br><span class="line"><span class="comment">//	Animal &amp;animal=cat;</span></span><br><span class="line">	Animal &amp;animal=dog;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>有纯虚函数的类称为抽象类</p>
<p>语法：virtual 返回值类型	函数名（参数列表）&#x3D;0；</p>
<p>抽象类特点：</p>
<ol>
<li>无法实例化</li>
<li>子类必须重写抽象类的纯虚函数，否则子类也属于抽象类</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//		变成纯虚函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span>	<span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="keyword">public</span> Animal &#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;喵喵~~&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:<span class="keyword">public</span> Animal  &#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;汪汪~~&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	Dog dog;</span><br><span class="line"><span class="comment">//	Animal &amp;animal=cat;</span></span><br><span class="line">	Animal &amp;animal=dog;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p>有纯虚析构的类也称为抽象类</p>
<blockquote>
<p>用处：如果子类属性开辟到堆区，那么父类指针在释放时无法调用子类的析构代码</p>
</blockquote>
<p>虚析构语法：virtual ~类名（）{}</p>
<p>纯虚析构：virtual ~类名（）&#x3D;0；必须要有具体实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Animal</span>() &#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Animal构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		利用虚析构</span></span><br><span class="line"><span class="comment">//		virtual ~Animal() &#123;</span></span><br><span class="line"><span class="comment">//			cout&lt;&lt;&quot;Animal析构函数调用&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		利用纯虚析构</span></span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>()=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="keyword">public</span> Animal &#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="built_in">Cat</span>() &#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Cat构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Cat</span>(string name) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;name=<span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Cat有参构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">			<span class="keyword">if</span>(name!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">delete</span> name;</span><br><span class="line">				name=<span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Cat析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		string *name;</span><br><span class="line">&#125;;</span><br><span class="line">Animal::~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Animal析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	Animal *animal=<span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-泛型编程"><a href="#C-泛型编程" class="headerlink" title="C++泛型编程"></a>C++泛型编程</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><blockquote>
<p>用途：提高复用性</p>
</blockquote>
<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>语法：template<typename T>，typename可以用class代替</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//利用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span> </span>&#123;</span><br><span class="line">	T temp;</span><br><span class="line">	temp=a;</span><br><span class="line">	a=b;</span><br><span class="line">	b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line">	<span class="type">float</span> c=<span class="number">10.9</span>,d=<span class="number">10.6</span>;</span><br><span class="line">	<span class="built_in">Swap</span>(a,b);</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;<span class="string">&quot; ,&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">Swap</span>(c,d);</span><br><span class="line">	cout&lt;&lt;c&lt;&lt;<span class="string">&quot; ,&quot;</span>&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="普通函数与模板函数的区别"><a href="#普通函数与模板函数的区别" class="headerlink" title="普通函数与模板函数的区别"></a>普通函数与模板函数的区别</h5><ul>
<li>普通函数可以自动类型转换</li>
<li>函数模板如果使用自动类型，不会发生自动类型转换</li>
<li>函数模板如果使用指定类型，会发生自动类型转换</li>
</ul>
<h5 id="普通函数与模板函数的调用规则"><a href="#普通函数与模板函数的调用规则" class="headerlink" title="普通函数与模板函数的调用规则"></a>普通函数与模板函数的调用规则</h5><ol>
<li>函数模板和普通函数都可以，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以重载</li>
<li>如果函数模板能更好匹配，优先调用函数模板</li>
</ol>
<h5 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h5><p>对于数组和对象来说，可以使用template&lt;&gt;重写一个模板具体实现</p>
<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">NameType</span>,<span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">People</span>(NameType name,AgeType age) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">			<span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">		&#125;</span><br><span class="line">		NameType name;</span><br><span class="line">		AgeType age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="function">People&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">	cout&lt;&lt;p.name&lt;&lt;p.age&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类模板的成员函数的创建时机"><a href="#类模板的成员函数的创建时机" class="headerlink" title="类模板的成员函数的创建时机"></a>类模板的成员函数的创建时机</h5><p>类模板中成员函数只在调用时才去创建</p>
<h5 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h5><p>传入方式</p>
<ol>
<li>指定传入方式</li>
<li>参数模板化</li>
<li>整个类模板化</li>
</ol>
<h5 id="类模板继承"><a href="#类模板继承" class="headerlink" title="类模板继承"></a>类模板继承</h5><ol>
<li>当子类继承父类是一个类模板时，子类在声明时，要指出父类中的数据类型</li>
<li>不指定，编译器无法给子类分配内存</li>
<li>如果要灵活支出父类中的数据类型，子类也要变成类模板</li>
</ol>
<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><blockquote>
<p>查阅API即可，深入理解阅读《STL源码剖析》</p>
</blockquote>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><blockquote>
<p>string本质上是一个类，内部封装了char *,是一个char *的容器</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	string str=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *ch=<span class="string">&quot;china&quot;</span>;</span><br><span class="line">	<span class="function">string  <span class="title">str1</span><span class="params">(ch)</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">str2</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">	str+=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">	cout&lt;&lt;str&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str2&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><blockquote>
<p>功能：类似数组，又称为单端数组，可以动态扩展（找更大的内存空间，将数据拷贝，释放原空间）</p>
</blockquote>
<h6 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	vector容器，类似于数组</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itBegin=v.<span class="built_in">begin</span>();<span class="comment">//起始迭代器，指向容器中第一个元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd=v.<span class="built_in">end</span>();<span class="comment">//结束迭代器，指向容器中最后一个元素的下一个位置</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;while循环遍历&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">while</span>(itBegin!=itEnd) &#123;</span><br><span class="line">		cout&lt;&lt;*itBegin&lt;&lt;endl;</span><br><span class="line">		itBegin++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;for循环遍历&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=v.<span class="built_in">begin</span>(); it!=v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;stl遍历算法&quot;</span>&lt;&lt;endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),print);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="vector存放自定义数据类型"><a href="#vector存放自定义数据类型" class="headerlink" title="vector存放自定义数据类型"></a>vector存放自定义数据类型</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">People</span>(string name,<span class="type">int</span> age) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">			<span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">		&#125;</span><br><span class="line">		string name;</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="function">People <span class="title">p1</span><span class="params">(<span class="string">&quot;李白&quot;</span>,<span class="number">2000</span>)</span></span>;</span><br><span class="line">	<span class="function">People <span class="title">p2</span><span class="params">(<span class="string">&quot;达摩&quot;</span>,<span class="number">1000</span>)</span></span>;</span><br><span class="line">	<span class="function">People <span class="title">p3</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>,<span class="number">900</span>)</span></span>;</span><br><span class="line">	<span class="function">People <span class="title">p4</span><span class="params">(<span class="string">&quot;公孙离&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">People <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>,<span class="number">200</span>)</span></span>;</span><br><span class="line">	vector&lt;People&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">	vector&lt;People*&gt; v1;</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line">	<span class="keyword">for</span>(vector&lt;People&gt;::iterator it=v.<span class="built_in">begin</span>(); it!=v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;it-&gt;name&lt;&lt;<span class="string">&quot; 年龄：&quot;</span>&lt;&lt;it-&gt;age&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;遍历自定义数据类型指针&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(vector&lt;People*&gt;::iterator it=v1.<span class="built_in">begin</span>(); it!=v1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;(*it)-&gt;name&lt;&lt;<span class="string">&quot; 年龄：&quot;</span>&lt;&lt;(*it)-&gt;age&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="vector容器嵌套"><a href="#vector容器嵌套" class="headerlink" title="vector容器嵌套"></a>vector容器嵌套</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//vector容器嵌套</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">		v3.<span class="built_in">push_back</span>(i+<span class="number">2</span>);</span><br><span class="line">		v4.<span class="built_in">push_back</span>(i+<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v4);</span><br><span class="line">	<span class="keyword">for</span>(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;::iterator it=v.<span class="built_in">begin</span>(); it!=v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator vit=(*it).<span class="built_in">begin</span>(); vit!=(*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">			cout&lt;&lt;*vit&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="vector容器插入和删除"><a href="#vector容器插入和删除" class="headerlink" title="vector容器插入和删除"></a>vector容器插入和删除</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=v.<span class="built_in">begin</span>(); it!=v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">	v.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">	v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(),<span class="number">60</span>);</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">	v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">	v.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h5><p>双端数组，可以对头端进行插入和删除</p>
<h5 id="Stack（栈）：没啥可说的"><a href="#Stack（栈）：没啥可说的" class="headerlink" title="Stack（栈）：没啥可说的"></a>Stack（栈）：没啥可说的</h5><h5 id="Queue（队列）：没啥可说的"><a href="#Queue（队列）：没啥可说的" class="headerlink" title="Queue（队列）：没啥可说的"></a>Queue（队列）：没啥可说的</h5><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>注意：list不支持随机存取，所以没有[]和at的访问方式</p>
<h5 id="Set和Multiser"><a href="#Set和Multiser" class="headerlink" title="Set和Multiser"></a>Set和Multiser</h5><p>set结构会自动排序，底层是二叉树</p>
<ul>
<li>set中不允许有重复的值</li>
<li>multiset允许有重复的值</li>
</ul>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>map中所以元素都是pair,底层为二叉树，可以根据key快速找到value</p>
<ul>
<li>map中不允许有重复key值元素</li>
<li>multimap中允许有重复key值元素</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习</title>
    <url>/2022/06/19/Git/</url>
    <content><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><blockquote>
<p>学习git这一种主流的版本控制系统</p>
</blockquote>
<h2 id="什么是”版本控制”？"><a href="#什么是”版本控制”？" class="headerlink" title="什么是”版本控制”？"></a>什么是”版本控制”？</h2><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<span id="more"></span>

<h2 id="git的三种状态"><a href="#git的三种状态" class="headerlink" title="git的三种状态"></a>git的三种状态</h2><h3 id="已提交：commited"><a href="#已提交：commited" class="headerlink" title="已提交：commited"></a>已提交：commited</h3><p>已提交表示数据已经安全的保存在本地数据库中。</p>
<h3 id="已修改：modified"><a href="#已修改：modified" class="headerlink" title="已修改：modified"></a>已修改：modified</h3><p>已修改表示修改了文件，但还没保存到数据库中。</p>
<h3 id="已暂存：staged"><a href="#已暂存：staged" class="headerlink" title="已暂存：staged"></a>已暂存：staged</h3><p>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p>
<h2 id="git的三个工作区"><a href="#git的三个工作区" class="headerlink" title="git的三个工作区"></a>git的三个工作区</h2><p><img data-src="https://s1.ax1x.com/2022/06/19/XjBi0x.png" alt="git的三个工作区"></p>
<h3 id="git仓库"><a href="#git仓库" class="headerlink" title="git仓库"></a>git仓库</h3><p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，其它计算机克隆仓库时，拷贝的就是这里的数据。</p>
<h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><p>工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p>
<h3 id="暂存区域"><a href="#暂存区域" class="headerlink" title="暂存区域"></a>暂存区域</h3><p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作”索引”，不过一般说法还是叫暂存区域。</p>
<h3 id="基本的-Git-工作流程"><a href="#基本的-Git-工作流程" class="headerlink" title="基本的 Git 工作流程"></a>基本的 Git 工作流程</h3><ol>
<li><p>在工作目录中修改文件。</p>
</li>
<li><p>暂存文件，将文件的快照放入暂存区域。</p>
</li>
<li><p>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</p>
</li>
</ol>
<h2 id="git的安装"><a href="#git的安装" class="headerlink" title="git的安装"></a>git的安装</h2><h3 id="Linux上安装"><a href="#Linux上安装" class="headerlink" title="Linux上安装"></a>Linux上安装</h3><p>以Fedora 上为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install git</span><br></pre></td></tr></table></figure>

<p>如果你在基于 Debian 的发行版上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<h3 id="Mac上安装"><a href="#Mac上安装" class="headerlink" title="Mac上安装"></a>Mac上安装</h3><p>最简单的方法是安装 Xcode或者<a href="https://git-scm.com/">git官网</a> 下载二进制文件安装</p>
<h3 id="Windows上安装"><a href="#Windows上安装" class="headerlink" title="Windows上安装"></a>Windows上安装</h3><p>在 Windows 上安装 Git 也有几种安装方法。官方版本可以在 Git 官方网站下载。</p>
<h3 id="从源代码安装"><a href="#从源代码安装" class="headerlink" title="从源代码安装"></a>从源代码安装</h3><p>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。</p>
<p>如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装Git的二进制版：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</span><br><span class="line">sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext  libz-dev libssl-dev</span><br></pre></td></tr></table></figure>

<p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install asciidoc xmlto docbook2x</span><br><span class="line">sudo apt-get install asciidoc xmlto docbook2x</span><br></pre></td></tr></table></figure>

<p>从 GitHub 网站上的镜像来获得最新发布版本的 tar 包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxf git-2.0.0.tar.gz</span><br><span class="line">cd git-2.0.0</span><br><span class="line"> make configure</span><br><span class="line"> ./configure --prefix=/usr</span><br><span class="line"> make all doc info</span><br><span class="line"> sudo make install install-doc install-html install-info</span><br></pre></td></tr></table></figure>

<h2 id="git的配置"><a href="#git的配置" class="headerlink" title="git的配置"></a>git的配置</h2><h3 id="初次启动（配置环境变量）"><a href="#初次启动（配置环境变量）" class="headerlink" title="初次启动（配置环境变量）"></a>初次启动（配置环境变量）</h3><p>对于Linux系统，Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。这些变量存储在三个不同的位置：</p>
<ol>
<li><strong>&#x2F;etc&#x2F;gitconfig</strong> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的git config 时，它会从此文件读写配置变量。</li>
<li>~&#x2F;.gitconfig 或 ~&#x2F;.config&#x2F;git&#x2F;config 文件：只针对当前用户。 可以传递 –global 选项让 Git读写此文件。</li>
<li>当前使用仓库的 Git 目录中的 config 文件（就是 .git&#x2F;config）：针对该仓库。</li>
</ol>
<p>每一个级别覆盖上一级别的配置，所以 .git&#x2F;config 的配置变量会覆盖 &#x2F;etc&#x2F;gitconfig 中的配置变量。</p>
<p>对于windows系统，Git 会查找 $HOME$ 目录下（一般情况下是 C:\Users\$USER$）的 .gitconfig 文件。</p>
<h3 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h3><p>每一次 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Mr.W&quot;	#配置用户名</span><br><span class="line">git config --global user.email xxxxxxxx@qq.com	#配置邮箱</span><br></pre></td></tr></table></figure>

<p>使用–global代表全局设置，该命令只需要运行一次，之后无论你在该系统上做任何事情， Git 都会使用这些信息。</p>
<p>当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行不带 –global 选项的命令来配置。</p>
<h3 id="指定文本编辑器"><a href="#指定文本编辑器" class="headerlink" title="指定文本编辑器"></a>指定文本编辑器</h3><p>Git 会使用操作系统默认的文本编辑器，通常是 Vim。如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global core.editor emacs</span><br></pre></td></tr></table></figure>

<h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<p>可以通过输入 git config  <key>： 来检查 Git 的某一项配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure>

<h3 id="获取帮助手册"><a href="#获取帮助手册" class="headerlink" title="获取帮助手册"></a>获取帮助手册</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git help &lt;verb&gt; #方式一</span><br><span class="line">git &lt;verb&gt; --help #方式二</span><br><span class="line">man git-&lt;verb&gt; #在linux上可以方式三</span><br></pre></td></tr></table></figure>

<h2 id="git基础"><a href="#git基础" class="headerlink" title="git基础"></a>git基础</h2><h3 id="获取git仓库"><a href="#获取git仓库" class="headerlink" title="获取git仓库"></a>获取git仓库</h3><ol>
<li>在现有项目或目录下导入所有文件到 Git 中</li>
<li>从一个服务器克隆一个现有的 Git 仓库</li>
</ol>
<h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><p>进入该项目目录并输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是Git 仓库的核心。</p>
<p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。你可通过 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add *.c</span><br><span class="line">git add LICENSE</span><br><span class="line">git commit -m &#x27;initial project version&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令。当执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone [url]</span><br></pre></td></tr></table></figure>

<p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone [url] 本地仓库的名字</span><br></pre></td></tr></table></figure>

<p>经常报错: <code>OpenSSL SSL_read: Connection was reset, errno 10054</code>解决方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>

<p>Git 支持多种数据传输协议。上面的例子使用的是 https:&#x2F;&#x2F; 协议，不过你也可以使用 git:&#x2F;&#x2F; 协议或者使用SSH 传输协议，比如 user@server:path&#x2F;to&#x2F;repo.git </p>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。<strong>已跟踪的文件</strong>是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放 入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于<strong>未跟踪文件</strong>，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p>
<p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。使用 Git 时文件的生命周期如下：</p>
<p><img data-src="https://s1.ax1x.com/2022/06/19/XjBF76.png" alt="记录每次更新到仓库"></p>
<h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>要查看哪些文件处于什么状态，可以用 git status 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息 还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是 “master”,这是默认的分支名。</p>
<h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令 git add 开始跟踪一个文件。所以，要跟踪 <code>README</code> 文件，运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure>

<p>此时再运行 git status 命令，会看到 <code>README</code> 文件已被跟踪，并处于暂存状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    new file: README</span><br></pre></td></tr></table></figure>

<p>只要在 Changes to be committed 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。</p>
<h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><p>现在我们来修改一个已被跟踪的文件。如果你修改了一个名为 Git.md 的已被跟踪的文件，然后运行 git status 命令，会看到下面内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line">No commits yet</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   Git.md</span><br><span class="line">        new file:   README</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   Git.md</span><br></pre></td></tr></table></figure>

<p>文件 <code>Git.md</code> 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。</p>
<p>要暂存这次更新，需要运行 git add 命令。这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add Git.md</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">No commits yet</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   Git.md</span><br><span class="line">        new file:   README</span><br></pre></td></tr></table></figure>

<p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。假设此时，你想要在 CONTRIBUTING.md 里再加条注释，重新编辑存盘后，准备好提交。不过且慢，再运行 git status 看看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line">No commits yet</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   Git.md</span><br><span class="line">        new file:   README</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   Git.md</span><br></pre></td></tr></table></figure>

<p>现在 <code>Git.md</code> 文件同时出现在暂存区和非暂存区。实际上 Git 只不过暂存了你运行 git add 命令时的版本，如果你现在提交，<code>Git.md</code> 的版本是你最后一次运行git add 命令时的那个版本，而不是你运行 git commit 时，在工作目录中的当前版本。所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add Git.md</span><br><span class="line">git status </span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">No commits yet</span><br><span class="line">Changes to be committed:</span><br><span class="line"> (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">       new file:   Git.md</span><br><span class="line">       new file:   README</span><br></pre></td></tr></table></figure>

<h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p>git status 命令的输出十分详细，但其用语有些繁琐。如果你使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git status -s</span><br><span class="line"></span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A lib/git.rb</span><br><span class="line">M lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure>

<p>新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。例如，上面的状态报告显示： <code>README</code> 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,<code>lib/simplegit.rb</code> 文件被修改了并将修改后的文件放入了暂存区。而<code>Rakefile</code> 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p>
<h3 id="忽略文件-gitignore"><a href="#忽略文件-gitignore" class="headerlink" title="忽略文件(.gitignore)"></a>忽略文件(<code>.gitignore</code>)</h3><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文 件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为 <code>.gitignore</code>的文件，列出要忽略的文件模式。来看一个实际的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat .gitignore</span><br><span class="line"></span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure>

<p>文件 <code>.gitignore</code> 的格式规范如下： </p>
<ul>
<li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。 </li>
<li>可以使用标准的 glob 模式匹配。 </li>
<li>匹配模式可以以<code>/</code>开头防止递归。 </li>
<li>匹配模式可以以<code>/</code>结尾指定目录。 </li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号<code>*</code>匹配零个或多个任意字符；<code>[abc]</code> 匹配任 何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号<code>?</code>只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。使用两个星号<code>**</code> 表示匹配任意中间目录，比如<code>a/**/z</code> 可以匹配 <code>a/z</code>,<code>a/b/z</code> 或 <code>a/b/c/z</code>等。</p>
<h3 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h3><p>如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。git diff 将通过文件补丁的格式显示具体哪些行发生了改变。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff</span><br><span class="line"></span><br><span class="line">warning: LF will be replaced by CRLF in Git.md.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">diff --git a/Git.md b/Git.md</span><br><span class="line">index b49f414..661e036 100644</span><br><span class="line">--- a/Git.md</span><br><span class="line">+++ b/Git.md</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> Git Test</span><br><span class="line"> Modified</span><br><span class="line"> Second Modified</span><br><span class="line">+Third Modified</span><br></pre></td></tr></table></figure>

<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以使用 git diff –staged</p>
<h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>现在的暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>

<p>默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。如果想要更详细的对修改了哪些内容的提示，可以用 -v 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。</p>
<p>另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;git second commit&quot;</span><br></pre></td></tr></table></figure>

<h4 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h4><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -a -m <span class="string">&quot;git third commit&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。<code>可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件</code>，这样以后就不会出现在未跟踪文件清单了。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是未暂存清单）看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm README</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        deleted:    README</span><br></pre></td></tr></table></figure>

<p>下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>。这是一种安全特性，用于防止误删还没有添加到快照的数据，<code>这样的数据不能被 git 恢复</code>。</p>
<p>另外一种情况是，<code>我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm --cached test.txt</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line"> (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">       deleted:    test.txt</span><br><span class="line">Untracked files:</span><br><span class="line"> (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">       test.txt</span><br></pre></td></tr></table></figure>

<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git mv Git.md git.md</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        renamed:    Git.md -&gt; git.md</span><br><span class="line">        deleted:    test.txt</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        test.txt</span><br></pre></td></tr></table></figure>

<p>其实，运行 git mv 就相当于运行了下面三条命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv README.md README</span><br><span class="line">git rm README.md</span><br><span class="line">git add README</span><br></pre></td></tr></table></figure>

<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史.完成这个任务最简单而又有效的工具是 git log 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p>默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。</p>
<p>git log 有许多选项可以帮助你搜寻你所要找的提交，接下来我们介绍些最常用的。一个常用的选项是 -p，用来显示每次提交的内容差异。你也可以加上 -2 来仅显示最近两次提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log -p -2</span><br></pre></td></tr></table></figure>

<p>你也可以为 git log 附带一系列的总结性选项。比如说，如果你想看到每次提交的简略的统计信息，你可以使用 –stat 选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure>

<p>另外一个常用的选项是 –pretty。这个选项可以指定使用不同于默认格式的方式展示提交历史。这个选项有一些内建的子选项供你使用。比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。另外还有short，full 和 fuller 可以用，展示的信息或多或少有些不同。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure>

<p>有用的是 format，可以定制要显示的记录格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</span><br></pre></td></tr></table></figure>

<p>git log –pretty&#x3D;format 常用的选项 列出了常用的格式占位符写法及其代表的意义。</p>
<p><img data-src="https://s1.ax1x.com/2022/06/19/XjBEtO.png" alt="git log"></p>
<p>当 oneline 或 format 与另一个 log 选项 –graph 结合使用时尤其有用。这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --pretty=format:&quot;%h %s&quot; --graph</span><br></pre></td></tr></table></figure>

<p>git log 的常用选项:</p>
<p><img data-src="https://s1.ax1x.com/2022/06/19/XjBVhD.png" alt="git log 的常用选项"></p>
<h4 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h4><p>除了定制输出格式的选项之外，git log 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。之前你已经看到过 -2 了，它只显示最近的两条提交，实际上，这是 -<n> 选项的写法，其中的 n 可以是任何整数，表示仅显示最近的若干条提交。不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调 用分页程序，所以你一次只会看到一页的内容。</p>
<p>另外还有按照时间作限制的选项，比如 –since 和 –until 也很有用。例如，下面的命令列出所有最近两周内的提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --since=2.weeks</span><br></pre></td></tr></table></figure>

<p>另一个非常有用的筛选选项是 -S，可以列出那些添加或移除了某些字符串的提交。比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -SModified</span><br></pre></td></tr></table></figure>

<p> 限制 git log 输出的选项:</p>
<p><img data-src="https://s1.ax1x.com/2022/06/19/XjBAAK.png" alt="限制 git log 输出的选项"></p>
<h3 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h3><p>在任何一个阶段，你都有可能想要撤消某些操作。这里，我们将会学习几个撤消你所做修改的基本工具。</p>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 –amend 选项的提交命令尝试重新提交，这个命令会将暂存区中的文件提交。：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p>
<h4 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h4><p>例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了git add * 暂存了它们两个。如何只取消暂存两个中的一个呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset HEAD CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<h4 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h4><p>如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -- CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><blockquote>
<p>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。</p>
</blockquote>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。它会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>

<p>你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>首先在github上创建一个仓库，然后clone到本地，再然后运行git remote add <shortname> <url> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add gs https://github.com/mygit-WK/gStudy.git</span><br></pre></td></tr></table></figure>

<p>现在你可以在命令行中使用字符串 gs来代替整个 URL。例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch gs：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch gs</span><br></pre></td></tr></table></figure>

<h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>从远程仓库中获得数据，可以执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch [remote-name]</span><br></pre></td></tr></table></figure>

<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 </p>
<p>如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。所以git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。必须注意 git fetch 命令会将数据拉取到你的本地仓库它并不会自动合并或修改你当前的工作。</p>
<p>如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。这个命令很简单：git push [remote-name] [branch-name]。当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p>
<h3 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure>

<h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rename gs gitstudy</span><br></pre></td></tr></table></figure>

<p>可以使用 git remote rm 来移除远程仓库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> gitstudy</span><br></pre></td></tr></table></figure>

<h2 id="git标签"><a href="#git标签" class="headerlink" title="git标签"></a>git标签</h2><h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>

<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）</p>
<p>在 Git 中创建一个附注标签是很简单的。最简单的方式是当你在运行 tag 命令时指定 -a 选项，-m 选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag -a v1.0 -m <span class="string">&#x27;my version 1.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过使用 git show 命令可以看到标签信息与对应的提交信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git show v1.0</span><br></pre></td></tr></table></figure>

<p>另一种给提交打标签的方式是使用轻量标签。轻量标签本质上是将提交校验和存储到一个文件中,没有保存任何其他信息。创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag v1.0-lw</span><br></pre></td></tr></table></figure>

<h3 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h3><p>你也可以对过去的提交打标签。现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。你可以在之后补上标签。要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -a v1.2 9fceb02</span><br></pre></td></tr></table></figure>

<h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样 - 你可以运行 git push origin [tagname]。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin v1.5</span><br></pre></td></tr></table></figure>

<p>如果想要一次性推送很多标签，也可以使用带有 –tags 选项的 git push 命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b version2 v2.0.0</span><br></pre></td></tr></table></figure>

<h3 id="Git-别名"><a href="#Git-别名" class="headerlink" title="Git 别名"></a>Git 别名</h3><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的 Git 命令，可以通过 gitconfig 文件来轻松地为每一个命令设置一个别名。这里有一些例子你可以试试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>

<p>这意味着，当要输入 git commit<code>时，只需要输入 </code>git ci。</p>
<p>可以向 Git 中 添加你自己的取消暂存别名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git unstage fileA</span><br><span class="line">git reset HEAD -- fileA</span><br></pre></td></tr></table></figure>

<p>通常也会添加一个 last 命令，可以轻松地看到最后一次提交：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global alias.last <span class="string">&#x27;log -1 HEAD&#x27;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
